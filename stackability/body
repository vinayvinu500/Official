create or replace PACKAGE BODY us_vmi_stackability AS
    PROCEDURE p_vmi_create_udc IS
        /******************************************************************
          Procedure : p_vmi_create_udc
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam 
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          01-Nov-2024     Surendra Ankita           Initial Version
          01-Nov-2024     Abhay Shukla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Initial / Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_create_udc';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA SERIALLY_REUSABLE;

    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Take backup of tables in p_vmi_create_udc';
               
        EXECUTE IMMEDIATE 'CREATE OR REPLACE FORCE EDITIONABLE VIEW "BATCHMGR"."UDC" ("SCHEDARRIVDATE", "SCHEDSHIPDATE", "MIN_SCHEDSHIPDATE", "MAX_SCHEDSHIPDATE", "ITEM", "NEEDSHIPDATE", "NEEDARRIVDATE", "U_STACKABILITYTYPE", "SOURCE", "DEST", "TRANSMODE", "AVAILTOSHIPDATE", "RECQTY", "SALES_UNITS_QTY", "PALLETS_QTY", "RATIO", "MINORSHIPQTY", "MAJORSHIPQTY", "PICKED_RATIO", "U_SOURCINGMIN", "U_DISPATCHDATE", "MUSTGODAYS", "LOOKAHEADDAYS", "TRANSMODEMINRULE", "TRANSLEADTIME", "U_CAPCONSTRSW", "MINCAP", "MAXCAP", "WGT", "U_ITEM_MINTRUCKSTACKCAP", "U_ITEM_MAXTRUCKSTACKCAP", "SOURCECATEGORY", "TARGETCATEGORY", "SOURCEUOM", "TARGETUOM", "UOM", "U_ADJUSTEDMAXCAP", "DEFAULTUOM", "U_VARIANT_TYPE_DESC", "U_PRIORITY", "SEQNUM", "SID", "ARRIVCAL", "SHIPCAL", "CONSTRRECSHIPSW") AS 
          select
            distinct
            TO_DATE(recship.schedarrivdate, ''DD-MM-YY'') as schedarrivdate,
            TO_DATE(recship.schedshipdate, ''DD-MM-YY'') as schedshipdate,
            TO_DATE(u_dispatchdate, ''DD-MM-YY'') + TO_NUMBER(mustgodays/1440) as min_schedshipdate, /*u_dispatchdate + mustgodur*/
            TO_DATE(u_dispatchdate, ''DD-MM-YY'') + TO_NUMBER(mustgodays/1440) + TO_NUMBER(lookaheaddays/1440) as max_schedshipdate, /*u_dispatchdate + mustgodur + LOOKAHEADDAYS*/
            recship.item,
            recship.needshipdate,
            recship.needarrivdate,
            sourcing.u_stackabilitytype,
            recship.source,
            recship.dest,
            recship.transmode,
            recship.availtoshipdate,
            recship.qty as recqty,
            (recship.qty / sourcinguomconvfactor.ratio) as sales_units_qty,
            --round(recship.qty / sourcinguomconvfactor.ratio) as pallets_qty, -- We have commented this line and included below to fix 0 pallet rounding
            ceil(recship.qty / sourcinguomconvfactor.ratio) as pallets_qty, --We have commented this line to fix partial pallet rounding issue
            --ceil(recship.qty / sourcing.MAJORSHIPQTY) as pallets_qty,
            sourcinguomconvfactor.ratio,
            sourcing.MINORSHIPQTY,
            sourcing.MAJORSHIPQTY, -- paritial/full pallet fix
            dense_rank() over(partition by recship.schedshipdate, recship.source, recship.dest, recship.transmode, recship.item order by case when sourcinguomconvfactor.sourceuom = 95 then 1 else 2 end) picked_ratio, -- mark the pallet ratio first then second next in the duplicates of each recship -- hardcoded truck capacity to pallets by default from SU to Pallets instead of "targetUOM" 
            network.u_sourcingmin,
            network.u_dispatchdate,
            TO_NUMBER(mustgodays/1440) as mustgodays,
            TO_NUMBER(lookaheaddays/1440) as LOOKAHEADDAYS,
            network.transmodeminrule,
            TO_NUMBER(network.transleadtime / 1440) as transleadtime,
            TRANSMODECAP.U_CapConstrSw,
            TRANSMODECAP.mincap,
            TRANSMODECAP.maxcap,
            item.wgt,
            sourcing.u_item_mintruckstackcap,
            sourcing.u_item_maxtruckstackcap,
            sourcinguomconvfactor.sourcecategory,
            sourcinguomconvfactor.targetcategory,
            sourcinguomconvfactor.sourceuom,
            sourcinguomconvfactor.targetuom,
            TRANSMODECAP.uom,
            TRANSMODECAP.u_adjustedmaxcap,
            item.defaultuom,
            item.u_variant_type_desc,
            sourcing.u_priority,
            recship.Seqnum,
            sourcing.sid,
            sourcing.arrivcal,
            sourcing.shipcal,
            skudeploymentparam.constrrecshipsw
        from scpomgr.sourcing sourcing
        left join scpomgr.recship recship on sourcing.source = recship.source and sourcing.dest = recship.dest and sourcing.transmode = recship.transmode and sourcing.item = recship.item 
        left join scpomgr.sourcinguomconvfactor sourcinguomconvfactor on sourcing.source = sourcinguomconvfactor.source and sourcing.dest = sourcinguomconvfactor.dest and sourcing.transmode = sourcinguomconvfactor.transmode and sourcing.item = sourcinguomconvfactor.item 
        left join scpomgr.network network on sourcing.source = network.source and sourcing.dest = network.dest and sourcing.transmode = network.transmode 
        left join scpomgr.TRANSMODECAP TRANSMODECAP on TRANSMODECAP.transmode = network.transmode 
        left join scpomgr.item item on item.item = sourcing.item
        left join scpomgr.skudeploymentparam skudeploymentparam on skudeploymentparam.item = recship.item and skudeploymentparam.loc = recship.source
        where item.item like ''XUS%'' and item.item not like ''XUS_TS%''
        order by sourcing.u_priority, recship.source, recship.dest, recship.transmode, recship.item';
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_create_udc;

    PROCEDURE p_vmi_create_uom_ratios IS
        /******************************************************************
          Procedure : p_vmi_create_uom_ratios
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam 
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          01-Nov-2024     Surendra Ankita           Initial Version
          01-Nov-2024     Abhay Shukla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Initial / Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_create_uom_ratios';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA SERIALLY_REUSABLE;

    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Take backup of tables in p_vmi_create_uom_ratios';
               
        EXECUTE IMMEDIATE 'create or replace view uom_ratios as
            select 
                distinct
                udc.uom as key, 
                sourcinguomconvfactor.ratio as value,
                sourcinguomconvfactor.item as item,
                uom.plurallabel
            from sourcinguomconvfactor inner join udc 
            on udc.uom = sourcinguomconvfactor.sourceuom 
            and udc.targetuom = sourcinguomconvfactor.targetuom
            and udc.source = sourcinguomconvfactor.source
            and udc.dest = sourcinguomconvfactor.dest
            and udc.transmode = sourcinguomconvfactor.transmode
            and udc.item = sourcinguomconvfactor.item
            inner join uom on udc.uom = uom.uom
            Where sourcinguomconvfactor.item like (''XUS%'') and udc.item not like ''XUS_TS%''
            ;';
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_create_uom_ratios;
    
    PROCEDURE p_vmi_calculate_utilization_trucks IS
        /******************************************************************
          Procedure : p_vmi_calculate_utilization_trucks
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam 
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          01-Nov-2024     Surendra Ankita           Initial Version
          01-Nov-2024     Abhay Shukla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Initial / Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_calculate_utilization_trucks';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA SERIALLY_REUSABLE;
        
        v_count             NUMBER;
        v_utilization       NUMBER := 0;
        v_total_pallets     NUMBER := 0;
        v_max_pallets       NUMBER := 0;

    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        -- re-calculating the utilization to finalize and correct the error results (i.e, there were only few loads which were calculated wrongly twice)
        -- overridding the utilization results by freshly calculating the results based on u_recship not based on temp_visualization_results table
        FOR lds IN (
            SELECT DISTINCT 
                source, 
                dest,
                transmode,
                substr(u_variant_type_desc, 1, 2) as u_variant_type_desc,
                loadid,
                u_priority
            FROM
                BATCHMGR.u_recship
            ORDER BY 
                source, dest, transmode, substr(u_variant_type_desc, 1, 2), loadid, u_priority
        ) LOOP
            -- Correct pallet calculation (global doubling, not local)
            SELECT
                LEAST(
                    (2 * CEIL(SUM(CASE WHEN u_stackabilitytype = 'RED' THEN pallets_qty ELSE 0 END))) +
                    (2 * CEIL(SUM(CASE WHEN u_stackabilitytype = 'SS' THEN pallets_qty ELSE 0 END))) +
                    CEIL(SUM(CASE WHEN u_stackabilitytype = 'BLACK' THEN pallets_qty ELSE 0 END)) +
                    CEIL(SUM(CASE WHEN u_stackabilitytype = 'DS' THEN pallets_qty ELSE 0 END)) +
                    CEIL(SUM(CASE WHEN u_stackabilitytype = 'GREEN' THEN pallets_qty ELSE 0 END)) +
                    CEIL(SUM(CASE WHEN u_stackabilitytype = 'YELLOW' THEN pallets_qty ELSE 0 END)),
                    MAX(u_adjustedmaxcap)
                )
            INTO v_total_pallets
            FROM
                batchmgr.u_recship
            WHERE
                source = lds.source
                AND dest = lds.dest
                AND transmode = lds.transmode
                AND substr(u_variant_type_desc, 1, 2) = lds.u_variant_type_desc
                AND loadid = lds.loadid
                AND u_priority = lds.u_priority;
        
            -- Get max pallets
            SELECT
                MAX(u_adjustedmaxcap)
            INTO v_max_pallets
            FROM
                batchmgr.u_recship
            WHERE
                source = lds.source
                AND dest = lds.dest
                AND transmode = lds.transmode
                AND substr(u_variant_type_desc, 1, 2) = lds.u_variant_type_desc
                AND loadid = lds.loadid
                AND u_priority = lds.u_priority;
        
            -- Calculate pallet utilization
            v_utilization := ( v_total_pallets / v_max_pallets ) * 100;
            
            -- Add weight calculation
            DECLARE
                v_total_weight NUMBER := 0;
                v_max_weight NUMBER := 0;
                v_weight_utilization NUMBER := 0;
                v_final_utilization NUMBER := 0;
                -- Debug variables
                v_red_qty NUMBER := 0;
                v_ss_qty NUMBER := 0;
                v_black_qty NUMBER := 0;
                v_ds_qty NUMBER := 0;
                v_green_qty NUMBER := 0;
                v_yellow_qty NUMBER := 0;
            BEGIN
                -- Get individual color quantities for debugging
                SELECT
                    SUM(CASE WHEN u_stackabilitytype = 'RED' THEN pallets_qty ELSE 0 END),
                    SUM(CASE WHEN u_stackabilitytype = 'SS' THEN pallets_qty ELSE 0 END),
                    SUM(CASE WHEN u_stackabilitytype = 'BLACK' THEN pallets_qty ELSE 0 END),
                    SUM(CASE WHEN u_stackabilitytype = 'DS' THEN pallets_qty ELSE 0 END),
                    SUM(CASE WHEN u_stackabilitytype = 'GREEN' THEN pallets_qty ELSE 0 END),
                    SUM(CASE WHEN u_stackabilitytype = 'YELLOW' THEN pallets_qty ELSE 0 END)
                INTO
                    v_red_qty, v_ss_qty, v_black_qty, v_ds_qty, v_green_qty, v_yellow_qty
                FROM
                    batchmgr.u_recship
                WHERE
                    source = lds.source
                    AND dest = lds.dest
                    AND transmode = lds.transmode
                    AND substr(u_variant_type_desc, 1, 2) = lds.u_variant_type_desc
                    AND loadid = lds.loadid
                    AND u_priority = lds.u_priority;
                
                /*
                -- Debug output
                DBMS_OUTPUT.PUT_LINE('Load: ' || lds.source || '_' || lds.dest || '_' || 
                                   lds.u_variant_type_desc || '_' || lds.loadid || '_' || lds.u_priority);
                DBMS_OUTPUT.PUT_LINE('  Color breakdown: RED=' || v_red_qty || ', SS=' || v_ss_qty || 
                                   ', BLACK=' || v_black_qty || ', DS=' || v_ds_qty || 
                                   ', GREEN=' || v_green_qty || ', YELLOW=' || v_yellow_qty);
                DBMS_OUTPUT.PUT_LINE('  Calculated slots: RED=' || (2 * CEIL(v_red_qty)) || 
                                   ', SS=' || (2 * CEIL(v_ss_qty)) || 
                                   ', Others=' || (CEIL(v_black_qty) + CEIL(v_ds_qty) + 
                                                 CEIL(v_green_qty) + CEIL(v_yellow_qty)));
                */
                
                -- Get weight totals
                SELECT
                    NVL(SUM(updated_wgt), 0),
                    NVL(MAX(updated_maxcap_su_pounds), 0)
                INTO
                    v_total_weight,
                    v_max_weight
                FROM
                    batchmgr.u_recship
                WHERE
                    source = lds.source
                    AND dest = lds.dest
                    AND transmode = lds.transmode
                    AND substr(u_variant_type_desc, 1, 2) = lds.u_variant_type_desc
                    AND loadid = lds.loadid
                    AND u_priority = lds.u_priority;
                
                -- Calculate weight utilization
                IF v_max_weight > 0 THEN
                    v_weight_utilization := (v_total_weight / v_max_weight) * 100;
                ELSE
                    v_weight_utilization := 0;
                END IF;
                
                /*
                DBMS_OUTPUT.PUT_LINE('  Pallets: ' || v_total_pallets || '/' || v_max_pallets || 
                                   ' = ' || ROUND(v_utilization, 2) || '%');
                DBMS_OUTPUT.PUT_LINE('  Weight: ' || ROUND(v_total_weight, 2) || '/' || ROUND(v_max_weight, 2) || 
                                   ' = ' || ROUND(v_weight_utilization, 2) || '%');
                */
                
                -- Take the greater utilization
                v_final_utilization := GREATEST(v_utilization, v_weight_utilization);
                v_final_utilization := CASE WHEN v_final_utilization > 100 THEN 100 ELSE v_final_utilization END;
                
                --DBMS_OUTPUT.PUT_LINE('  Final Utilization: ' || ROUND(v_final_utilization, 2) || '%');
                
                -- Update
                UPDATE u_recship 
                SET utilization = ROUND(v_final_utilization, 2) 
                WHERE source = lds.source 
                    AND dest = lds.dest 
                    AND transmode = lds.transmode
                    AND substr(u_variant_type_desc, 1, 2) = lds.u_variant_type_desc 
                    AND loadid = lds.loadid 
                    AND u_priority = lds.u_priority;
            END;
            
        END LOOP;
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_calculate_utilization_trucks;

    PROCEDURE p_vmi_create_priority_list IS
        /******************************************************************
          Procedure : p_vmi_create_priority_list
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam 
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          01-Nov-2024     Surendra Ankita           Initial Version
          01-Nov-2024     Abhay Shukla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Initial / Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_create_priority_list';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA SERIALLY_REUSABLE;

    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Take backup of tables in p_vmi_create_priority_list';
               
        EXECUTE IMMEDIATE 'CREATE OR REPLACE FORCE EDITIONABLE VIEW "BATCHMGR"."PRIORITY_LIST" ("SOURCE", "DEST", "TRANSMODE", "U_VARIANT_TYPE_DESC", "ITEM", "U_STACKABILITYTYPE", "U_PRIORITY", "SID", "U_SOURCINGMIN") AS 
              select sourcing.source, sourcing.dest, sourcing.transmode, 
              sku.u_variant_type_desc,
              item.item, sourcing.u_stackabilitytype, sourcing.u_priority, sourcing.sid, network.u_sourcingmin
            from scpomgr.sourcing sourcing
            inner join scpomgr.sku sku on sourcing.item = sku.item and sourcing.dest = sku.loc
            left join scpomgr.network network on sourcing.source = network.source and sourcing.dest = network.dest and sourcing.transmode = network.transmode
            left join scpomgr.item item on sourcing.item = item.item
            where item.item like ''XUS%'' and item.item not like (''XUS_TS%'')
            ORDER BY sourcing.dest, sourcing.transmode, sku.u_variant_type_desc, item.item, sourcing.u_stackabilitytype';
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_create_priority_list;
    
    PROCEDURE p_vmi_backuptables IS
        /******************************************************************
          Procedure : P_VMI_BACKUPTABLES
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          15-July-2024    Sahil Chawla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_BACKUPTABLES';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA SERIALLY_REUSABLE;

    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Take backup of tables in P_VMI_BACKUPTABLES';
               
         BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE batchmgr.recship_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;

        EXECUTE IMMEDIATE 'create table batchmgr.recship_prebkp as select * from scpomgr.recship';
        COMMIT;

        l_v_errstep := 'DROP TABLE batchmgr.udc_recship_prebkp';
         BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE batchmgr.udc_recship_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.udc_recship_prebkp as select * from batchmgr.udc_recship';
        COMMIT;
       
        l_v_errstep := 'Drop TABLE batchmgr.u_recship_prebkp';
        BEGIN
            EXECUTE IMMEDIATE 'Drop TABLE batchmgr.u_recship_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
     
        EXECUTE IMMEDIATE 'create table batchmgr.u_recship_prebkp as select * from batchmgr.u_recship';
        COMMIT;
        
        l_v_errstep := 'Drop table batchmgr.u_recship_mincap_prebkp';

        BEGIN
            EXECUTE IMMEDIATE 'Drop table batchmgr.u_recship_mincap_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.u_recship_mincap_prebkp as select * from batchmgr.u_recship_mincap';
        COMMIT;
        
        l_v_errstep := 'Drop table batchmgr.priority_shift_pallets_conv_prebkp';

        BEGIN
            EXECUTE IMMEDIATE 'Drop table batchmgr.priority_shift_pallets_conv_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.priority_shift_pallets_conv_prebkp as select * from batchmgr.priority_shift_pallets_conv';
        COMMIT;
        
        l_v_errstep := 'Drop table batchmgr.priority_shift_pallets_prebkp';

        BEGIN
            EXECUTE IMMEDIATE 'Drop table batchmgr.priority_shift_pallets_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.priority_shift_pallets_prebkp as select * from batchmgr.priority_shift_pallets';
        COMMIT;
        
        l_v_errstep := 'Drop table batchmgr.Vehicleload_prebkp';

         BEGIN
            EXECUTE IMMEDIATE 'Drop table batchmgr.Vehicleload_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.Vehicleload_prebkp as select * from scpomgr.Vehicleload';
        COMMIT;


          l_v_errstep := 'Drop table batchmgr.Vehicleloadline_prebkp';
         BEGIN
            EXECUTE IMMEDIATE 'Drop table batchmgr.Vehicleloadline_prebkp';
        EXCEPTION
            WHEN OTHERS THEN
                IF sqlcode != -942 THEN
                    RAISE;
                END IF;
        END;
        EXECUTE IMMEDIATE 'create table batchmgr.Vehicleloadline_prebkp as select * from scpomgr.Vehicleloadline';
        COMMIT;
        
        
        --dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
          -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_backuptables;

--    PROCEDURE p_vmi_create_udc_recship IS 
--    /******************************************************************
--      Procedure : P_VMI_CREATE_UDC_RECSHIP
--      Description : creation of the udc_recship table which is the combination/amalgum of the BY standard tables(recship, sourcing, sourcinguomconvfactor,network, transmodecap, item) into one single udt table where all key relevant columns are showed as one single record
--      Output Parameters: None
--      Error Conditions Raised: When Others
--      Author: Vinay Govardhanam
--      Revision History:
--      ------------------
--      Date            Author                    Description
--      ----            -----                     ------------
--      15-July-2024    Sahil Chawla              Initial Version
--      06-June-2024    Vinay Kumar Govardhanam   Modified Version
--      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--      *******************************************************************/
--      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_UDC_RECSHIP';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_weight            NUMBER;
--    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'CALCULATE TABLE SCPOMGR.P_VMI_CREATE_UDC_RECSHIP';
--        
--        -- Check if table exists, if not create it
--        --EXECUTE IMMEDIATE 'SELECT 1 FROM udc_recship WHERE ROWNUM = 1';
--        BEGIN
--            EXECUTE IMMEDIATE 'DROP TABLE batchmgr.udc_recship';
--        EXCEPTION
--            WHEN OTHERS THEN
--                IF sqlcode != -942 THEN
--                    RAISE;
--                END IF;
--        END;
--        EXECUTE IMMEDIATE 'CREATE TABLE batchmgr.udc_recship (
--                        schedarrivdate DATE,
--                        schedshipdate DATE,
--                        availtoshipdate DATE,
--                        min_schedshipdate DATE,
--                        max_schedshipdate DATE,
--                        u_dispatchdate DATE,
--                        LOOKAHEADDAYS NUMBER,
--                        mustgodays NUMBER,
--                        source VARCHAR2(100),
--                        dest VARCHAR2(100),
--                        transmode VARCHAR2(100),
--                        u_variant_type_desc VARCHAR2(100),
--                        item VARCHAR2(100),
--                        u_stackabilitytype VARCHAR2(100),
--                        recqty NUMBER,
--                        sales_units_qty FLOAT,
--                        pallets_qty NUMBER,
--                        u_sourcingmin NUMBER,
--                        ratio FLOAT,
--                        MINORSHIPQTY NUMBER,
--                        MAJORSHIPQTY NUMBER,
--                        multiplication_ratio FLOAT,
--                        mincap_calculated_su FLOAT,
--                        updated_mincap_su FLOAT,
--                        updated_maxcap_su FLOAT,
--                        u_adjustedmaxcap FLOAT,
--                        transleadtime FLOAT,
--                        U_CapConstrSw NUMBER,
--                        transmodeminrule NUMBER,
--                        mincap NUMBER,
--                        maxcap NUMBER,
--                        u_item_mintruckstackcap NUMBER,
--                        u_item_maxtruckstackcap NUMBER,
--                        wgt NUMBER,
--                        uom NUMBER,
--                        PLURALLABEL VARCHAR2(100),
--                        sourceuom NUMBER,
--                        targetuom NUMBER,
--                        defaultuom NUMBER,
--                        u_priority NUMBER,
--                        Seqnum NUMBER,
--                        sid NUMBER,
--                        arrivcal VARCHAR2(100),
--                        shipcal VARCHAR2(100),
--                        CONSTRRECSHIPSW NUMBER,
--                        needshipdate DATE,
--                        needarrivdate DATE,
--                        
--                        -- majorshipqty fix
--                        acc_pallets_qty NUMBER,
--                        img_pallets_qty NUMBER,
--                        acc_sales_units_qty NUMBER,
--                        img_sales_units_qty NUMBER,
--                        exp_sales_units_qty NUMBER,
--                    
--                        -- additional columns
--                        updated_wgt FLOAT,
--                        pounds_qty FLOAT,
--                        sourcingid NUMBER, -- no of source been designated to truckid
--                        sourcingid_seq NUMBER,
--                        condition VARCHAR2(10),
--                        color_priority_sourcingid_seq NUMBER, -- color priority precedence,
--
--                        -- dynamic columns
--                        SU_PALLETS_RATIO FLOAT,
--                        UPDATED_MINCAP_SU_PALLETS FLOAT,
--                        UPDATED_MAXCAP_SU_PALLETS FLOAT,
--                        SU_POUNDS_RATIO FLOAT,
--                        UPDATED_MINCAP_SU_POUNDS FLOAT,
--                        UPDATED_MAXCAP_SU_POUNDS FLOAT,
--                        SU_PALLETBASES_RATIO FLOAT,
--                        UPDATED_MINCAP_SU_PALLETBASES FLOAT,
--                        UPDATED_MAXCAP_SU_PALLETBASES FLOAT,
--                        SU_PALLETBASES_PALLETS_CONV FLOAT,
--                        UPD_MINCAP_SU_PALLETBASES_PAL FLOAT,
--                        UPD_MAXCAP_SU_PALLETBASES_PAL FLOAT
--                    )';
--  
--      -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
--      -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_udc_recship;

--    PROCEDURE p_vmi_create_priorityshift IS 
--    /******************************************************************
--      Procedure : P_VMI_CREATE_PRIORITYSHIFT
--      Description : creation of the priority_shift table which is the combination/amalgum of the BY standard tables(sourcing) & view (priority_list), the table reference of the plant and hub locations as source1 & source2 respectively
--      Output Parameters: None
--      Error Conditions Raised: When Others
--      Author: Vinay Govardhanam
--      Revision History:
--      ------------------
--      Date            Author                    Description
--      ----            -----                     ------------
--      15-July-2024    Sahil Chawla              Initial Version
--      06-June-2024    Vinay Kumar Govardhanam   Modified Version
--      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--      *******************************************************************/
--      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_PRIORITYSHIFT';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_weight            NUMBER;
--    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'CALCULATE TABLE SCPOMGR.P_VMI_CREATE_PRIORITYSHIFT';
--        
--        -- Check if table exists, if not create it
--        EXECUTE IMMEDIATE 'drop table batchmgr.priority_shift';
--        EXECUTE IMMEDIATE 'create table batchmgr.priority_shift(
--                "DEST" VARCHAR2(1000 BYTE), 
--                "U_VARIANT_TYPE_DESC" VARCHAR2(1000 BYTE), 
--                "ITEM" VARCHAR2(1000 BYTE), 
--                "SID" NUMBER, 
--                "SOURCE1" VARCHAR2(1000 BYTE), 
--                "SOURCE2" VARCHAR2(1000 BYTE), 
--                "TRANSMODE1" VARCHAR2(1000 BYTE), 
--                "TRANSMODE2" VARCHAR2(1000 BYTE), 
--                "U_STACKABILITYTYPE1" VARCHAR2(1000 BYTE), 
--                "U_STACKABILITYTYPE2" VARCHAR2(1000 BYTE), 
--                "U_PRIORITY1" NUMBER, 
--                "U_PRIORITY2" NUMBER, 
--                "U_SOURCINGMIN1" NUMBER, 
--                "U_SOURCINGMIN2" NUMBER, 
--                 PRIMARY KEY ("DEST", "U_VARIANT_TYPE_DESC", "ITEM", "SID")
--            )';
--  
--      -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
--      -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_priorityshift;

    PROCEDURE p_vmi_intializingthevalues IS
        /******************************************************************
          Procedure : P_VMI_INTIALIZINGTHEVALUES
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          15-July-2024    Sahil Chawla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INTIALIZINGTHEVALUES';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        PRAGMA AUTONOMOUS_TRANSACTION;
        
    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');
        

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Initialize the values in P_VMI_INTIALIZINGTHEVALUES';
            
            -- updating the network table where u_dispatchdate is current date
        UPDATE scpomgr.network
        SET
            -- u_dispatchdate = sysdate;
            u_dispatchdate = (select to_date(param_value, 'DD-MM-YY') AS param_value from scpomgr.u_parameter  where process_name='BATCH' and param_name= 'PROCESS_DATE' and param_group='CALENDAR' and note='Process Date');
            -- Commit the transaction
        COMMIT;  
            
            -- updating the transmodecap table where u_adjustedmaxcap is calculated dynamically
        UPDATE scpomgr.transmodecap
        SET
            u_adjustedmaxcap = round(maxcap -(u_buffer * maxcap));
           
            -- Commit the transaction
        COMMIT;  
           
        -- updating the sourcing table where SID to identify the plant and hub location
        MERGE INTO scpomgr.sourcing t
        USING (
                  SELECT
                      ROWID AS rid,
                      DENSE_RANK()
                      OVER(
                          ORDER BY
                              dest, item
                      )     AS sid
                  FROM
                      scpomgr.sourcing
              )
        r ON ( t.rowid = r.rid )
        WHEN MATCHED THEN UPDATE
        SET t.sid = r.sid;

        --dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
          -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_intializingthevalues;

    PROCEDURE p_vmi_insert_into_udcrecship IS
        /******************************************************************
          Procedure : P_VMI_INSERT_INTO_UDCRECSHIP
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          15-July-2024    Sahil Chawla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INSERT_INTO_UDCRECSHIP';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Initialize the values in P_VMI_INSERT_INTO_UDCRECSHIP';
        
        EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.udc_recship';
        
        INSERT /*+parallel(16) */ INTO batchmgr.udc_recship (
            schedarrivdate,
            schedshipdate,
            availtoshipdate,
            min_schedshipdate,
            max_schedshipdate,
            u_dispatchdate,
            lookaheaddays,
            mustgodays,
            source,
            dest,
            transmode,
            u_variant_type_desc,
            item,
            u_stackabilitytype,
            recqty,
            sales_units_qty,
            pallets_qty,
            u_sourcingmin,
            ratio,
            minorshipqty,
            majorshipqty,
            multiplication_ratio,
            mincap_calculated_su,
            updated_mincap_su,
            updated_maxcap_su,
            u_adjustedmaxcap,
            transleadtime,
            u_capconstrsw,
            transmodeminrule,
            mincap,
            maxcap,
            u_item_mintruckstackcap,
            u_item_maxtruckstackcap,
            wgt,
            uom,
            plurallabel,
            sourceuom,
            targetuom,
            defaultuom,
            u_priority,
            seqnum,
            sid,
            shipcal,
            arrivcal,
            constrrecshipsw,
            needshipdate,
            needarrivdate,
            -- majorshipqty fix
            acc_pallets_qty,
            img_pallets_qty,
            acc_sales_units_qty,
            img_sales_units_qty,
            exp_sales_units_qty
        )
            SELECT /*+parallel(16) */ DISTINCT
                to_date(schedarrivdate, 'DD-MM-YY')                                                              schedarrivdate,
                to_date(schedshipdate, 'DD-MM-YY')                                                               schedshipdate,
                to_date(availtoshipdate, 'DD-MM-YY')                                                               availtoshipdate,
                to_date(min_schedshipdate, 'DD-MM-YY')                                                           min_schedshipdate,
                to_date(max_schedshipdate, 'DD-MM-YY')                                                           max_schedshipdate,
                u_dispatchdate,
                lookaheaddays,
                mustgodays,
                udc.source,
                udc.dest,
                udc.transmode,
                --case when upper(trim(u_variant_type_desc)) = 'PROMO' then 'BASE / PROMO' ELSE u_variant_type_desc END as u_variant_type_desc, -- need to change
                u_variant_type_desc,
                udc.item,
                u_stackabilitytype,
                recqty,
                sales_units_qty,
                -- Calculate full_pallet_count and partial_su directly:
                --FLOOR(recqty / ratio) + CASE WHEN MOD(recqty, ratio) > 0 THEN 1 ELSE 0 END as pallets_qty,
                pallets_qty,
                u_sourcingmin,
                ratio,
                minorshipqty,
                majorshipqty,
                CASE
                    WHEN ( udc.uom = uom_ratios.key
                           AND udc.item = uom_ratios.item 
                           AND udc.source = uom_ratios.source 
                           AND udc.dest = uom_ratios.dest 
                           AND udc.transmode = uom_ratios.transmode
                           ) THEN
                        uom_ratios.value
                    ELSE
                        1
                END                                                                                              AS multiplication_ratio,
                mincap *
                CASE
                    WHEN ( udc.uom = uom_ratios.key
                           AND udc.item = uom_ratios.item 
                           AND udc.source = uom_ratios.source 
                           AND udc.dest = uom_ratios.dest 
                           AND udc.transmode = uom_ratios.transmode
                           ) THEN
                            uom_ratios.value
                    ELSE
                        1
                END
                AS mincap_calculated_su,
                CASE
                    WHEN ( u_capconstrsw = 1
                           AND transmodeminrule = 1 ) THEN
                        MAX(mincap *
                            CASE
                                WHEN(udc.uom = uom_ratios.key
                                     AND udc.item = uom_ratios.item
                                     AND udc.source = uom_ratios.source 
                                     AND udc.dest = uom_ratios.dest 
                                     AND udc.transmode = uom_ratios.transmode
                                       ) THEN
                                    uom_ratios.value
                                ELSE
                                    1
                            END
                        )
                        OVER(PARTITION BY udc.source, udc.dest, udc.transmode, udc.item
                             ORDER BY
                                 schedshipdate
                        )
                    WHEN ( u_capconstrsw = 1
                           AND transmodeminrule = 2 ) THEN
                        MIN(mincap *
                            CASE
                                WHEN(udc.uom = uom_ratios.key
                                     AND udc.item = uom_ratios.item
                                     AND udc.source = uom_ratios.source 
                                     AND udc.dest = uom_ratios.dest 
                                     AND udc.transmode = uom_ratios.transmode
                                     ) THEN
                                    uom_ratios.value
                                ELSE
                                    1
                            END
                        )
                        OVER(PARTITION BY udc.source, udc.dest, udc.transmode, udc.item
                             ORDER BY
                                 schedshipdate
                        )
                    WHEN u_capconstrsw = 0 THEN
                        0
                    ELSE
                        mincap *
                        CASE
                            WHEN ( udc.uom = uom_ratios.key
                                   AND udc.item = uom_ratios.item 
                                   AND udc.source = uom_ratios.source 
                                   AND udc.dest = uom_ratios.dest 
                                   AND udc.transmode = uom_ratios.transmode
                                     ) THEN
                                    uom_ratios.value
                            ELSE
                                1
                        END
                END                                                                                              AS updated_mincap_su,
                maxcap *
                CASE
                    WHEN ( udc.uom = uom_ratios.key 
                        AND udc.item = uom_ratios.item 
                        AND udc.source = uom_ratios.source 
                        AND udc.dest = uom_ratios.dest 
                        AND udc.transmode = uom_ratios.transmode
                     )THEN
                            uom_ratios.value
                    ELSE
                        1
                END
                AS updated_maxcap_su,
                u_adjustedmaxcap,
                transleadtime,
                u_capconstrsw,
                transmodeminrule,
                mincap,
                maxcap,
                u_item_mintruckstackcap,
                u_item_maxtruckstackcap,
                wgt,
                uom,
                coalesce(plurallabel, 'Sales_Units')                                                             AS plurallabel, -- by default we don't have 'Sales_Units' ratio in which we are getting the default values as SU = 18 (ratio)
                sourceuom,
                targetuom,
                defaultuom,
                u_priority,
                seqnum,
                sid,
                shipcal,
                arrivcal,
                constrrecshipsw,
                needshipdate,
                needarrivdate,
            -- majorshipqty fix
                floor(recqty / ratio)                                                                            AS acc_pallets_qty,
                ceil(recqty / ratio) - floor(recqty / ratio)                                                     AS img_pallets_qty,
                floor(recqty / ratio) * ratio                                                                    AS acc_sales_units_qty,
                ( ceil(recqty / ratio) - floor(recqty / ratio) ) * ratio                                         AS img_sales_units_qty,
                ( floor(recqty / ratio) * ratio ) + ( ( ceil(recqty / ratio) - floor(recqty / ratio) ) * ratio ) AS exp_sales_units_qty
            FROM
                batchmgr.udc        udc
                LEFT JOIN batchmgr.uom_ratios uom_ratios ON udc.uom = uom_ratios.key
                                                           AND udc.item = uom_ratios.item 
                                                           AND udc.source = uom_ratios.source 
                                                           AND udc.dest = uom_ratios.dest 
                                                          AND udc.transmode = uom_ratios.transmode
            WHERE
                udc.source IS NOT NULL
                AND picked_ratio = 1
                /*
                AND CASE
                    WHEN ( udc.uom = uom_ratios.key
                           AND udc.item = uom_ratios.item 
                           AND udc.source = uom_ratios.source 
                           AND udc.dest = uom_ratios.dest 
                           AND udc.transmode = uom_ratios.transmode
                           ) THEN
                        uom_ratios.value
                    ELSE
                        1
                END <> 1 -- multiplication_ratio & updated_maxcap_su (filteration)*/
                AND pallets_qty > 0 -- Zero Quantity Issue (first fix)
                AND uom = 95; -- 338 rows -- removing the duplicates (sourcinguomconvfactor) -- hardcoded truck capacity to pallets by default from SU to Pallets instead of target UOM 
        
        COMMIT;
        
        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET
            condition =
                CASE
                    WHEN to_date(schedshipdate, 'DD-MM-YY') <= to_date(min_schedshipdate, 'DD-MM-YY') THEN
                        'FIRST'
                    WHEN to_date(schedshipdate, 'DD-MM-YY') <= to_date(max_schedshipdate, 'DD-MM-YY') THEN
                        'SECOND'
                    ELSE
                        'ELSE'
                END;
        
        COMMIT;
        
        -- Extract of the pre & post udc_recship
        EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.udc_recship_extract';
        COMMIT;
        EXECUTE IMMEDIATE 'INSERT INTO batchmgr.udc_recship_extract select * from udc_recship';
        COMMIT;
        
        -- First update the golden records with all calculations (error)
        UPDATE udc_recship u
        SET 
            recqty = (
                SELECT total_recqty
                FROM (
                    SELECT 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition,
                        SUM(recqty) as total_recqty,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
            ),
            SALES_UNITS_QTY = (
                SELECT total_recqty/RATIO
                FROM (
                    SELECT 
                        source, dest, transmode, u_variant_type_desc, 
                        u_stackabilitytype, item, sid, condition,
                        SUM(recqty) as total_recqty,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, dest, transmode, u_variant_type_desc, 
                        u_stackabilitytype, item, sid, condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
            ),
            seqnum = (
                SELECT seqnum
                FROM (
                    SELECT 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition,
                        MIN(seqnum) as seqnum,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
            ),
            schedshipdate = (
                SELECT schedshipdate
                FROM (
                    SELECT 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition,
                        MIN(schedshipdate) as schedshipdate,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
            ),
            schedarrivdate = (
                SELECT schedarrivdate
                FROM (
                    SELECT 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition,
                        MIN(schedarrivdate) as schedarrivdate,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, 
                        dest, 
                        transmode, 
                        u_variant_type_desc, 
                        u_stackabilitytype, 
                        item, 
                        sid, 
                        condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
            ),
            PALLETS_QTY = --CEIL
            (
                (SELECT total_recqty/RATIO
                FROM (
                    SELECT 
                        source, dest, transmode, u_variant_type_desc, 
                        u_stackabilitytype, item, sid, condition,
                        SUM(recqty) as total_recqty,
                        MIN(ROWID) as keep_rowid
                    FROM udc_recship
                    WHERE condition = 'FIRST'
                    GROUP BY 
                        source, dest, transmode, u_variant_type_desc, 
                        u_stackabilitytype, item, sid, condition
                ) sr
                WHERE sr.source = u.source
                AND sr.dest = u.dest
                AND sr.transmode = u.transmode
                AND sr.u_variant_type_desc = u.u_variant_type_desc
                AND sr.u_stackabilitytype = u.u_stackabilitytype
                AND sr.item = u.item
                AND sr.sid = u.sid
                AND sr.condition = u.condition
                )
            )
        WHERE u.condition = 'FIRST'
        AND u.ROWID IN (
            SELECT MIN(ROWID)
            FROM udc_recship
            WHERE condition = 'FIRST'
            GROUP BY 
                source, dest, transmode, u_variant_type_desc, 
                u_stackabilitytype, item, sid, condition
        );
        
        COMMIT;
        
        -- Then delete the duplicates apart from golden record
        DELETE FROM udc_recship
        WHERE condition = 'FIRST'
        AND ROWID NOT IN (
            SELECT MIN(ROWID)
            FROM udc_recship
            WHERE condition = 'FIRST'
            GROUP BY 
                source, dest, transmode, u_variant_type_desc, 
                u_stackabilitytype, item, sid, condition
        );
        
        COMMIT;
        
        --dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
          -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_insert_into_udcrecship;

    PROCEDURE p_vmi_insert_into_priorityshift IS
        /******************************************************************
          Procedure : P_VMI_INSERT_INTO_PRIORITYSHIFT
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          15-July-2024    Sahil Chawla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time        iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time          iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep                iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id                     iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name              scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INSERT_INTO_PRIORITYSHIFT';
        l_v_prog_status            scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency              scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        CURSOR c_aggregate IS
        SELECT
            dest,
            u_variant_type_desc,
            item,
            u_priority,
            sid,
            source,
            transmode,
            u_stackabilitytype,
            u_sourcingmin
        FROM
            batchmgr.priority_list -- Assuming priority_list is the view
        ORDER BY
            dest,            
            u_variant_type_desc,
            item,
            u_priority,
            sid,
            source,
            transmode,
            u_stackabilitytype,
            u_sourcingmin;

        v_dest                     batchmgr.priority_list.dest%TYPE;
        --v_transmode                batchmgr.priority_list.transmode%TYPE;
        v_u_variant_type_desc      batchmgr.priority_list.u_variant_type_desc%TYPE;
        v_item                     batchmgr.priority_list.item%TYPE;
        v_u_priority               batchmgr.priority_list.u_priority%TYPE;
        v_sid                      batchmgr.priority_list.sid%TYPE;
        v_source_list              source_table := source_table();
        v_u_stackabilitytype_list  u_stackabilitytype_table := u_stackabilitytype_table();
        v_transmode_list           transmode_table := transmode_table();
        v_source1                  VARCHAR2(4000); -- Increased size
        v_source2                  VARCHAR2(4000); -- Increased size
        v_transmode1               VARCHAR2(4000); -- Increased size
        v_transmode2               VARCHAR2(4000); -- Increased size
        v_u_stackabilitytype1      VARCHAR2(4000); -- Increased size
        v_u_stackabilitytype2      VARCHAR2(4000); -- Increased size
        v_prev_dest                batchmgr.priority_list.dest%TYPE;
        --v_prev_transmode           batchmgr.priority_list.transmode%TYPE;
        v_prev_u_variant_type_desc batchmgr.priority_list.u_variant_type_desc%TYPE;
        v_prev_item                batchmgr.priority_list.item%TYPE;
        v_prev_u_priority          batchmgr.priority_list.u_priority%TYPE;
        v_prev_sid                 batchmgr.priority_list.sid%TYPE;
        v_first                    BOOLEAN := true;
        v_u_sourcingmin1           NUMBER;
        v_u_sourcingmin2           NUMBER;
    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Insert into priorityshift table in P_VMI_INSERT_INTO_PRIORITYSHIFT';
        
        EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.priority_shift';
        
        FOR rec IN c_aggregate LOOP
            -- Check if it's the first record or if the group matches the previous record
            IF v_first OR (
                rec.dest = v_prev_dest
                --AND rec.transmode = v_prev_transmode -- due to change of transmode from 'TRUCK_USA' to 'CPU TRUCK USA'
                AND rec.u_variant_type_desc = v_prev_u_variant_type_desc
                AND rec.item = v_prev_item
                AND rec.sid = v_prev_sid
            ) THEN
                v_source_list.extend;
                v_source_list(v_source_list.count) := rec.source;
                v_u_stackabilitytype_list.extend;
                v_u_stackabilitytype_list(v_u_stackabilitytype_list.count) := rec.u_stackabilitytype;
                v_transmode_list.extend;
                v_transmode_list(v_transmode_list.count) := rec.transmode;
            ELSE
                -- Check if there are at least two sources in the list
                IF v_source_list.count >= 2 THEN
                    v_source1 := v_source_list(1);
                    v_source2 := v_source_list(2);
                    v_u_stackabilitytype1 := v_u_stackabilitytype_list(1);
                    v_u_stackabilitytype2 := v_u_stackabilitytype_list(2);
                    v_transmode1 := v_transmode_list(1);
                    v_transmode2 := v_transmode_list(2);
                    
                    -- Get u_sourcingmin values for source1 and source2
                    SELECT
                        u_sourcingmin
                    INTO v_u_sourcingmin1
                    FROM
                        batchmgr.priority_list
                    WHERE
                            dest = v_prev_dest
                        --AND transmode = v_prev_transmode -- due to change of transmode from 'TRUCK_USA' to 'CPU TRUCK USA'
                        AND substr(u_variant_type_desc,1,2) = substr(v_prev_u_variant_type_desc,1,2)
                        AND item = v_prev_item
                        AND source = v_source1
                        AND transmode = v_transmode1;

                    SELECT
                        u_sourcingmin
                    INTO v_u_sourcingmin2
                    FROM
                        batchmgr.priority_list
                    WHERE
                            dest = v_prev_dest
                        --AND transmode = v_prev_transmode -- due to change of transmode from 'TRUCK_USA' to 'CPU TRUCK USA'
                        --AND substr(u_variant_type_desc,1,2) = substr(v_prev_u_variant_type_desc,1,2)
                        AND item = v_prev_item
                        AND source = v_source2
                        AND transmode = v_transmode2;
                    
                    -- Insert into the results table
                    INSERT INTO batchmgr.priority_shift (
                        dest,
                        --transmode,
                        u_variant_type_desc,
                        item,
                        u_priority1,
                        u_priority2,
                        sid,
                        source1,
                        source2,
                        transmode1,
                        transmode2,
                        u_stackabilitytype1,
                        u_stackabilitytype2,
                        u_sourcingmin1,
                        u_sourcingmin2
                    ) VALUES (
                        v_prev_dest,
                        --v_prev_transmode,
                        --case when upper(trim(v_prev_u_variant_type_desc)) = 'PROMO' then 'BASE / PROMO' ELSE v_prev_u_variant_type_desc END,
                        v_prev_u_variant_type_desc,
                        v_prev_item,
                        coalesce(v_prev_u_priority, 1),
                        2,
                        v_prev_sid,
                        v_source1,
                        v_source2,
                        v_transmode1,
                        v_transmode2,
                        v_u_stackabilitytype1,
                        v_u_stackabilitytype2,
                        v_u_sourcingmin1,
                        v_u_sourcingmin2
                    );

                END IF;
    
                -- Start a new group
                v_source_list.DELETE;
                v_u_stackabilitytype_list.DELETE;
                v_transmode_list.DELETE;
                v_source_list.extend;
                v_source_list(1) := rec.source;
                v_u_stackabilitytype_list.extend;
                v_u_stackabilitytype_list(1) := rec.u_stackabilitytype;
                v_transmode_list.extend;
                v_transmode_list(1) := rec.transmode;
            END IF;
    
            -- Store the current record's values to compare with the next record
            v_prev_dest := rec.dest;
            --v_prev_transmode := rec.transmode;
            v_prev_u_variant_type_desc := rec.u_variant_type_desc;
            v_prev_item := rec.item;
            v_prev_sid := rec.sid;
            v_first := false;
        END LOOP;
    
        -- Output the last group if it has at least two sources
        IF v_source_list.count >= 2 THEN
            v_source1 := v_source_list(1);
            v_source2 := v_source_list(2);
            v_u_stackabilitytype1 := v_u_stackabilitytype_list(1);
            v_u_stackabilitytype2 := v_u_stackabilitytype_list(2);
            v_transmode1 := v_transmode_list(1);
            v_transmode2 := v_transmode_list(2);
    
            -- Get u_sourcingmin values for source1 and source2
            SELECT
                u_sourcingmin
            INTO v_u_sourcingmin1
            FROM
                batchmgr.priority_list
            WHERE
                    dest = v_prev_dest
                --AND transmode = v_prev_transmode
                AND substr(u_variant_type_desc,1,2) = substr(v_prev_u_variant_type_desc,1,2)
                AND item = v_prev_item
                AND source = v_source1
                AND transmode = v_transmode1;

            SELECT
                u_sourcingmin
            INTO v_u_sourcingmin2
            FROM
                batchmgr.priority_list
            WHERE
                    dest = v_prev_dest
                --AND transmode = v_prev_transmode
                AND substr(u_variant_type_desc,1,2) = substr(v_prev_u_variant_type_desc,1,2)
                AND item = v_prev_item
                AND source = v_source2
                AND transmode = v_transmode2;
            
            -- Insert into the results table 
            INSERT INTO batchmgr.priority_shift (
                dest,
                --transmode,
                u_variant_type_desc,
                item,
                u_priority1,
                u_priority2,
                sid,
                source1,
                source2,
                transmode1,
                transmode2,
                u_stackabilitytype1,
                u_stackabilitytype2,
                u_sourcingmin1,
                u_sourcingmin2
            ) VALUES (
                v_prev_dest,
                --v_prev_transmode,
                --case when upper(trim(v_prev_u_variant_type_desc)) = 'PROMO' then 'BASE / PROMO' ELSE v_prev_u_variant_type_desc END,
                v_prev_u_variant_type_desc,
                v_prev_item,
                1,
                2,
                v_prev_sid,
                v_source1,
                v_source2,
                v_transmode1,
                v_transmode2,
                v_u_stackabilitytype1,
                v_u_stackabilitytype2,
                v_u_sourcingmin1,
                v_u_sourcingmin2
            );

        END IF;

        --dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
          -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
            
          -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
             
          -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_insert_into_priorityshift;

    PROCEDURE p_vmi_add_column_if_not_exists (
        p_table_name  IN VARCHAR2,
        p_column_name IN VARCHAR2,
        p_data_type   IN VARCHAR2
    ) IS

        v_column_exists     NUMBER;
        /******************************************************************
          Procedure : P_VMI_ADD_COLUMN_IF_NOT_EXISTS
          Description : tbd
          Output Parameters: None
          Error Conditions Raised: When Others
          Author: Vinay Govardhanam
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          15-July-2024    Sahil Chawla              Initial Version
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
          *******************************************************************/
          -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;
    
            -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_ADD_COLUMN_IF_NOT_EXISTS';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
           -- Initialize interface start time
        l_d_start_date_time := systimestamp;
            
          -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'ALTER TABLE TO ADD COLUMN in P_VMI_ADD_COLUMN_IF_NOT_EXISTS';
        SELECT
            COUNT(*)
        INTO v_column_exists
        FROM
            user_tab_columns
        WHERE
                table_name = upper(p_table_name)
            AND column_name = upper(p_column_name);

        IF v_column_exists = 0 THEN
            EXECUTE IMMEDIATE 'ALTER TABLE SCPOMGR.'
                              || p_table_name
                              || ' ADD '
                              || p_column_name
                              || ' '
                              || p_data_type;
        END IF;
         -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
             -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
             -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_add_column_if_not_exists;

--    PROCEDURE p_vmi_create_dynamic_columns_udcreship IS
--        /******************************************************************
--          Procedure : P_VMI_CREATE_DYNAMIC_COLUMNS_UDCRESHIP
--          Description : tbd
--          Output Parameters: None
--          Error Conditions Raised: When Others
--          Author: Vinay Govardhanam
--          Revision History:
--          ------------------
--          Date            Author                    Description
--          ----            -----                     ------------
--          15-July-2024    Sahil Chawla              Initial Version
--          06-June-2024    Vinay Kumar Govardhanam   Modified Version
--          24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--          *******************************************************************/
--          -- define variables
--        l_d_start_date_time       iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time         iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep               iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id                    iio_interface_timing_log.id%TYPE;
--    
--            -- Initialize variables
--        l_v_prog_name             scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_DYNAMIC_COLUMNS_UDCRESHIP';
--        l_v_prog_status           scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency             scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_logic_sql_code          VARCHAR2(4000);
--        v_truncated_col_name      VARCHAR2(30);
--        v_truncated_min_col_name  VARCHAR2(30);
--        v_truncated_max_col_name  VARCHAR2(30);
--        v_conversion_col_name     VARCHAR2(30);
--        v_min_conversion_col_name VARCHAR2(30);
--        v_max_conversion_col_name VARCHAR2(30);
--        v_palletbase_exists       NUMBER := 0;
--    BEGIN
--           -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--            
--          -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Pallets & Pounds: Updating the dynamic ratios of truck capacity (mincap and maxcap)';
--           
--              
--        -- Add the dynamic columns from uom_ratios to the existing udc_recship
--        FOR rec IN (
--            SELECT
--                key,
--                item,
--                value,
--                'SU_' || plurallabel AS label_ratio
--            FROM
--                batchmgr.uom_ratios
--        ) LOOP
--            -- Truncate column names to 30 characters
--            v_truncated_col_name := substr(rec.label_ratio || '_ratio', 1, 30);
--            v_truncated_min_col_name := substr('updated_mincap_' || rec.label_ratio, 1, 30);
--            v_truncated_max_col_name := substr('updated_maxcap_' || rec.label_ratio, 1, 30);
--    
--            -- Add ratio columns dynamically if not exists
--
--            v_logic_sql_code := 'ALTER TABLE batchmgr.udc_recship ADD ('
--                                || v_truncated_col_name
--                                || ' FLOAT)';
--            EXECUTE IMMEDIATE v_logic_sql_code;
--            COMMIT;
--    
--            -- Add updated mincap and maxcap columns dynamically if not exists
--
--            v_logic_sql_code := 'ALTER TABLE batchmgr.udc_recship ADD ('
--                                || v_truncated_min_col_name
--                                || ' FLOAT)';
--            EXECUTE IMMEDIATE v_logic_sql_code;
--            COMMIT;
--            v_logic_sql_code := 'ALTER TABLE batchmgr.udc_recship ADD ('
--                                || v_truncated_max_col_name
--                                || ' FLOAT)';
--            EXECUTE IMMEDIATE v_logic_sql_code;
--            COMMIT;
--            
--    
--            -- Update or insert new columns with designated ratios
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_truncated_col_name
--                                || ' = '
--                                || rec.value
--                                || ' WHERE item = '''
--                                || rec.item
--                                || '''';
--
--            EXECUTE IMMEDIATE v_logic_sql_code;
--            IF SQL%rowcount = 0 THEN
--                v_logic_sql_code := 'INSERT INTO batchmgr.udc_recship (item, '
--                                    || v_truncated_col_name
--                                    || ') VALUES ('''
--                                    || rec.item
--                                    || ''', '
--                                    || rec.value
--                                    || ')';
--
--                EXECUTE IMMEDIATE v_logic_sql_code;
--                COMMIT;
--            END IF;
--
--        END LOOP;
--    
--        -- Update min and max columns based on the new columns added
--        l_v_errstep := 'Update min and max columns based on the new columns added';
--        FOR rec IN (
--            SELECT
--                key,
--                value,
--                item,
--                'SU_' || plurallabel AS label_ratio
--            FROM
--                batchmgr.uom_ratios
--        ) LOOP
--            v_truncated_col_name := substr(rec.label_ratio || '_ratio', 1, 30);
--            v_truncated_min_col_name := substr('updated_mincap_' || rec.label_ratio, 1, 30);
--            v_truncated_max_col_name := substr('updated_maxcap_' || rec.label_ratio, 1, 30);
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_truncated_min_col_name
--                                || ' = round(updated_mincap_su / '
--                                || rec.value
--                                || ')'
--                                || ' WHERE item = '''
--                                || rec.item
--                                || '''';
--
--            EXECUTE IMMEDIATE v_logic_sql_code;
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_truncated_max_col_name
--                                || ' = round(updated_maxcap_su / '
--                                || rec.value
--                                || ')'
--                                || ' WHERE item = '''
--                                || rec.item
--                                || '''';
--
--            EXECUTE IMMEDIATE v_logic_sql_code;
--        END LOOP;
--
--        COMMIT;
--        -- PalletBases uom creation
--    
--        -- First verify if PalletBases exists in the uom_ratios table
--        l_v_errstep := 'First verify if PalletBases exists in the uom_ratios table';
--        SELECT
--            COUNT(*)
--        INTO v_palletbase_exists
--        FROM
--            batchmgr.uom_ratios
--        WHERE
--            upper(plurallabel) = 'PALLETBASES';
--        
--        -- Add the dynamic columns for conversion to the existing udc_recship
--        l_v_errstep := 'Add the dynamic columns for conversion to the existing udc_recship';
--        FOR rec IN (
--            SELECT
--                key,
--                item,
--                value,
--                'SU_' || plurallabel AS label_ratio
--            FROM
--                batchmgr.uom_ratios
--            WHERE
--                upper(plurallabel) NOT IN ( 'PALLETS', 'POUNDS' )
--        ) LOOP
--            -- Truncate column names to 30 characters
--            v_conversion_col_name := truncate_identifier(rec.label_ratio || '_Pallets_conv');
--            v_min_conversion_col_name := truncate_identifier('upd_mincap_'
--                                                             || rec.label_ratio
--                                                             || '_pal');
--            v_max_conversion_col_name := truncate_identifier('upd_maxcap_'
--                                                             || rec.label_ratio
--                                                             || '_pal');
--     
--            -- Add conversion columns if they don't exist
--            p_vmi_add_column_if_not_exists('udc_recship', v_conversion_col_name, 'FLOAT');
--            p_vmi_add_column_if_not_exists('udc_recship', v_min_conversion_col_name, 'FLOAT');
--            p_vmi_add_column_if_not_exists('udc_recship', v_max_conversion_col_name, 'FLOAT');
--     
--            -- Calculate conversion ratios
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_conversion_col_name
--                                || ' = CASE WHEN '
--                                || truncate_identifier('updated_maxcap_' || rec.label_ratio)
--                                || ' IS NOT NULL AND '
--                                || truncate_identifier('updated_maxcap_' || rec.label_ratio)
--                                || ' != 0 THEN updated_maxcap_su_pallets / '
--                                || truncate_identifier('updated_maxcap_' || rec.label_ratio)
--                                || ' ELSE NULL END WHERE item = :1';
--
--            EXECUTE IMMEDIATE v_logic_sql_code
--                USING rec.item;
--     
--               -- Calculate converted min and max capacities
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_min_conversion_col_name
--                                || ' = '
--                                || truncate_identifier('updated_mincap_' || rec.label_ratio)
--                                || ' * '
--                                || v_conversion_col_name
--                                || ' WHERE item = :1';
--
--            EXECUTE IMMEDIATE v_logic_sql_code
--                USING rec.item;
--            v_logic_sql_code := 'UPDATE batchmgr.udc_recship SET '
--                                || v_max_conversion_col_name
--                                || ' = '
--                                || truncate_identifier('updated_maxcap_' || rec.label_ratio)
--                                || ' * '
--                                || v_conversion_col_name
--                                || ' WHERE item = :1';
--
--            EXECUTE IMMEDIATE v_logic_sql_code
--                USING rec.item;
--        END LOOP;
--
--        COMMIT;
--        l_v_errstep := 'Construct the final update based on whether PalletBases exists';
--        -- Construct the final update based on whether PalletBases exists
--        IF v_palletbase_exists > 0 THEN
--            -- DBMS_OUTPUT.PUT_LINE('PalletBases exists');
--            -- If PalletBases exists, include it in the UNION
--
--            EXECUTE IMMEDIATE '
--            UPDATE batchmgr.udc_recship
--            SET updated_mincap_su_pallets = COALESCE(
--                (SELECT MIN(col_value) FROM (
--                    SELECT updated_mincap_su_pallets AS col_value FROM DUAL WHERE updated_mincap_su_pallets IS NOT NULL
--                    UNION ALL
--                    SELECT '
--                              || truncate_identifier('upd_mincap_SU_PalletBases_pal')
--                              || ' FROM DUAL WHERE '
--                              || truncate_identifier('upd_mincap_SU_PalletBases_pal')
--                              || ' IS NOT NULL
--                ))
--                , updated_mincap_su_pallets
--            ),
--            updated_maxcap_su_pallets = COALESCE(
--                (SELECT MAX(col_value) FROM (
--                    SELECT updated_maxcap_su_pallets AS col_value FROM DUAL WHERE updated_maxcap_su_pallets IS NOT NULL
--                    UNION ALL
--                    SELECT '
--                              || truncate_identifier('upd_maxcap_SU_PalletBases_pal')
--                              || ' FROM DUAL WHERE '
--                              || truncate_identifier('upd_maxcap_SU_PalletBases_pal')
--                              || ' IS NOT NULL
--                ))
--                , updated_maxcap_su_pallets
--            )';
--        ELSE
--            --DBMS_OUTPUT.PUT_LINE('PalletBases does not exists');
--            l_v_errstep := 'PalletBases does not exists';
--            -- If PalletBases doesn't exist, use a simpler update
--            EXECUTE IMMEDIATE '
--            UPDATE batchmgr.udc_recship
--            SET updated_mincap_su_pallets = updated_mincap_su_pallets,
--                updated_maxcap_su_pallets = updated_maxcap_su_pallets';
--        END IF;
--
--        dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
--          -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--            
--          -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--             
--          -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--             -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--    
--             -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_dynamic_columns_udcreship;

    PROCEDURE p_vmi_update_udc_recship IS
    /******************************************************************
      Procedure : P_VMI_UPDATE_UDC_RECSHIP
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_UPDATE_UDC_RECSHIP';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Update sourcing id and sorucingseq in batchmgr.p_vmi_update_udc_recship';
  
        -- additional calculations
       -- Update ratio columns from uom_ratios table
        MERGE /*+parallel(16) */ INTO batchmgr.udc_recship u
        USING (
            SELECT ITEM, SOURCE, DEST, TRANSMODE, VALUE, 'SU_' || PLURALLABEL AS LABEL_RATIO
            FROM batchmgr.uom_ratios r
            WHERE PLURALLABEL = 'Pallets'
        ) r
        ON (u.item = r.item and u.source = r.source and u.dest = r.dest and u.transmode = r.transmode)
        WHEN MATCHED THEN
            UPDATE SET u.SU_PALLETS_RATIO = r.VALUE
        WHEN NOT MATCHED THEN
            INSERT (item, SU_PALLETS_RATIO)
            VALUES (r.item, r.VALUE);
         
         COMMIT;
        MERGE /*+parallel(16) */ INTO batchmgr.udc_recship u
        USING (
            SELECT ITEM, SOURCE, DEST, TRANSMODE, VALUE, 'SU_' || PLURALLABEL AS LABEL_RATIO 
            FROM batchmgr.uom_ratios r
            WHERE PLURALLABEL = 'Pounds'
        ) r
        ON (u.item = r.item and u.source = r.source and u.dest = r.dest and u.transmode = r.transmode)
        WHEN MATCHED THEN
            UPDATE SET u.SU_POUNDS_RATIO = r.VALUE
        WHEN NOT MATCHED THEN
            INSERT (item, SU_POUNDS_RATIO)
            VALUES (r.item, r.VALUE);
         COMMIT;
        
        MERGE  /*+parallel(16) */ INTO batchmgr.udc_recship u
        USING (
            SELECT ITEM, SOURCE, DEST, TRANSMODE, VALUE, 'SU_' || PLURALLABEL AS LABEL_RATIO 
            FROM batchmgr.uom_ratios r
            WHERE PLURALLABEL = 'PalletBases'
        ) r
        ON (u.item = r.item and u.source = r.source and u.dest = r.dest and u.transmode = r.transmode)
        WHEN MATCHED THEN
            UPDATE SET u.SU_PALLETBASES_RATIO = r.VALUE
        WHEN NOT MATCHED THEN
            INSERT (item, SU_PALLETBASES_RATIO)
            VALUES (r.item, r.VALUE);
         
         COMMIT;
         
        -- Update conversion ratio column from uom_ratios table
        MERGE /*+parallel(16) */ INTO batchmgr.udc_recship u
        USING (
            SELECT ITEM, SOURCE, DEST, TRANSMODE, VALUE, 'SU_' || PLURALLABEL AS LABEL_RATIO 
            FROM batchmgr.uom_ratios r
            WHERE PLURALLABEL = 'PALLETBASES_PALLETS'
        ) r
        ON (u.item = r.item and u.source = r.source and u.dest = r.dest and u.transmode = r.transmode)
        WHEN MATCHED THEN
            UPDATE SET u.SU_PALLETBASES_PALLETS_CONV = r.VALUE
        WHEN NOT MATCHED THEN
            INSERT (item, SU_PALLETBASES_PALLETS_CONV)
            VALUES (r.item, r.VALUE);
         
         COMMIT;
         
        -- Update min and max capacity columns based on ratios
        UPDATE /*+parallel(16) */batchmgr.udc_recship
        SET 
            UPDATED_MINCAP_SU_PALLETS = ROUND(updated_mincap_su / SU_PALLETS_RATIO),
            UPDATED_MAXCAP_SU_PALLETS = ROUND(updated_maxcap_su / SU_PALLETS_RATIO)
        WHERE SU_PALLETS_RATIO IS NOT NULL;
         
         COMMIT;
         
        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET 
            UPDATED_MINCAP_SU_POUNDS = (
                SELECT mincap 
                FROM scpomgr.transmodecap
                WHERE uom = 50 
                  AND transmode = udc_recship.transmode
                  AND ROWNUM = 1
            ),
            UPDATED_MAXCAP_SU_POUNDS = (
                SELECT maxcap 
                FROM scpomgr.transmodecap
                WHERE uom = 50 
                  AND transmode = udc_recship.transmode
                  AND ROWNUM = 1
            )
        WHERE SU_POUNDS_RATIO IS NOT NULL;
         
         COMMIT;
         
        UPDATE /*+parallel(16) */batchmgr.udc_recship
        SET 
            UPDATED_MINCAP_SU_PALLETBASES = ROUND(updated_mincap_su / SU_PALLETBASES_RATIO),
            UPDATED_MAXCAP_SU_PALLETBASES = ROUND(updated_maxcap_su / SU_PALLETBASES_RATIO)
        WHERE SU_PALLETBASES_RATIO IS NOT NULL;
         
         COMMIT;
         
        -- Update min and max capacity columns based on the conversion ratio
        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET 
            UPD_MINCAP_SU_PALLETBASES_PAL = ROUND(updated_mincap_su / SU_PALLETBASES_PALLETS_CONV),
            UPD_MAXCAP_SU_PALLETBASES_PAL = ROUND(updated_maxcap_su / SU_PALLETBASES_PALLETS_CONV)
        WHERE SU_PALLETBASES_PALLETS_CONV IS NOT NULL;
        
        COMMIT;
        
        -- Update min and max capacity pallets uom columns with respect to palletbases uom columns
        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET updated_mincap_su_pallets = COALESCE(
                LEAST(updated_mincap_su_pallets, UPD_MINCAP_SU_PALLETBASES_PAL),
                updated_mincap_su_pallets,
                UPD_MINCAP_SU_PALLETBASES_PAL
            ),
            updated_maxcap_su_pallets = COALESCE(
                GREATEST(updated_maxcap_su_pallets, UPD_MAXCAP_SU_PALLETBASES_PAL),
                updated_maxcap_su_pallets,
                UPD_MAXCAP_SU_PALLETBASES_PAL
            )
        WHERE UPD_MINCAP_SU_PALLETBASES_PAL IS NOT NULL 
           OR UPD_MAXCAP_SU_PALLETBASES_PAL IS NOT NULL;
           
        COMMIT;

        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET
            updated_wgt = wgt * recqty;
            --updated_wgt = sales_units_qty * wgt;
            --updated_wgt = wgt * pallets_qty;
        
        COMMIT;

        UPDATE /*+parallel(16) */batchmgr.udc_recship
        SET
            pounds_qty = round(sales_units_qty / su_pounds_ratio);
        
        COMMIT;

       
        UPDATE /*+parallel(16) */ batchmgr.udc_recship
        SET
            color_priority_sourcingid_seq =
                CASE
                    WHEN u_stackabilitytype = 'RED'                    THEN
                        1
                    WHEN u_stackabilitytype = 'SS'                        THEN
                        2
                    WHEN u_stackabilitytype = 'BLACK'  THEN
                        3
                    WHEN u_stackabilitytype = 'GREEN'              THEN
                        4
                    WHEN u_stackabilitytype = 'DS'                    THEN
                        5
                    WHEN u_stackabilitytype = 'YELLOW' THEN
                        6
                    ELSE
                        7
                END;
        
        COMMIT;
        
        UPDATE udc_recship
        SET full_pallet_count = FLOOR(recqty / ratio),
            partial_su = MOD(recqty, ratio),
            --pallets_qty = FLOOR(recqty / ratio) + CASE WHEN MOD(recqty, ratio) > 0 THEN 1 ELSE 0 END,
            total_weight = recqty * wgt, --((FLOOR(recqty / ratio) * ratio) + MOD(recqty, ratio)) * wgt
            partial_pallet_count = pallets_qty - floor(pallets_qty), 
            full_pallet_wgt = case when pallets_qty - floor(pallets_qty) >= 0 then floor(pallets_qty) * (updated_wgt / pallets_qty) else 0 end, 
            partial_pallet_wgt = case when pallets_qty - floor(pallets_qty) > 0 then (pallets_qty - floor(pallets_qty)) * (updated_wgt / pallets_qty) else 0 end;
        
        COMMIT;
        
        -- need to look up on only for those respective sourcingid need to be changed
        MERGE /*+parallel(16) */ INTO batchmgr.udc_recship t
        USING (
                  SELECT 
                      ROWID AS rid,
                      CASE 
                          WHEN availtoshipdate <= u_dispatchdate THEN u_dispatchdate
                          WHEN availtoshipdate > u_dispatchdate THEN availtoshipdate
                      END AS new_availtoshipdate
                  FROM batchmgr.udc_recship
              ) temp 
        ON (t.rowid = temp.rid)
        WHEN MATCHED THEN UPDATE 
        SET t.availtoshipdate = temp.new_availtoshipdate;
                
        COMMIT;
        -- when the constrrecshipsw is 0 we will follow the above logic and if not we will include the availtoshipdate in the grouping
        -- update sourcingid & sourcingid_seq                                                      
        MERGE /*+parallel(16) */ INTO batchmgr.udc_recship t
        USING (
              WITH ranked_data AS (
                  SELECT
                      ROWID AS rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      substr(u_variant_type_desc, 1, 2) AS u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      DENSE_RANK() OVER(
                          PARTITION BY 
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN 1 
                                  ELSE 0 
                              END
                          ORDER BY
                              source, 
                              dest, 
                              transmode, 
                              substr(u_variant_type_desc, 1, 2),
                              u_priority,
                              CASE 
                                  WHEN constrrecshipsw != 0 THEN availtoshipdate
                              END
                      ) AS sourcingid
                  FROM
                      batchmgr.udc_recship
              ), final_data AS (
                  SELECT
                      rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      sourcingid,
                      DENSE_RANK() OVER(
                          PARTITION BY sourcingid
                          ORDER BY
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN schedshipdate
                                  ELSE availtoshipdate
                              END
                      ) AS sourcingid_seq
                  FROM
                      ranked_data
              )
              SELECT
                  rid,
                  schedshipdate,
                  source,
                  dest,
                  transmode,
                  u_variant_type_desc,
                  u_priority,
                  constrrecshipsw,
                  sourcingid,
                  sourcingid_seq
              FROM
                  final_data
          )
        temp ON ( t.rowid = temp.rid )
        WHEN MATCHED THEN UPDATE
        SET t.sourcingid = temp.sourcingid,
            t.sourcingid_seq = temp.sourcingid_seq;

        COMMIT;
        
        -- delete the records which exceeds the truck maxcap or wgt is missing or sourcinguomconvfactor.pounds ratio is missing
        -- SELECT U_SU_POUNDS*U_SU_PALLET, ITEM FROM SCPOMGR.ITEM WHERE U_SU_POUNDS*U_SU_PALLET>  AND ITEM LIKE 'XUS%' or u_stackabilitytype is null or u_stackabilitytype = '' '' ;
        EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.udc_recship_data_issues';
        COMMIT;
        EXECUTE IMMEDIATE 'INSERT INTO batchmgr.udc_recship_data_issues select distinct udc_recship.*  from udc_recship WHERE wgt is null or SU_POUNDS_RATIO is null or (ratio * wgt) > updated_maxcap_su_pounds or u_stackabilitytype is null or u_stackabilitytype = '' ''  or u_item_mintruckstackcap is null or u_item_maxtruckstackcap is null or u_sourcingmin is null or u_priority is null or SU_POUNDS_RATIO is null or SU_PALLETS_RATIO is null or updated_maxcap_su_pallets is null or u_variant_type_desc is null or updated_maxcap_su_pounds is null or arrivcal is null or arrivcal = '' '''; -- or shipcal = '' ''  -- or updated_maxcap_su_pallets = 0 or updated_maxcap_su_pounds = 0 
        COMMIT;
        
        -- user perspective
        EXECUTE IMMEDIATE 'DELETE FROM scpomgr.udt_data_issues'; 
        COMMIT;
        EXECUTE IMMEDIATE 'INSERT INTO scpomgr.udt_data_issues(item, source, dest, transmode, u_stackabilitytype, ratio, su_pounds_ratio, su_pallets_ratio, wgt, updated_wgt, u_sourcingmin, u_priority, u_item_mintruckstackcap, u_item_maxtruckstackcap, updated_maxcap_su_pounds, updated_maxcap_su_pallets, arrivcal) select distinct item, source, dest, transmode, u_stackabilitytype, ratio, su_pounds_ratio,su_pallets_ratio, wgt, updated_wgt, u_sourcingmin, u_priority, u_item_mintruckstackcap, u_item_maxtruckstackcap, updated_maxcap_su_pounds, updated_maxcap_su_pallets, arrivcal from udc_recship WHERE wgt is null or SU_POUNDS_RATIO is null or (ratio * wgt) > updated_maxcap_su_pounds or u_stackabilitytype is null or u_stackabilitytype = '' ''  or u_item_mintruckstackcap is null or u_item_maxtruckstackcap is null or u_sourcingmin is null or u_priority is null or SU_POUNDS_RATIO is null or SU_PALLETS_RATIO is null or updated_maxcap_su_pallets is null or u_variant_type_desc is null or updated_maxcap_su_pounds is null or arrivcal is null or arrivcal = '' '''; --  or shipcal = '' '' -- or updated_maxcap_su_pallets = 0 or updated_maxcap_su_pounds = 0 
        COMMIT;
        
        DELETE /*+parallel(16) */FROM batchmgr.udc_recship
        WHERE
            wgt is null or SU_POUNDS_RATIO is null or (ratio * wgt) > updated_maxcap_su_pounds or u_stackabilitytype is null or u_stackabilitytype = ' ' or u_item_mintruckstackcap is null or u_item_maxtruckstackcap is null or u_sourcingmin is null or u_priority is null or SU_POUNDS_RATIO is null or SU_PALLETS_RATIO is null or updated_maxcap_su_pallets is null or u_variant_type_desc is null or updated_maxcap_su_pounds is null or arrivcal is null or arrivcal = ' '; -- or shipcal = ' ' or updated_wgt = 0 |Note: removing (updated_maxcap_su_pallets, updated_maxcap_su_pounds) -- or updated_maxcap_su_pallets = 0 or updated_maxcap_su_pounds = 0 
        COMMIT;        
         
        -- delete the condition is not equal to 'ELSE' which are out of range recship
        DELETE /*+parallel(16) */FROM batchmgr.udc_recship
        WHERE
            condition = 'ELSE';
            
        --dbms_output.put_line('Number of rows updated:' || SQL%rowcount); 
      -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_update_udc_recship;

--    PROCEDURE p_vmi_create_u_recship IS 
--    /******************************************************************
--      Procedure : P_VMI_CREATE_U_RECSHIP
--      Description : tbd
--      Output Parameters: None
--      Error Conditions Raised: When Others
--      Author: Vinay Govardhanam
--      Revision History:
--      ------------------
--      Date            Author                    Description
--      ----            -----                     ------------
--      15-July-2024    Sahil Chawla              Initial Version
--      06-June-2024    Vinay Kumar Govardhanam   Modified Version
--      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--      *******************************************************************/
--      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_U_RECSHIP';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_weight            NUMBER;
--    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'CALCULATE TABLE SCPOMGR.P_VMI_CREATE_U_RECSHIP';
--        
--        -- Check if table exists, if not create it
--        EXECUTE IMMEDIATE 'DROP TABLE batchmgr.u_recship';
--        COMMIT;
--        EXECUTE IMMEDIATE 'CREATE TABLE batchmgr.u_recship (
--                    id NUMBER PRIMARY KEY,
--                    sourcingid NUMBER,
--                    sourcingid_seq NUMBER,
--                    condition VARCHAR2(100),
--                    u_priority NUMBER,
--                    loadid NUMBER,
--                    load_sequence NUMBER,
--                    loaded VARCHAR2(1),
--                    utilization NUMBER,
--                    u_sourcingmin NUMBER,
--                    schedshipdate DATE,
--                    schedarrivdate DATE,
--                    source VARCHAR2(100),
--                    dest VARCHAR2(100),
--                    transmode VARCHAR2(100),
--                    u_variant_type_desc VARCHAR2(100),
--                    item VARCHAR2(100),
--                    u_stackabilitytype VARCHAR2(100),
--                    pallets_qty NUMBER,
--                    updated_wgt NUMBER,
--                    updated_mincap_su_pallets NUMBER,
--                    updated_maxcap_su_pallets NUMBER,
--                    updated_mincap_su_pounds NUMBER,
--                    updated_maxcap_su_pounds NUMBER,
--                    u_item_mintruckstackcap NUMBER,
--                    u_item_maxtruckstackcap NUMBER,
--                    sid NUMBER,
--                    seqnum NUMBER,
--                    stack_position VARCHAR2(10),
--                    u_dispatchdate DATE,
--                    ratio NUMBER,
--                    recqty NUMBER,
--                    sales_units_qty FLOAT,
--                    majorshipqty NUMBER,
--                    minorshipqty NUMBER,
--                    status VARCHAR2(100),
--                    sourcing VARCHAR2(1000 CHAR),
--                    transleadtime FLOAT,
--                    arrivcal VARCHAR2(1000),
--                    shipcal VARCHAR2(1000),
--                    u_adjustedmaxcap NUMBER,
--                    wgt FLOAT,
--                    constrrecshipsw NUMBER,
--                    availtoshipdate DATE,
--                    needshipdate DATE,
--                    needarrivdate DATE,
--                    created_at TIMESTAMP DEFAULT SYSTIMESTAMP
--                )';
--        
--      -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
--      -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_u_recship;

--    PROCEDURE p_vmi_create_temp_visulaization_results IS 
--    /******************************************************************
--      Procedure : P_VMI_CREATE_TEMP_VISULAIZATION_RESULTS
--      Description : tbd
--      Output Parameters: None
--      Error Conditions Raised: When Others
--      Author: Vinay Govardhanam
--      Revision History:
--      ------------------
--      Date            Author                    Description
--      ----            -----                     ------------
--      15-July-2024    Sahil Chawla              Initial Version
--      06-June-2024    Vinay Kumar Govardhanam   Modified Version
--      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--      *******************************************************************/
--      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_TEMP_VISULAIZATION_RESULTS';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_weight            NUMBER;
--    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'CALCULATE TABLE SCPOMGR.P_VMI_CREATE_TEMP_VISULAIZATION_RESULTS';
--        
--        -- Check if table exists, if not create it
--        EXECUTE IMMEDIATE 'DROP TABLE batchmgr.temp_visualization_results';
--        EXECUTE IMMEDIATE 'CREATE TABLE batchmgr.temp_visualization_results (
--                    sourcingid NUMBER,
--                    loadid NUMBER,
--                    condition VARCHAR2(10),
--                    stack_position VARCHAR2(10),
--                    load_sequence NUMBER,
--                    u_stackabilitytype VARCHAR2(100),
--                    item VARCHAR2(100),
--                    weight NUMBER,
--                    schedshipdate DATE,
--                    sourcingid_seq NUMBER,
--                    u_priority NUMBER,
--                    sid NUMBER,
--                    seqnum NUMBER
--                )';
--  
--      -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
--      -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_temp_visulaization_results;

--    PROCEDURE p_vmi_create_priority_shift_pallets IS 
--    /******************************************************************
--      Procedure : P_VMI_CREATE_PRIORITY_SHIFT_PALLETS
--      Description : tbd
--      Output Parameters: None
--      Error Conditions Raised: When Others
--      Author: Vinay Govardhanam
--      Revision History:
--      ------------------
--      Date            Author                    Description
--      ----            -----                     ------------
--      15-July-2024    Sahil Chawla              Initial Version
--      06-June-2024    Vinay Kumar Govardhanam   Modified Version
--      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
--      *******************************************************************/
--      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CREATE_PRIORITY_SHIFT_PALLETS';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
--        v_weight            NUMBER;
--    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'CALCULATE TABLE SCPOMGR.P_VMI_CREATE_PRIORITY_SHIFT_PALLETS';
--        
--        -- Check if table exists, if not create it
--        EXECUTE IMMEDIATE 'DROP TABLE batchmgr.priority_shift_pallets';
--        EXECUTE IMMEDIATE 'CREATE TABLE batchmgr.priority_shift_pallets (
--                sourcingid NUMBER,
--                sourcingid_seq NUMBER,
--                condition VARCHAR2(200),
--                u_priority NUMBER,
--                u_sourcingmin NUMBER,
--                schedshipdate DATE,
--                schedarrivdate DATE,
--                source VARCHAR2(150),
--                dest VARCHAR2(150),
--                transmode VARCHAR2(150),
--                u_variant_type_desc VARCHAR2(150),
--                item VARCHAR2(150),
--                u_stackabilitytype VARCHAR2(120),
--                pallets_qty NUMBER,
--                updated_wgt FLOAT,
--                updated_mincap_su_pallets NUMBER,
--                updated_maxcap_su_pallets NUMBER,
--                updated_mincap_su_pounds NUMBER,
--                updated_maxcap_su_pounds NUMBER,
--                u_item_mintruckstackcap NUMBER,
--                u_item_maxtruckstackcap NUMBER,
--                sid NUMBER,
--                seqnum NUMBER,
--                status VARCHAR2(50),
--                u_dispatchdate DATE,
--                ratio NUMBER,
--                recqty NUMBER,
--                sales_units_qty FLOAT,
--                majorshipqty NUMBER,
--                minorshipqty NUMBER,
--                transleadtime FLOAT,
--                arrivcal VARCHAR2(100),
--                u_adjustedmaxcap NUMBER,
--                wgt FLOAT,
--                constrrecshipsw NUMBER,
--                availtoshipdate DATE,
--                needshipdate DATE,
--                needarrivdate DATE
--            )';
--  
--      -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
--      -- Commit the transaction
--        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
--    END p_vmi_create_priority_shift_pallets;
    
    PROCEDURE p_vmi_reset_caches IS
    BEGIN
        efficiency_cache.DELETE;
        split_cache.DELETE;
        cache_size := 0;
    END p_vmi_reset_caches;
    
    PROCEDURE assert_true(
        p_expr IN BOOLEAN,
        p_msg  IN VARCHAR2
      ) IS
    BEGIN
        IF NOT p_expr THEN
          RAISE_APPLICATION_ERROR(-20001, '[ASSERT_TRUE] ' || p_msg);
        END IF;
    END assert_true;
    
    PROCEDURE assert_equals(
        p_a   IN FLOAT,
        p_b   IN FLOAT,
        p_tol IN FLOAT,
        p_msg IN VARCHAR2
    ) IS
    BEGIN
        IF ABS(p_a - p_b) > p_tol THEN
          RAISE_APPLICATION_ERROR(
            -20002,
            '[ASSERT_EQUALS] ' || p_msg || ': ' || TO_CHAR(p_a) || ' vs ' || TO_CHAR(p_b)
          );
        END IF;
    END assert_equals;
    
    -- Validate whether splitting an item is allowed (formerly is_valid_split)
    FUNCTION f_vmi_is_valid_split(
        p_item         IN partial_pallet_rec,
        p_split_qty    IN FLOAT,
        p_target_bins  IN number_set,
        p_bin_contents IN merged_bin_array,
        p_tolerance    IN FLOAT := 0.0001
    ) RETURN BOOLEAN IS
        v_same_item_in_bin BOOLEAN := FALSE;
        v_original_id      NUMBER;
        v_item_id          NUMBER := p_item.id;
        v_ideal_split      BOOLEAN := FALSE;
        v_edge_tolerance   FLOAT := GREATEST(p_tolerance * 100, 0.02);
        v_bin_idx          NUMBER;
    BEGIN
        -- Basic bounds checks
        IF p_split_qty <= 0 OR p_split_qty >= p_item.quantity THEN
            RETURN FALSE;
        ELSIF p_split_qty < 0.05 OR (p_item.quantity - p_split_qty) < 0.05 THEN
            RETURN FALSE;
        END IF;

        -- Avoid splitting near‐perfect items unless it makes a perfect bin
        IF p_item.quantity BETWEEN 0.97 AND 0.999 THEN
            FOR idx IN 1..p_bin_contents.COUNT LOOP
                IF p_bin_contents.EXISTS(idx) AND p_target_bins.EXISTS(idx) THEN
                    IF ABS( (p_bin_contents(idx).total_quantity + p_split_qty) - 1.0 )
                       <= p_tolerance THEN
                        v_ideal_split := TRUE;
                        EXIT;
                    END IF;
                END IF;
            END LOOP;
            IF NOT v_ideal_split THEN
                RETURN FALSE;
            END IF;
        END IF;

        -- Determine original ID
        IF p_item.is_split THEN
            v_original_id := p_item.original_id;
        ELSE
            v_original_id := p_item.id;
        END IF;

        -- Prevent splitting if both parts would go to the same bin
        IF p_target_bins.COUNT <= 1 THEN
            v_ideal_split := FALSE;
            FOR idx IN 1..p_bin_contents.COUNT LOOP
                IF p_bin_contents.EXISTS(idx) AND p_target_bins.EXISTS(idx) THEN
                    IF ABS( (p_bin_contents(idx).total_quantity + p_split_qty) - 1.0 )
                       <= p_tolerance THEN
                        v_ideal_split := TRUE;
                        EXIT;
                    END IF;
                END IF;
            END LOOP;
            IF NOT v_ideal_split THEN
                RETURN FALSE;
            END IF;
        END IF;

        -- Check if that target bin already contains this original item
        v_bin_idx := NULL;
        FOR i IN 1..p_target_bins.LAST LOOP
            IF p_target_bins.EXISTS(i) THEN
                v_bin_idx := p_target_bins(i);
                EXIT;
            END IF;
        END LOOP;
        IF v_bin_idx IS NOT NULL AND p_bin_contents.EXISTS(v_bin_idx) THEN
            FOR j IN 1..p_bin_contents(v_bin_idx).item_count LOOP
                IF p_bin_contents(v_bin_idx).items.EXISTS(j) THEN
                    IF p_bin_contents(v_bin_idx).items(j).is_split AND
                       p_bin_contents(v_bin_idx).items(j).original_id = v_original_id
                    THEN
                        v_same_item_in_bin := TRUE;
                        EXIT;
                    ELSIF NOT p_bin_contents(v_bin_idx).items(j).is_split AND
                          p_bin_contents(v_bin_idx).items(j).id = v_item_id
                    THEN
                        v_same_item_in_bin := TRUE;
                        EXIT;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        IF v_same_item_in_bin AND NOT v_ideal_split THEN
            RETURN FALSE;
        END IF;

        -- For large (0.85–0.95) items, only split if it creates ≥95% fill
        IF p_item.quantity >= 0.85 AND p_item.quantity < 0.97 THEN
            v_ideal_split := FALSE;
            FOR idx IN 1..p_bin_contents.COUNT LOOP
                IF p_bin_contents.EXISTS(idx) AND p_target_bins.EXISTS(idx) THEN
                    IF p_bin_contents(idx).total_quantity + p_split_qty >= 0.95 THEN
                        v_ideal_split := TRUE;
                        EXIT;
                    END IF;
                END IF;
            END LOOP;
            IF NOT v_ideal_split THEN
                RETURN FALSE;
            END IF;
        END IF;

        RETURN TRUE;
    END f_vmi_is_valid_split;
    
    FUNCTION f_vmi_new_merged_bin(p_color IN VARCHAR2) RETURN merged_bin_rec IS
        v_bin merged_bin_rec;
    BEGIN
        v_bin.id := NULL;  -- Will be assigned later
        v_bin.total_quantity := 0;
        v_bin.total_weight := 0;
        v_bin.color := p_color;
        v_bin.items := partial_pallet_array();
        v_bin.item_count := 0;
        v_bin.efficiency := 0;
        v_bin.is_standalone := 'N';
        
        RETURN v_bin;
    END f_vmi_new_merged_bin;
    
    FUNCTION f_vmi_calc_bin_efficiency(
        p_bin IN merged_bin_rec,
        p_tolerance IN FLOAT
    ) RETURN FLOAT IS
        v_cache_key VARCHAR2(100);
        v_efficiency FLOAT;
        v_rounded_qty FLOAT;
    BEGIN
        -- Empty bin has 0 efficiency
        IF p_bin.total_quantity = 0 THEN
            RETURN 0;
        END IF;
        
        -- Generate cache key
        v_cache_key := TO_CHAR(p_bin.total_quantity, 'FM999.999999') || '_' || TO_CHAR(p_tolerance, 'FM0.999999');
        
        -- Check cache
        IF efficiency_cache.EXISTS(v_cache_key) THEN
            RETURN efficiency_cache(v_cache_key);
        END IF;
        
        -- Round to precision to avoid minor floating-point issues
        v_rounded_qty := ROUND(p_bin.total_quantity, 6);
        
        -- Perfect bin (exactly 1.0 or within tolerance)
        IF ABS(v_rounded_qty - 1.0) <= p_tolerance THEN
            v_efficiency := 1.0;
        -- Handle severely overfilled bin
        ELSIF v_rounded_qty > 1.0 + p_tolerance THEN
            -- Severely over capacity, penalize
            v_efficiency := 0;
        -- Almost perfect bin (≥ 0.98)
        ELSIF v_rounded_qty >= 0.98 THEN
            v_efficiency := 1.0;  -- Consider as full for practical purposes
        ELSE
            -- Otherwise, return ratio of filled capacity
            v_efficiency := v_rounded_qty;
        END IF;
        
        -- Cache the result
        efficiency_cache(v_cache_key) := v_efficiency;
        cache_size := cache_size + 1;
        
        RETURN v_efficiency;
    END f_vmi_calc_bin_efficiency;
    
    PROCEDURE p_vmi_quicksort(
        p_items IN OUT qty_idx_array,
        p_low IN PLS_INTEGER,
        p_high IN PLS_INTEGER,
        p_ascending IN BOOLEAN DEFAULT FALSE
    ) IS
        i PLS_INTEGER;
        j PLS_INTEGER;
        pivot FLOAT;
        temp qty_idx_pair;
    BEGIN
        IF p_low < p_high THEN
            pivot := p_items((p_low+p_high)/2).qty;
            i := p_low;
            j := p_high;
            LOOP
                IF p_ascending THEN
                    WHILE p_items(i).qty < pivot LOOP
                        i := i + 1;
                        EXIT WHEN i > p_high;
                    END LOOP;
                    WHILE p_items(j).qty > pivot LOOP
                        j := j - 1;
                        EXIT WHEN j < p_low;
                    END LOOP;
                ELSE
                    WHILE p_items(i).qty > pivot LOOP
                        i := i + 1;
                        EXIT WHEN i > p_high;
                    END LOOP;
                    WHILE p_items(j).qty < pivot LOOP
                        j := j - 1;
                        EXIT WHEN j < p_low;
                    END LOOP;
                END IF;
                
                IF i <= j THEN
                    temp := p_items(i);
                    p_items(i) := p_items(j);
                    p_items(j) := temp;
                    i := i + 1;
                    j := j - 1;
                END IF;
                EXIT WHEN i > j;
            END LOOP;
            
            IF p_low < j THEN
                p_vmi_quicksort(p_items, p_low, j, p_ascending);
            END IF;
            
            IF i < p_high THEN
                p_vmi_quicksort(p_items, i, p_high, p_ascending);
            END IF;
        END IF;
    END p_vmi_quicksort;
    
    FUNCTION f_vmi_split_partial(
        p_partial IN partial_pallet_rec,
        p_split_qty IN FLOAT
    ) RETURN partial_pallet_array IS
        v_result partial_pallet_array;
        v_cache_key VARCHAR2(100);
    BEGIN
        -- Generate cache key
        v_cache_key := p_partial.id || '_' || TO_CHAR(p_split_qty, 'FM999.999999');
        
        -- Check cache first
        IF split_cache.EXISTS(v_cache_key) THEN
            RETURN split_cache(v_cache_key);
        END IF;
        
        -- Pre-allocate only the needed entries
        v_result := partial_pallet_array();
        
        -- Validate split amount
        IF p_split_qty <= 0 OR p_split_qty >= p_partial.quantity THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid split quantity: ' || p_split_qty || 
                                 ' (original: ' || p_partial.quantity || ')');
        END IF;
        
        -- Create first part (with requested quantity)
        v_result(1) := p_partial;
        v_result(1).quantity := p_split_qty;
        v_result(1).weight := (p_split_qty / p_partial.quantity) * p_partial.weight;
        v_result(1).is_split := TRUE;
        -- Adjust sales_units_qty proportionally
        --v_result(1).sales_units_qty := ROUND(p_partial.sales_units_qty * (p_split_qty / p_partial.quantity));
        v_result(1).sales_units_qty := p_partial.sales_units_qty;
    
        
        IF p_partial.is_split THEN
            v_result(1).original_id := p_partial.original_id;
            v_result(1).original_qty := p_partial.original_qty;
        ELSE
            v_result(1).original_id := p_partial.id;
            v_result(1).original_qty := p_partial.quantity;
        END IF;
        
        -- Create second part (remainder)
        v_result(2) := p_partial;
        v_result(2).quantity := p_partial.quantity - p_split_qty;
        v_result(2).weight := p_partial.weight - v_result(1).weight; --  p_partial.weight * ((p_partial.quantity - p_split_qty) / p_partial.quantity);
        v_result(2).is_split := TRUE;
        -- Adjust sales_units_qty for remainder
        --v_result(2).sales_units_qty := p_partial.sales_units_qty - v_result(1).sales_units_qty;
        v_result(2).sales_units_qty := p_partial.sales_units_qty;
        
        IF p_partial.is_split THEN
            v_result(2).original_id := p_partial.original_id;
            v_result(2).original_qty := p_partial.original_qty;
        ELSE
            v_result(2).original_id := p_partial.id;
            v_result(2).original_qty := p_partial.quantity;
        END IF;
        
        -- Store result in cache
        split_cache(v_cache_key) := v_result;
        
        RETURN v_result;
    END f_vmi_split_partial;
       
    FUNCTION f_vmi_check_tolerance_edge_case(
        p_partials IN partial_pallet_array,
        p_color IN VARCHAR2,
        p_tolerance IN FLOAT
    ) RETURN merged_bin_array IS
        v_result merged_bin_array;
        v_large_item_idx NUMBER := 0;
        v_small_item_idx NUMBER := 0;
        v_large_qty FLOAT := 0;
        v_small_qty FLOAT := 0;
        v_special_bins merged_bin_array;
    BEGIN
        -- Look for items that might be a tolerance edge case (one large ~0.99 and one small ~0.02)
        FOR i IN 1..p_partials.COUNT LOOP
            IF p_partials.EXISTS(i) AND p_partials(i).color = p_color THEN
                IF p_partials(i).quantity > 0.95 AND p_partials(i).quantity < 1.0 THEN
                    v_large_item_idx := i;
                    v_large_qty := p_partials(i).quantity;
                ELSIF p_partials(i).quantity <= 0.05 THEN
                    v_small_item_idx := i;
                    v_small_qty := p_partials(i).quantity;
                END IF;
            END IF;
        END LOOP;
        
        -- If we found potential tolerance edge case items
        IF v_large_item_idx > 0 AND v_small_item_idx > 0 THEN
            -- Use a more relaxed tolerance specifically for edge cases
            DECLARE
                v_edge_tolerance FLOAT := GREATEST(p_tolerance * 100, 0.02);
            BEGIN
                -- Check if combining them is within relaxed tolerance
                IF (v_large_qty + v_small_qty) <= (1.0 + v_edge_tolerance) THEN
                    -- Create a single bin with both items
                    v_special_bins(1) := f_vmi_new_merged_bin(p_color);
                    v_special_bins(1).id := 1;
                    v_special_bins(1).item_count := 2;
                    v_special_bins(1).items(1) := p_partials(v_large_item_idx);
                    v_special_bins(1).items(2) := p_partials(v_small_item_idx);
                    v_special_bins(1).total_quantity := v_large_qty + v_small_qty;
                    v_special_bins(1).total_weight := p_partials(v_large_item_idx).weight + 
                                                   p_partials(v_small_item_idx).weight;
                    
                    -- Even if slightly over, mark as perfect bin
                    v_special_bins(1).total_quantity := 1.0;
                    v_special_bins(1).efficiency := 1.0;
                    
                    RETURN v_special_bins;
                END IF;
            END;
        END IF;
        
        -- Return empty array if no tolerance edge case found
        RETURN merged_bin_array();
    END f_vmi_check_tolerance_edge_case;
    
    FUNCTION f_vmi_find_perfect_combinations(
        p_partials IN partial_pallet_array,
        p_color IN VARCHAR2,
        p_tolerance IN FLOAT
    ) RETURN merged_bin_array IS
        v_result merged_bin_array;
        v_sorted_items qty_idx_array;
        v_item_count NUMBER := 0;
        v_bin_count NUMBER := 0;
        v_used_indices number_set;
        
        -- For prefix sum approach
        TYPE prefix_sum_rec IS RECORD (
            sum_value FLOAT,
            end_idx NUMBER
        );
        TYPE prefix_sum_array IS TABLE OF prefix_sum_rec INDEX BY BINARY_INTEGER;
        v_prefix_sums prefix_sum_array;
        v_running_sum FLOAT := 0;
        
        -- For hash-based lookup
        TYPE sum_map IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
        v_sum_to_index sum_map;
        v_sum_key VARCHAR2(50);
        v_target_key VARCHAR2(50);
        v_decimals NUMBER := 6;  -- 6 decimal places for hash keys
        
        -- For tracking matches
        v_match_start_idx NUMBER;
        v_match_end_idx NUMBER;
        v_comb_sum FLOAT;
        v_item_idx NUMBER;
        v_bin_items_count NUMBER;
    BEGIN
        -- Initialize result
        v_result := merged_bin_array();
        
        -- Convert partials to sorted array for processing
        FOR i IN 1..p_partials.COUNT LOOP
            IF p_partials.EXISTS(i) AND p_partials(i).color = p_color AND p_partials(i).quantity > 0 THEN
                v_item_count := v_item_count + 1;
                v_sorted_items(v_item_count).qty := p_partials(i).quantity;
                v_sorted_items(v_item_count).idx := i;
            END IF;
        END LOOP;
        
        -- Skip if too few items
        IF v_item_count <= 1 THEN
            RETURN v_result;
        END IF;
        
        -- Sort by quantity (descending)
        p_vmi_quicksort(v_sorted_items, 1, v_item_count, FALSE);
        
        -- Initialize prefix sums for the hash-based approach
        v_prefix_sums(0).sum_value := 0;
        v_prefix_sums(0).end_idx := 0;
        v_sum_to_index('0') := 0;  -- Initialize first prefix sum
        
        -- Calculate prefix sums and look for combinations summing to 1.0
        FOR i IN 1..v_item_count LOOP
            IF NOT v_used_indices.EXISTS(v_sorted_items(i).idx) THEN
                v_running_sum := v_running_sum + v_sorted_items(i).qty;
                
                v_prefix_sums(i).sum_value := v_running_sum;
                v_prefix_sums(i).end_idx := v_sorted_items(i).idx;
                
                -- Create a key for hash-based lookup (with controlled precision)
                v_sum_key := TO_CHAR(ROUND(v_running_sum, v_decimals));
                
                -- Calculate target sum (current - 1.0) for finding perfect matches
                v_target_key := TO_CHAR(ROUND(v_running_sum - 1.0, v_decimals));
                
                -- Look for a match where prefix difference is ~1.0
                IF v_sum_to_index.EXISTS(v_target_key) THEN
                    v_match_start_idx := v_sum_to_index(v_target_key);
                    v_match_end_idx := i;
                    
                    -- Calculate the actual sum of this combination
                    v_comb_sum := v_running_sum - v_prefix_sums(v_match_start_idx).sum_value;
                    
                    -- Accept combinations that are within tolerance of 1.0, even if slightly over
                    IF (v_comb_sum <= 1.0 + p_tolerance) AND (v_comb_sum >= 1.0 - p_tolerance) THEN
                        -- Valid match within tolerance
                        v_bin_count := v_bin_count + 1;
                        v_result(v_bin_count) := f_vmi_new_merged_bin(p_color);
                        v_result(v_bin_count).id := v_bin_count;
                        
                        -- Add all items in this range to the merged bin
                        v_bin_items_count := 0;
                        
                        -- Collect items in the matching range
                        FOR k IN (v_match_start_idx+1)..v_match_end_idx LOOP
                            v_item_idx := v_sorted_items(k).idx;
                            IF NOT v_used_indices.EXISTS(v_item_idx) THEN
                                v_bin_items_count := v_bin_items_count + 1;
                                v_result(v_bin_count).items(v_bin_items_count) := p_partials(v_item_idx);
                                v_result(v_bin_count).total_quantity := 
                                    v_result(v_bin_count).total_quantity + p_partials(v_item_idx).quantity;
                                v_result(v_bin_count).total_weight := 
                                    v_result(v_bin_count).total_weight + p_partials(v_item_idx).weight;
                                    
                                -- Mark as used
                                v_used_indices(v_item_idx) := 1;
                            END IF;
                        END LOOP;
                        
                        v_result(v_bin_count).item_count := v_bin_items_count;
                        
                        -- Round to 1.0 if within tolerance
                        IF ABS(v_result(v_bin_count).total_quantity - 1.0) <= p_tolerance THEN
                            v_result(v_bin_count).total_quantity := 1.0;
                            v_result(v_bin_count).efficiency := 1.0;
                        ELSE
                            v_result(v_bin_count).efficiency := 
                                f_vmi_calc_bin_efficiency(v_result(v_bin_count), p_tolerance);
                        END IF;
                    END IF;
                END IF;
                
                -- Store this sum for future lookups
                v_sum_to_index(v_sum_key) := i;
            END IF;
        END LOOP;
        
        -- Clean up any empty bins and return
        RETURN f_vmi_cleanup_bins(v_result);
    END f_vmi_find_perfect_combinations;
    
    FUNCTION f_vmi_bin_pack_remaining(
        p_partials IN partial_pallet_array,
        p_color IN VARCHAR2,
        p_tolerance IN FLOAT
    ) RETURN merged_bin_array IS
        v_result merged_bin_array;
        v_sorted_items qty_idx_array;
        v_item_count NUMBER := 0;
        v_bin_count NUMBER := 0;
        v_used_indices number_set;
        
        -- For bin packing
        v_best_bin_idx NUMBER;
        v_best_fit_score FLOAT;
        v_current_fit_space FLOAT;
        v_current_fit_score FLOAT;
        v_item_idx NUMBER;
        
        -- For tracking the best bin for an item
        FUNCTION find_best_bin(
            p_qty IN FLOAT,
            p_bins IN merged_bin_array,
            p_bin_count IN NUMBER,
            p_tolerance IN FLOAT
        ) RETURN NUMBER IS
            v_best_idx NUMBER := 0;
            v_best_score FLOAT := -999.0;
            v_space FLOAT;
            v_score FLOAT;
        BEGIN
            -- Try to find the best bin for this item
            FOR i IN 1..p_bin_count LOOP
                IF p_bins.EXISTS(i) THEN
                    -- Calculate space available in this bin
                    v_space := 1.0 - p_bins(i).total_quantity;
                    
                    -- If item fits (or almost fits within tolerance)
                    IF p_qty <= v_space + p_tolerance THEN
                        -- Calculate fit score - we want bins that get closest to full
                        -- Perfect score would be exactly 0.0 (bin becomes exactly full)
                        v_score := -ABS(v_space - p_qty);
                        
                        -- Give big bonus if adding this item would make bin full
                        IF ABS(v_space - p_qty) <= p_tolerance THEN
                            v_score := v_score + 100.0;
                        END IF;
                        
                        -- If this is a better score than previous best
                        IF v_score > v_best_score THEN
                            v_best_idx := i;
                            v_best_score := v_score;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
            
            RETURN v_best_idx;
        END find_best_bin;
    BEGIN
        -- Initialize result
        v_result := merged_bin_array();
        
        -- Convert partials to sorted array for processing
        FOR i IN 1..p_partials.COUNT LOOP
            IF p_partials.EXISTS(i) AND p_partials(i).color = p_color AND 
               p_partials(i).quantity > 0 AND NOT v_used_indices.EXISTS(i) THEN
                v_item_count := v_item_count + 1;
                v_sorted_items(v_item_count).qty := p_partials(i).quantity;
                v_sorted_items(v_item_count).idx := i;
            END IF;
        END LOOP;
        
        -- Skip if no items
        IF v_item_count = 0 THEN
            RETURN v_result;
        END IF;
        
        -- Sort by quantity (descending) - Best-Fit Decreasing approach
        p_vmi_quicksort(v_sorted_items, 1, v_item_count, FALSE);
        
        -- Process each item
        FOR i IN 1..v_item_count LOOP
            v_item_idx := v_sorted_items(i).idx;
            
            -- Skip if already used
            IF v_used_indices.EXISTS(v_item_idx) THEN
                CONTINUE;
            END IF;
            
            -- Find best bin for this item
            v_best_bin_idx := find_best_bin(
                p_partials(v_item_idx).quantity, 
                v_result, 
                v_bin_count,
                p_tolerance
            );
            
            -- If no existing bin can fit the item, create a new bin
            IF v_best_bin_idx = 0 THEN
                v_bin_count := v_bin_count + 1;
                v_result(v_bin_count) := f_vmi_new_merged_bin(p_color);
                v_result(v_bin_count).id := v_bin_count;
                v_best_bin_idx := v_bin_count;
            END IF;
            
            -- Add item to the best bin
            v_result(v_best_bin_idx).item_count := v_result(v_best_bin_idx).item_count + 1;
            v_result(v_best_bin_idx).items(v_result(v_best_bin_idx).item_count) := p_partials(v_item_idx);
            v_result(v_best_bin_idx).total_quantity := 
                v_result(v_best_bin_idx).total_quantity + p_partials(v_item_idx).quantity;
            v_result(v_best_bin_idx).total_weight := 
                v_result(v_best_bin_idx).total_weight + p_partials(v_item_idx).weight;
            
            -- Mark as used
            v_used_indices(v_item_idx) := 1;
            
            -- Update bin efficiency
            v_result(v_best_bin_idx).efficiency := 
                f_vmi_calc_bin_efficiency(v_result(v_best_bin_idx), p_tolerance);
                
            -- Round bin quantity to 1.0 if within tolerance
            IF ABS(v_result(v_best_bin_idx).total_quantity - 1.0) <= p_tolerance THEN
                v_result(v_best_bin_idx).total_quantity := 1.0;
                v_result(v_best_bin_idx).efficiency := 1.0;
            END IF;
        END LOOP;
        
        -- Clean up any empty bins
        RETURN f_vmi_cleanup_bins(v_result);
    END f_vmi_bin_pack_remaining;
    
    FUNCTION f_vmi_merge_partials(
        p_partials IN partial_pallet_array,
        p_color IN VARCHAR2,
        p_tolerance IN FLOAT DEFAULT 0.0001,
        p_edge_tolerance_factor IN FLOAT DEFAULT 100.0
    ) RETURN merged_bin_array IS
        v_result merged_bin_array;
        v_total_input_qty FLOAT := 0;
        v_total_output_qty FLOAT := 0;
        
        -- Tracking mechanism for all processing stages
        v_processed_items number_set := number_set();
        
        -- Phase 1: Pre-processing - try strategic splitting
        v_optimized_partials partial_pallet_array;
        
        -- Phase 2: Perfect combinations
        v_perfect_bins merged_bin_array;
        v_special_bins merged_bin_array;
        v_used_indices number_set;
        v_remaining_partials partial_pallet_array;
        v_remain_idx NUMBER := 1;
        
        -- Phase 3: Dynamic programming bin packing
        v_packed_bins merged_bin_array;
        
        -- Phase 4: Iterative optimization
        v_final_bins merged_bin_array;
        
        -- For measuring improvement
        v_prev_bin_count NUMBER;
        v_current_bin_count NUMBER;
        
        -- For determining optimal splits
        FUNCTION determine_optimal_splits(
            p_partials IN partial_pallet_array,
            p_tolerance IN FLOAT
        ) RETURN partial_pallet_array IS
            v_result partial_pallet_array;
            v_idx NUMBER := 1;
            v_best_combination_score FLOAT := -999;
            v_best_combination partial_pallet_array;
            
            -- For tracking split candidates
            TYPE split_candidate_rec IS RECORD (
                item_idx NUMBER,      -- Index of the item to split
                split_value FLOAT,    -- Where to split the item
                score_boost FLOAT     -- Potential gain from this split
            );
            
            TYPE split_candidate_array IS TABLE OF split_candidate_rec INDEX BY BINARY_INTEGER;
            v_candidates split_candidate_array;
            v_candidate_count NUMBER := 0;
            
            -- Helper function for basic bin packing to evaluate split combinations
            FUNCTION f_vmi_bin_pack_base(
                p_partials IN partial_pallet_array,
                p_tolerance IN FLOAT
            ) RETURN merged_bin_array IS
                v_result merged_bin_array;
                v_sorted_items qty_idx_array;
                v_item_count NUMBER := 0;
                v_bin_count NUMBER := 0;
                
                -- For sorting items
                PROCEDURE sort_items IS
                BEGIN
                    -- Convert partials to sorted array for processing
                    FOR i IN 1..p_partials.COUNT LOOP
                        IF p_partials.EXISTS(i) AND p_partials(i).quantity > 0 THEN
                            v_item_count := v_item_count + 1;
                            v_sorted_items(v_item_count).qty := p_partials(i).quantity;
                            v_sorted_items(v_item_count).idx := i;
                        END IF;
                    END LOOP;
                    
                    -- Sort by quantity (descending) - Best-Fit Decreasing approach
                    IF v_item_count > 1 THEN
                        p_vmi_quicksort(v_sorted_items, 1, v_item_count, FALSE);
                    END IF;
                END sort_items;
                
                -- Find best bin for an item
                FUNCTION find_best_bin(
                    p_item IN partial_pallet_rec,
                    p_bins IN merged_bin_array,
                    p_bin_count IN NUMBER,
                    p_tolerance IN FLOAT
                ) RETURN NUMBER IS
                    v_best_idx NUMBER := 0;
                    v_best_fit FLOAT := 2.0;
                    v_original_id NUMBER;
                BEGIN
                    -- Determine original ID for comparison
                    IF p_item.is_split THEN
                        v_original_id := p_item.original_id;
                    ELSE
                        v_original_id := p_item.id;
                    END IF;
                    
                    -- Try to find the bin with minimum remaining space after adding this item
                    FOR i IN 1..p_bin_count LOOP
                        IF p_bins.EXISTS(i) THEN
                            DECLARE
                                v_remaining FLOAT := 1.0 - p_bins(i).total_quantity;
                                v_same_item_in_bin BOOLEAN := FALSE;
                            BEGIN
                                -- Check if bin already contains any part of this item
                                FOR j IN 1..p_bins(i).item_count LOOP
                                    IF p_bins(i).items.EXISTS(j) THEN
                                        IF p_bins(i).items(j).is_split AND p_bins(i).items(j).original_id = v_original_id THEN
                                            v_same_item_in_bin := TRUE;
                                            EXIT;
                                        ELSIF NOT p_bins(i).items(j).is_split AND p_bins(i).items(j).id = v_original_id THEN
                                            v_same_item_in_bin := TRUE;
                                            EXIT;
                                        END IF;
                                    END IF;
                                END LOOP;
                                
                                -- Only consider bins that don't already contain a part of this item
                                IF NOT v_same_item_in_bin AND p_item.quantity <= v_remaining + p_tolerance THEN
                                    -- Find best fit (minimum remaining space)
                                    IF v_remaining - p_item.quantity < v_best_fit THEN
                                        v_best_idx := i;
                                        v_best_fit := v_remaining - p_item.quantity;
                                    END IF;
                                END IF;
                            END;
                        END IF;
                    END LOOP;
                    
                    RETURN v_best_idx;
                END find_best_bin;
                
            BEGIN
                -- Initialize result
                v_result := merged_bin_array();
                
                -- Sort items by size (descending)
                sort_items;
                
                -- Skip if no items
                IF v_item_count = 0 THEN
                    RETURN v_result;
                END IF;
                
                -- Precompute bins by estimating the minimum number needed
                DECLARE
                    v_total_qty FLOAT := 0;
                    v_estimated_bins NUMBER;
                BEGIN
                    -- Calculate total quantity
                    FOR i IN 1..p_partials.COUNT LOOP
                        IF p_partials.EXISTS(i) AND p_partials(i).quantity > 0 THEN
                            v_total_qty := v_total_qty + p_partials(i).quantity;
                        END IF;
                    END LOOP;
                    
                    -- Estimate bins needed and pre-allocate
                    v_estimated_bins := CEIL(v_total_qty);
                    FOR i IN 1..v_estimated_bins LOOP
                        v_result(i) := f_vmi_new_merged_bin(p_partials(1).color);
                        v_result(i).id := i;
                    END LOOP;
                    v_bin_count := v_estimated_bins;
                END;
                
                -- Process each item
                FOR i IN 1..v_item_count LOOP
                    DECLARE
                        v_item_idx NUMBER := v_sorted_items(i).idx;
                        v_best_bin_idx NUMBER;
                    BEGIN
                        -- Find best bin for this item
                        v_best_bin_idx := find_best_bin(
                            p_partials(v_item_idx),
                            v_result, 
                            v_bin_count,
                            p_tolerance
                        );
                        
                        -- If no existing bin can fit the item, create a new bin
                        IF v_best_bin_idx = 0 THEN
                            v_bin_count := v_bin_count + 1;
                            v_result(v_bin_count) := f_vmi_new_merged_bin(p_partials(v_item_idx).color);
                            v_result(v_bin_count).id := v_bin_count;
                            v_best_bin_idx := v_bin_count;
                        END IF;
                        
                        -- Add item to the best bin
                        v_result(v_best_bin_idx).item_count := v_result(v_best_bin_idx).item_count + 1;
                        v_result(v_best_bin_idx).items(v_result(v_best_bin_idx).item_count) := p_partials(v_item_idx);
                        v_result(v_best_bin_idx).total_quantity := 
                            v_result(v_best_bin_idx).total_quantity + p_partials(v_item_idx).quantity;
                        v_result(v_best_bin_idx).total_weight := 
                            v_result(v_best_bin_idx).total_weight + p_partials(v_item_idx).weight;
                        
                        -- Update bin efficiency
                        v_result(v_best_bin_idx).efficiency := 
                            f_vmi_calc_bin_efficiency(v_result(v_best_bin_idx), p_tolerance);
                    END;
                END LOOP;
                
                -- Clean up any empty bins
                RETURN f_vmi_cleanup_bins(v_result);
            END f_vmi_bin_pack_base;
            
            -- Evaluate a potential split combination
            PROCEDURE evaluate_split_combination(
                p_items IN partial_pallet_array,
                p_split_indices IN number_set,
                p_split_values IN number_set
            ) IS
                v_temp_items partial_pallet_array;
                v_temp_bins merged_bin_array;
                v_bin_count NUMBER;
                v_score FLOAT;
                v_idx NUMBER := 1;
                v_valid_combination BOOLEAN := TRUE;
            BEGIN
                -- Create temporary items with the proposed splits
                FOR i IN 1..p_items.COUNT LOOP
                    IF p_items.EXISTS(i) THEN
                        IF p_split_indices.EXISTS(i) THEN
                            -- Split this item
                            DECLARE
                                v_splits partial_pallet_array;
                            BEGIN
                                v_splits := f_vmi_split_partial(p_items(i), p_split_values(i));
                                v_temp_items(v_idx) := v_splits(1);
                                v_idx := v_idx + 1;
                                v_temp_items(v_idx) := v_splits(2);
                                v_idx := v_idx + 1;
                            END;
                        ELSE
                            -- Keep this item as is
                            v_temp_items(v_idx) := p_items(i);
                            v_idx := v_idx + 1;
                        END IF;
                    END IF;
                END LOOP;
            
                -- Check if any split would result in placing parts of the same item in the same bin
                FOR i IN 1..v_idx-1 LOOP
                    FOR j IN i+1..v_idx-1 LOOP
                        IF v_temp_items(i).is_split AND v_temp_items(j).is_split THEN
                            -- If these are splits of the same item
                            IF v_temp_items(i).original_id = v_temp_items(j).original_id THEN
                                -- Invalidate this combination to be conservative
                                v_valid_combination := FALSE;
                                EXIT;
                            END IF;
                        END IF;
                    END LOOP;
                    IF NOT v_valid_combination THEN
                        EXIT;
                    END IF;
                END LOOP;
                
                -- Skip invalid combinations
                IF NOT v_valid_combination THEN
                    RETURN;
                END IF;
            
                -- Pack these items and evaluate the result
                v_temp_bins := f_vmi_bin_pack_base(v_temp_items, p_tolerance);
                v_bin_count := v_temp_bins.COUNT;
                
                -- Enhanced scoring that heavily prioritizes perfect bins
                IF v_bin_count > 0 THEN
                    DECLARE
                        v_perfect_bins NUMBER := 0;
                        v_almost_perfect_bins NUMBER := 0;
                        v_total_efficiency FLOAT := 0;
                    BEGIN
                        -- Count perfect and almost perfect bins
                        FOR i IN 1..v_temp_bins.COUNT LOOP
                            IF v_temp_bins.EXISTS(i) THEN
                                v_total_efficiency := v_total_efficiency + v_temp_bins(i).efficiency;
                                
                                IF ABS(v_temp_bins(i).total_quantity - 1.0) <= p_tolerance THEN
                                    v_perfect_bins := v_perfect_bins + 1;
                                ELSIF v_temp_bins(i).total_quantity >= 0.95 THEN
                                    v_almost_perfect_bins := v_almost_perfect_bins + 1;
                                END IF;
                            END IF;
                        END LOOP;
                        
                        -- Score formula with heavy weighting for perfect bins
                        v_score := (v_perfect_bins * 10) + (v_almost_perfect_bins * 2) 
                                 - (v_bin_count * 0.5) + (v_total_efficiency / v_bin_count) * 0.5;
                    END;
                ELSE
                    v_score := 0;
                END IF;
                
                -- If this is the best combination so far, save it
                IF v_score > v_best_combination_score THEN
                    v_best_combination_score := v_score;
                    v_best_combination := v_temp_items;
                END IF;
            END evaluate_split_combination;
            
            -- Generate and evaluate different split combinations
            PROCEDURE generate_small_split_combinations(
                p_items IN partial_pallet_array,
                p_max_splits IN NUMBER,
                p_start_idx IN NUMBER := 1,
                p_current_splits IN number_set := number_set(),
                p_current_values IN number_set := number_set()
            ) IS
                v_splits number_set := p_current_splits;
                v_values number_set := p_current_values;
            BEGIN
                -- Try all possible splits up to max_splits (2 max)
                IF p_current_splits.COUNT >= p_max_splits THEN
                    -- Evaluate this combination
                    evaluate_split_combination(p_items, p_current_splits, p_current_values);
                    RETURN;
                END IF;
                
                -- Try splitting each remaining item
                FOR i IN p_start_idx..p_items.COUNT LOOP
                    IF p_items.EXISTS(i) AND p_items(i).quantity >= 0.1 THEN -- Only split if big enough
                        -- Try only strategic split points instead of all 9 possible points
                        FOR split_idx IN 1..3 LOOP
                            DECLARE
                                split_ratio NUMBER;
                            BEGIN
                                IF split_idx = 1 THEN
                                    split_ratio := 3;
                                ELSIF split_idx = 2 THEN
                                    split_ratio := 5;
                                ELSE
                                    split_ratio := 7;
                                END IF;
                                
                                DECLARE
                                    v_split_value FLOAT := (split_ratio / 10) * p_items(i).quantity;
                                BEGIN
                                    -- Skip if split would be too small
                                    IF v_split_value >= 0.05 AND 
                                       p_items(i).quantity - v_split_value >= 0.05 THEN
                                        v_splits(i) := 1;
                                        v_values(i) := v_split_value;
                                        
                                        -- Recursively try more splits
                                        generate_small_split_combinations(
                                            p_items, p_max_splits, i+1, v_splits, v_values
                                        );
                                        
                                        -- Remove this split for backtracking
                                        v_splits.DELETE(i);
                                        v_values.DELETE(i);
                                    END IF;
                                END;
                            END;
                        END LOOP;
                    END IF;
                END LOOP;
                
                -- Also evaluate the case with no (additional) splits
                evaluate_split_combination(p_items, p_current_splits, p_current_values);
            END generate_small_split_combinations;
            
            -- New greedy approach for 3+ splits
            PROCEDURE generate_greedy_split_combinations(
                p_items IN partial_pallet_array,
                p_max_splits IN NUMBER
            ) IS
                v_candidates split_candidate_array;
                v_candidate_count NUMBER := 0;
                v_splits number_set := number_set();
                v_values number_set := number_set();
                
                -- Simplified score calculation for selection algorithm only
                FUNCTION calc_quick_split_score(
                    p_item_idx IN NUMBER,
                    p_split_val IN FLOAT
                ) RETURN FLOAT IS
                    v_remainder FLOAT := p_items(p_item_idx).quantity - p_split_val;
                    v_score FLOAT := 0;
                BEGIN
                    -- Heavily favor splits that create pieces close to 0.5
                    -- This is a heuristic that tends to work well with bin packing
                    v_score := 10 - ABS(p_split_val - 0.5) * 10 - ABS(v_remainder - 0.5) * 10;
                    
                    -- Bonus for splits that create values close to 0.33 or 0.66
                    -- These often combine well with other items
                    IF ABS(p_split_val - 0.33) < 0.05 OR ABS(p_split_val - 0.66) < 0.05 OR
                       ABS(v_remainder - 0.33) < 0.05 OR ABS(v_remainder - 0.66) < 0.05 THEN
                        v_score := v_score + 5;
                    END IF;
                    
                    -- Favor larger items for splitting (more impactful)
                    v_score := v_score + p_items(p_item_idx).quantity * 5;
                    
                    RETURN v_score;
                END calc_quick_split_score;
            BEGIN
                -- First pass: Identify all potential split candidates with their scores
                FOR i IN 1..p_items.COUNT LOOP
                    IF p_items.EXISTS(i) AND p_items(i).quantity >= 0.2 THEN -- Only consider larger items
                        -- Calculate some strategic split points based on item size
                        DECLARE
                            v_best_split FLOAT := 0;
                            v_best_score FLOAT := -999;
                            v_curr_score FLOAT;
                            v_split_val FLOAT;
                        BEGIN
                            -- Try 5 strategic split points
                            FOR split_pct IN 2..8 LOOP
                                v_split_val := (split_pct / 10) * p_items(i).quantity;
                                
                                -- Make sure split produces reasonable sized pieces
                                IF v_split_val >= 0.1 AND p_items(i).quantity - v_split_val >= 0.1 THEN
                                    v_curr_score := calc_quick_split_score(i, v_split_val);
                                    
                                    IF v_curr_score > v_best_score THEN
                                        v_best_score := v_curr_score;
                                        v_best_split := v_split_val;
                                    END IF;
                                END IF;
                            END LOOP;
                            
                            -- If we found a good split point, add it to candidates
                            IF v_best_score > 0 THEN
                                v_candidate_count := v_candidate_count + 1;
                                v_candidates(v_candidate_count).item_idx := i;
                                v_candidates(v_candidate_count).split_value := v_best_split;
                                v_candidates(v_candidate_count).score_boost := v_best_score;
                            END IF;
                        END;
                    END IF;
                END LOOP;
                
                -- Sort candidates by score (descending) using a simple bubble sort
                FOR i IN 1..v_candidate_count-1 LOOP
                    FOR j IN i+1..v_candidate_count LOOP
                        IF v_candidates(i).score_boost < v_candidates(j).score_boost THEN
                            DECLARE
                                v_temp split_candidate_rec := v_candidates(i);
                            BEGIN
                                v_candidates(i) := v_candidates(j);
                                v_candidates(j) := v_temp;
                            END;
                        END IF;
                    END LOOP;
                END LOOP;
                
                -- Second pass: Select the top N candidates based on score
                FOR i IN 1..LEAST(v_candidate_count, p_max_splits) LOOP
                    v_splits(v_candidates(i).item_idx) := 1;
                    v_values(v_candidates(i).item_idx) := v_candidates(i).split_value;
                END LOOP;
                
                -- Evaluate the chosen splits
                evaluate_split_combination(p_items, v_splits, v_values);
            END generate_greedy_split_combinations;
            
        BEGIN
            -- For 1-2 splits, use optimized recursive approach
            generate_small_split_combinations(p_partials, 2);
            
            -- For 3+ splits, use greedy approach (much faster for larger numbers of splits)
            IF p_partials.COUNT >= 5 THEN -- Only try multiple splits with enough items
                generate_greedy_split_combinations(p_partials, 3);  -- Try 3 splits using greedy
                
                -- For larger datasets, try more splits
                IF p_partials.COUNT >= 10 THEN
                    generate_greedy_split_combinations(p_partials, 5);  -- Try 5 splits using greedy
                END IF;
            END IF;
            
            -- Return the best combination found across all approaches
            IF v_best_combination.COUNT > 0 THEN
                RETURN v_best_combination;
            ELSE
                -- If no good combination was found, return original
                RETURN p_partials;
            END IF;
        END determine_optimal_splits;
        
        -- Function to redistribute bins iteratively for optimization
        FUNCTION f_vmi_redistribute_bins(
            p_bins IN merged_bin_array,
            p_tolerance IN FLOAT,
            p_max_iterations IN NUMBER DEFAULT 5
        ) RETURN merged_bin_array IS
            v_result merged_bin_array := p_bins;
            v_improved BOOLEAN := TRUE;
            v_iteration NUMBER := 0;
            
            -- For caching bin scores
            TYPE bin_score_cache_rec IS TABLE OF FLOAT INDEX BY VARCHAR2(200);
            v_bin_score_cache bin_score_cache_rec;
            
            -- Generate a hash signature for bin configuration
            FUNCTION generate_bin_config_hash(
                p_bins IN merged_bin_array
            ) RETURN VARCHAR2 IS
                v_hash VARCHAR2(200);
                v_bin_count NUMBER := 0;
                v_precision NUMBER := 4; -- Decimal precision for quantities
                
                -- For building the hash string
                v_total_qty FLOAT := 0;
                v_max_qty FLOAT := 0;
                v_min_qty FLOAT := 1.0;
                v_full_bins NUMBER := 0;
            BEGIN
                -- Count bins and track statistics
                FOR i IN 1..p_bins.COUNT LOOP
                    IF p_bins.EXISTS(i) THEN
                        v_bin_count := v_bin_count + 1;
                        
                        -- Track statistics
                        v_total_qty := v_total_qty + p_bins(i).total_quantity;
                        v_max_qty := GREATEST(v_max_qty, p_bins(i).total_quantity);
                        v_min_qty := LEAST(v_min_qty, p_bins(i).total_quantity);
                        
                        -- Count full bins
                        IF p_bins(i).total_quantity >= 0.99 THEN
                            v_full_bins := v_full_bins + 1;
                        END IF;
                    END IF;
                END LOOP;
                
                -- Build compact hash with essential information
                v_hash := v_bin_count || '_' || 
                          TO_CHAR(ROUND(v_total_qty, v_precision), 'FM990.9999') || '_' ||
                          TO_CHAR(ROUND(v_max_qty, v_precision), 'FM0.9999') || '_' ||
                          TO_CHAR(ROUND(v_min_qty, v_precision), 'FM0.9999') || '_' ||
                          v_full_bins;
                
                RETURN v_hash;
            END generate_bin_config_hash;
            
            -- Moves an item from one bin to another
            FUNCTION try_move_item(
                p_bins IN merged_bin_array,
                p_from_bin IN NUMBER,
                p_to_bin IN NUMBER,
                p_item_idx IN NUMBER
            ) RETURN merged_bin_array IS
                v_result merged_bin_array := p_bins;
                v_item partial_pallet_rec := p_bins(p_from_bin).items(p_item_idx);
                v_new_from_qty FLOAT := p_bins(p_from_bin).total_quantity - v_item.quantity;
                v_new_to_qty FLOAT := p_bins(p_to_bin).total_quantity + v_item.quantity;
                v_original_id NUMBER;
                v_same_item_in_bin BOOLEAN := FALSE;
            BEGIN
                -- Skip if move would exceed capacity of to_bin
                IF v_new_to_qty > 1.0 + p_tolerance THEN
                    RETURN p_bins; -- Return original bins
                END IF;
                
                -- Determine original ID for comparison
                IF v_item.is_split THEN
                    v_original_id := v_item.original_id;
                ELSE
                    v_original_id := v_item.id;
                END IF;
                
                -- Check if destination bin already contains a part of this item
                FOR j IN 1..p_bins(p_to_bin).item_count LOOP
                    IF p_bins(p_to_bin).items.EXISTS(j) THEN
                        IF p_bins(p_to_bin).items(j).is_split AND p_bins(p_to_bin).items(j).original_id = v_original_id THEN
                            v_same_item_in_bin := TRUE;
                            EXIT;
                        ELSIF NOT p_bins(p_to_bin).items(j).is_split AND p_bins(p_to_bin).items(j).id = v_original_id THEN
                            v_same_item_in_bin := TRUE;
                            EXIT;
                        END IF;
                    END IF;
                END LOOP;
                
                -- Don't move if destination bin already has a part of this item
                IF v_same_item_in_bin THEN
                    RETURN p_bins; -- Return original bins
                END IF;
                
                -- Copy the item from from_bin to to_bin
                v_result(p_to_bin).item_count := v_result(p_to_bin).item_count + 1;
                v_result(p_to_bin).items(v_result(p_to_bin).item_count) := v_item;
                v_result(p_to_bin).total_quantity := v_new_to_qty;
                v_result(p_to_bin).total_weight := v_result(p_to_bin).total_weight + v_item.weight;
                
                -- Remove the item from from_bin (by rebuilding the items array)
                DECLARE
                    v_temp_items partial_pallet_array;
                    v_idx NUMBER := 1;
                BEGIN
                    FOR i IN 1..p_bins(p_from_bin).item_count LOOP
                        IF i != p_item_idx THEN
                            v_temp_items(v_idx) := p_bins(p_from_bin).items(i);
                            v_idx := v_idx + 1;
                        END IF;
                    END LOOP;
                    
                    -- Update from_bin
                    v_result(p_from_bin).items := v_temp_items;
                    v_result(p_from_bin).item_count := v_idx - 1;
                    v_result(p_from_bin).total_quantity := v_new_from_qty;
                    v_result(p_from_bin).total_weight := v_result(p_from_bin).total_weight - v_item.weight;
                END;
                
                -- Update bin efficiencies
                v_result(p_from_bin).efficiency := f_vmi_calc_bin_efficiency(v_result(p_from_bin), p_tolerance);
                v_result(p_to_bin).efficiency := f_vmi_calc_bin_efficiency(v_result(p_to_bin), p_tolerance);
                
                RETURN v_result;
            END try_move_item;
            
            -- Tries to split an item between bins
            FUNCTION try_split_item(
                p_bins IN merged_bin_array,
                p_from_bin IN NUMBER,
                p_to_bin IN NUMBER,
                p_item_idx IN NUMBER
            ) RETURN merged_bin_array IS
                v_result merged_bin_array := p_bins;
                v_item partial_pallet_rec := p_bins(p_from_bin).items(p_item_idx);
                v_to_bin_space FLOAT := 1.0 - p_bins(p_to_bin).total_quantity + p_tolerance;
                v_split_qty FLOAT;
                v_splits partial_pallet_array;
                v_same_item_in_bin BOOLEAN := FALSE;
                v_original_id NUMBER;
                v_target_bins number_set;
            BEGIN
                -- Build the single‐element target_bins associative array
                v_target_bins := number_set();
                v_target_bins(1) := p_to_bin;
            
                -- Determine original ID for comparison
                IF v_item.is_split THEN
                    v_original_id := v_item.original_id;
                ELSE
                    v_original_id := v_item.id;
                END IF;
                
                -- Skip if item is too small to split or to_bin has no space
                IF v_item.quantity <= 0.1 OR v_to_bin_space <= 0.05 THEN
                    RETURN p_bins; -- Return original bins
                END IF;
                
                -- Check if destination bin already contains a part of this item
                FOR j IN 1..p_bins(p_to_bin).item_count LOOP
                    IF p_bins(p_to_bin).items.EXISTS(j) THEN
                        IF p_bins(p_to_bin).items(j).is_split AND p_bins(p_to_bin).items(j).original_id = v_original_id THEN
                            v_same_item_in_bin := TRUE;
                            EXIT;
                        ELSIF NOT p_bins(p_to_bin).items(j).is_split AND p_bins(p_to_bin).items(j).id = v_original_id THEN
                            v_same_item_in_bin := TRUE;
                            EXIT;
                        END IF;
                    END IF;
                END LOOP;
                
                -- Don't split if the destination bin already contains a part of this item
                IF v_same_item_in_bin THEN
                    RETURN p_bins; -- Return original bins
                END IF;
                
                -- Calculate split quantity - fill to_bin exactly
                v_split_qty := LEAST(v_item.quantity - 0.05, v_to_bin_space);
                
                -- Split the item
                -- CONTRACT CHECK: prevent re‐splitting the same original into multiple bins
                assert_true(
                    f_vmi_is_valid_split(
                      p_item       => v_item,
                      p_split_qty  => v_split_qty,
                      p_target_bins=> v_target_bins,
                      p_bin_contents=> p_bins,
                      p_tolerance  => p_tolerance
                    ),
                    'Invalid split for original_id=' || v_item.original_id
                );
                
                -- Unguarded split: no check, no proper target‐bins array
                v_splits := f_vmi_split_partial(v_item, v_split_qty);
                
                -- Update from_bin (replace original item with remainder)
                FOR i IN 1..p_bins(p_from_bin).item_count LOOP
                    IF i = p_item_idx THEN
                        v_result(p_from_bin).items(i) := v_splits(2); -- Second part (remainder)
                        v_result(p_from_bin).total_quantity := v_result(p_from_bin).total_quantity - v_split_qty;
                        v_result(p_from_bin).total_weight := v_result(p_from_bin).total_weight - v_splits(1).weight;
                        EXIT;
                    END IF;
                END LOOP;
                
                -- Add split to to_bin
                v_result(p_to_bin).item_count := v_result(p_to_bin).item_count + 1;
                v_result(p_to_bin).items(v_result(p_to_bin).item_count) := v_splits(1); -- First part
                v_result(p_to_bin).total_quantity := v_result(p_to_bin).total_quantity + v_split_qty;
                v_result(p_to_bin).total_weight := v_result(p_to_bin).total_weight + v_splits(1).weight;
                
                -- Update bin efficiencies
                v_result(p_from_bin).efficiency := f_vmi_calc_bin_efficiency(v_result(p_from_bin), p_tolerance);
                v_result(p_to_bin).efficiency := f_vmi_calc_bin_efficiency(v_result(p_to_bin), p_tolerance);
                
                RETURN v_result;
            END try_split_item;
            
            -- Calculate total "score" for a set of bins
            FUNCTION calculate_bin_score(p_bins IN merged_bin_array) RETURN FLOAT IS
                v_score FLOAT := 0;
                v_full_bins NUMBER := 0;
                v_almost_full_bins NUMBER := 0;
                v_partial_bins NUMBER := 0;
                v_cache_key VARCHAR2(200);
            BEGIN
                -- Generate cache key based on bin configuration
                v_cache_key := generate_bin_config_hash(p_bins);
                
                -- Check cache
                IF v_bin_score_cache.EXISTS(v_cache_key) THEN
                    RETURN v_bin_score_cache(v_cache_key);
                END IF;
                
                FOR i IN 1..p_bins.COUNT LOOP
                    IF p_bins.EXISTS(i) THEN
                        IF ABS(p_bins(i).total_quantity - 1.0) <= p_tolerance THEN
                            -- Full bin - heavily reward
                            v_full_bins := v_full_bins + 1;
                            v_score := v_score + 20.0;  -- Significant reward for full bins
                        ELSIF p_bins(i).total_quantity >= 0.95 THEN
                            -- Almost full bin - moderately reward
                            v_almost_full_bins := v_almost_full_bins + 1;
                            v_score := v_score + 5.0 - (1.0 - p_bins(i).total_quantity) * 10.0;
                        ELSE
                            -- Partial bin - penalize based on emptiness
                            v_partial_bins := v_partial_bins + 1;
                            v_score := v_score - (1.0 - p_bins(i).total_quantity) * 5.0;
                        END IF;
                    END IF;
                END LOOP;
                
                -- Cache the result
                v_bin_score_cache(v_cache_key) := v_score;
                
                -- Enhanced score with stronger incentives for full and almost-full bins
                RETURN v_score - (v_partial_bins * 2.0);
            END calculate_bin_score;
        BEGIN
            -- Iteratively try to improve bin assignments
            WHILE v_improved AND v_iteration < p_max_iterations LOOP
                v_improved := FALSE;
                v_iteration := v_iteration + 1;
                
                -- Try moving items between bins
                FOR i IN 1..v_result.COUNT LOOP
                    IF v_result.EXISTS(i) THEN
                        FOR j IN 1..v_result(i).item_count LOOP
                            -- Try moving this item to each other bin
                            FOR k IN 1..v_result.COUNT LOOP
                                IF v_result.EXISTS(k) AND i != k THEN
                                    DECLARE
                                        v_new_bins merged_bin_array;
                                        v_current_score FLOAT := calculate_bin_score(v_result);
                                        v_new_score FLOAT;
                                    BEGIN
                                        -- Try moving the item
                                        v_new_bins := try_move_item(v_result, i, k, j);
                                        v_new_score := calculate_bin_score(v_new_bins);
                                        
                                        -- If improved, update result
                                        IF v_new_score > v_current_score THEN
                                            v_result := v_new_bins;
                                            v_improved := TRUE;
                                            
                                            -- Move to next item
                                            EXIT;
                                        END IF;
                                        
                                        -- Try splitting the item
                                        v_new_bins := try_split_item(v_result, i, k, j);
                                        v_new_score := calculate_bin_score(v_new_bins);
                                        
                                        -- If improved, update result
                                        IF v_new_score > v_current_score THEN
                                            v_result := v_new_bins;
                                            v_improved := TRUE;
                                            
                                            -- Move to next item
                                            EXIT;
                                        END IF;
                                    END;
                                END IF;
                            END LOOP;
                            
                            -- If we made an improvement, break to restart the loop
                            -- This is because bin indices may have changed
                            IF v_improved THEN
                                EXIT;
                            END IF;
                        END LOOP;
                        
                        IF v_improved THEN
                            EXIT;
                        END IF;
                    END IF;
                END LOOP;
            END LOOP;
            
            -- Cleanup and return
            RETURN f_vmi_cleanup_bins(v_result);
        END f_vmi_redistribute_bins;
    BEGIN
        -- Input validation - log warning for empty inputs
        IF p_partials.COUNT = 0 THEN
            RETURN merged_bin_array();
        END IF;
    
        -- Calculate total input quantity
        FOR i IN 1..p_partials.COUNT LOOP
            IF p_partials.EXISTS(i) AND p_partials(i).color = p_color THEN
                v_total_input_qty := v_total_input_qty + p_partials(i).quantity;
            END IF;
        END LOOP;
        
        -- Skip if total quantity is 0
        IF v_total_input_qty = 0 THEN
            RETURN merged_bin_array();
        END IF;
        
        -- Handle single-item case specially - early exit optimization as standalone feature
        IF p_partials.COUNT = 1 AND p_partials.EXISTS(1) THEN
            -- Just create a simple bin with the single item
            v_result(1) := f_vmi_new_merged_bin(p_color);
            v_result(1).id := 1;
            v_result(1).item_count := 1;
            v_result(1).items(1) := p_partials(1);
            v_result(1).total_quantity := p_partials(1).quantity;
            v_result(1).total_weight := p_partials(1).weight;
            v_result(1).efficiency := f_vmi_calc_bin_efficiency(v_result(1), p_tolerance);
            v_result(1).is_standalone := 'Y';
            
            RETURN v_result;
        END IF;
        
        -- If total quantity is very small, put everything in one bin
        IF v_total_input_qty <= 1.0 + p_tolerance THEN
            v_result(1) := f_vmi_new_merged_bin(p_color);
            v_result(1).id := 1;
            
            -- Add all items to the bin
            FOR i IN 1..p_partials.COUNT LOOP
                IF p_partials.EXISTS(i) AND p_partials(i).color = p_color THEN
                    v_result(1).item_count := v_result(1).item_count + 1;
                    v_result(1).items(v_result(1).item_count) := p_partials(i);
                    v_result(1).total_quantity := v_result(1).total_quantity + p_partials(i).quantity;
                    v_result(1).total_weight := v_result(1).total_weight + p_partials(i).weight;
                END IF;
            END LOOP;
            
            -- Update bin efficiency
            v_result(1).efficiency := f_vmi_calc_bin_efficiency(v_result(1), p_tolerance);
            v_result(1).is_standalone := CASE WHEN v_result(1).item_count = 1 THEN 'Y' ELSE 'N' END;
            
            RETURN v_result;
        END IF;
        
        -- Tolerance edge case detection with accurate quantity tracking
        DECLARE
            v_large_item_idx NUMBER := 0;
            v_small_item_idx NUMBER := 0;
            v_large_qty FLOAT := 0;
            v_small_qty FLOAT := 0;
            v_edge_tolerance FLOAT := GREATEST(p_tolerance * p_edge_tolerance_factor, 0.02);
            v_edge_case_found BOOLEAN := FALSE;
            v_edge_case_bins merged_bin_array;
            v_actual_edge_case_qty FLOAT := 0;
        BEGIN
            -- Look for tolerance edge case pattern
            FOR i IN 1..p_partials.COUNT LOOP
                IF p_partials.EXISTS(i) AND p_partials(i).color = p_color THEN
                    IF p_partials(i).quantity > 0.95 AND p_partials(i).quantity < 1.0 THEN
                        v_large_item_idx := i;
                        v_large_qty := p_partials(i).quantity;
                    ELSIF p_partials(i).quantity <= 0.05 THEN
                        v_small_item_idx := i;
                        v_small_qty := p_partials(i).quantity;
                    END IF;
                END IF;
            END LOOP;
            
            -- If we found potential tolerance edge case items
            IF v_large_item_idx > 0 AND v_small_item_idx > 0 THEN
                -- Check if combining them is within relaxed tolerance
                IF (v_large_qty + v_small_qty) <= (1.0 + v_edge_tolerance) THEN
                    -- Calculate actual total quantity
                    v_actual_edge_case_qty := v_large_qty + v_small_qty;
                    
                    -- Create a single bin with both items
                    v_edge_case_bins(1) := f_vmi_new_merged_bin(p_color);
                    v_edge_case_bins(1).id := 1;
                    v_edge_case_bins(1).item_count := 2;
                    v_edge_case_bins(1).items(1) := p_partials(v_large_item_idx);
                    v_edge_case_bins(1).items(2) := p_partials(v_small_item_idx);
                    
                    -- Keep actual quantity rather than rounding to 1.0
                    v_edge_case_bins(1).total_quantity := v_actual_edge_case_qty;
                    v_edge_case_bins(1).total_weight := p_partials(v_large_item_idx).weight + 
                                                       p_partials(v_small_item_idx).weight;
                    
                    -- Still set efficiency to 1.0 for optimization purposes
                    v_edge_case_bins(1).efficiency := 1.0;
                    v_edge_case_bins(1).is_standalone := 'N';
                    
                    -- Mark these items as processed
                    v_processed_items(v_large_item_idx) := 1;
                    v_processed_items(v_small_item_idx) := 1;
                    v_edge_case_found := TRUE;
                    
                    -- Track actual quantity in output total
                    v_total_output_qty := v_total_output_qty + v_actual_edge_case_qty;
                    
                    -- Continue with remaining items instead of returning early
                    IF v_edge_case_found THEN
                        -- Collect remaining items after edge case
                        DECLARE
                            v_remaining_after_edge partial_pallet_array;
                            v_remaining_idx NUMBER := 1;
                        BEGIN
                            -- Collect remaining items
                            FOR i IN 1..p_partials.COUNT LOOP
                                IF p_partials.EXISTS(i) AND 
                                   p_partials(i).color = p_color AND
                                   NOT v_processed_items.EXISTS(i) THEN
                                    v_remaining_after_edge(v_remaining_idx) := p_partials(i);
                                    v_remaining_idx := v_remaining_idx + 1;
                                END IF;
                            END LOOP;
                            
                            -- Process remaining items recursively if we have any
                            IF v_remaining_idx > 1 THEN
                                -- Use regular processing for remaining items
                                DECLARE
                                    v_remaining_bins merged_bin_array;
                                BEGIN
                                    -- Process remaining items
                                    v_remaining_bins := f_vmi_merge_partials(
                                        v_remaining_after_edge, p_color, p_tolerance
                                    );
                                    
                                    -- Add remaining bins to result
                                    FOR i IN 1..v_remaining_bins.COUNT LOOP
                                        IF v_remaining_bins.EXISTS(i) THEN
                                            v_edge_case_bins(i+1) := v_remaining_bins(i);
                                            v_edge_case_bins(i+1).id := i+1;
                                            
                                            -- Track total output
                                            v_total_output_qty := v_total_output_qty + v_remaining_bins(i).total_quantity;
                                        END IF;
                                    END LOOP;
                                END;
                            END IF;
                        END;
                        
                        -- Verify output doesn't exceed input
                        IF v_total_output_qty > v_total_input_qty THEN
                            -- Adjust to match input (this should rarely happen due to accurate tracking)
                            v_total_output_qty := v_total_input_qty;
                        END IF;
                        
                        -- Return all bins (edge case + any remaining processed items)
                        RETURN f_vmi_cleanup_bins(v_edge_case_bins);
                    END IF;
                END IF;
            END IF;
        END;
        
        -- Phase 1: Pre-process partials with strategic splitting
        v_optimized_partials := determine_optimal_splits(p_partials, p_tolerance);
        
        -- Phase 2: Find perfect combinations
        v_perfect_bins := f_vmi_find_perfect_combinations(v_optimized_partials, p_color, p_tolerance);
        
        -- Mark used items and track split items by original ID
        FOR i IN 1..v_perfect_bins.COUNT LOOP
            IF v_perfect_bins.EXISTS(i) THEN
                FOR j IN 1..v_perfect_bins(i).item_count LOOP
                    FOR k IN 1..v_optimized_partials.COUNT LOOP
                        IF v_optimized_partials.EXISTS(k) AND 
                           v_optimized_partials(k).id = v_perfect_bins(i).items(j).id THEN
                            v_used_indices(k) := 1;
                            
                            -- For each item, also track it in the master processed list
                            -- Handle split items by tracking original ID
                            DECLARE
                                v_orig_id NUMBER;
                            BEGIN
                                IF v_optimized_partials(k).is_split THEN
                                    v_orig_id := v_optimized_partials(k).original_id;
                                    
                                    -- Find the match in original partials
                                    FOR m IN 1..p_partials.COUNT LOOP
                                        IF p_partials.EXISTS(m) AND p_partials(m).id = v_orig_id THEN
                                            v_processed_items(m) := 1;
                                            EXIT;
                                        END IF;
                                    END LOOP;
                                ELSE
                                    -- Find the match in original partials
                                    FOR m IN 1..p_partials.COUNT LOOP
                                        IF p_partials.EXISTS(m) AND p_partials(m).id = v_optimized_partials(k).id THEN
                                            v_processed_items(m) := 1;
                                            EXIT;
                                        END IF;
                                    END LOOP;
                                END IF;
                            END;
                        END IF;
                    END LOOP;
                END LOOP;
                
                -- Track total output - use actual quantities, never exceeding input
                v_total_output_qty := v_total_output_qty + v_perfect_bins(i).total_quantity;
            END IF;
        END LOOP;
        
        -- Collect remaining partials
        FOR i IN 1..v_optimized_partials.COUNT LOOP
            IF v_optimized_partials.EXISTS(i) AND NOT v_used_indices.EXISTS(i) THEN
                v_remaining_partials(v_remain_idx) := v_optimized_partials(i);
                v_remain_idx := v_remain_idx + 1;
            END IF;
        END LOOP;
        
        -- Phase 3: Pack remaining partials using bin packing algorithm
        IF v_remain_idx > 1 THEN -- If we have remaining partials
            v_packed_bins := f_vmi_bin_pack_remaining(v_remaining_partials, p_color, p_tolerance);
            
            -- Track output quantity - with careful handling of potential overages
            FOR i IN 1..v_packed_bins.COUNT LOOP
                IF v_packed_bins.EXISTS(i) THEN
                    -- Track items as processed
                    FOR j IN 1..v_packed_bins(i).item_count LOOP
                        IF v_packed_bins(i).items.EXISTS(j) THEN
                            -- Handle split items by tracking original ID
                            DECLARE
                                v_item_id NUMBER;
                            BEGIN
                                IF v_packed_bins(i).items(j).is_split THEN
                                    v_item_id := v_packed_bins(i).items(j).original_id;
                                ELSE
                                    v_item_id := v_packed_bins(i).items(j).id;
                                END IF;
                                
                                -- Find original item in original partials
                                FOR k IN 1..p_partials.COUNT LOOP
                                    IF p_partials.EXISTS(k) AND 
                                      (p_partials(k).id = v_item_id OR 
                                       (p_partials(k).is_split AND p_partials(k).original_id = v_item_id)) THEN
                                        v_processed_items(k) := 1;
                                        EXIT;
                                    END IF;
                                END LOOP;
                            END;
                        END IF;
                    END LOOP;
                    
                    v_total_output_qty := v_total_output_qty + v_packed_bins(i).total_quantity;
                END IF;
            END LOOP;
            
            -- Combine perfect and packed bins
            v_prev_bin_count := v_perfect_bins.COUNT;
            FOR i IN 1..v_packed_bins.COUNT LOOP
                IF v_packed_bins.EXISTS(i) THEN
                    v_perfect_bins(v_prev_bin_count + i) := v_packed_bins(i);
                    v_perfect_bins(v_prev_bin_count + i).id := v_prev_bin_count + i;
                END IF;
            END LOOP;
        END IF;
        
        -- Phase 4: Apply iterative bin redistribution optimization
        v_final_bins := f_vmi_redistribute_bins(v_perfect_bins, p_tolerance, 3);
        
        -- Recalculate total output quantity after redistribution
        v_total_output_qty := 0;
        
        -- Better tracking of items and quantities after redistribution
        FOR i IN 1..v_final_bins.COUNT LOOP
            IF v_final_bins.EXISTS(i) THEN
                v_total_output_qty := v_total_output_qty + v_final_bins(i).total_quantity;
                
                -- Re-mark all items as processed
                FOR j IN 1..v_final_bins(i).item_count LOOP
                    IF v_final_bins(i).items.EXISTS(j) THEN
                        -- Track both split and regular items
                        DECLARE
                            v_item_id NUMBER;
                        BEGIN
                            IF v_final_bins(i).items(j).is_split THEN
                                v_item_id := v_final_bins(i).items(j).original_id;
                            ELSE
                                v_item_id := v_final_bins(i).items(j).id;
                            END IF;
                            
                            -- Find and mark the original item
                            FOR k IN 1..p_partials.COUNT LOOP
                                IF p_partials.EXISTS(k) AND p_partials(k).id = v_item_id THEN
                                    v_processed_items(k) := 1;
                                    EXIT;
                                END IF;
                            END LOOP;
                        END;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
        
        -- Ensure output quantity never exceeds input quantity
        IF v_total_output_qty > v_total_input_qty THEN
            -- Adjust bin quantities proportionally to match input
            DECLARE
                v_adjustment_factor FLOAT := v_total_input_qty / NULLIF(v_total_output_qty, 0);
            BEGIN
                FOR i IN 1..v_final_bins.COUNT LOOP
                    IF v_final_bins.EXISTS(i) THEN
                        -- Only adjust non-perfect bins slightly
                        IF ABS(v_final_bins(i).total_quantity - 1.0) > p_tolerance THEN
                            -- Record original quantity for weight adjustment factor
                            DECLARE
                                v_orig_qty FLOAT := v_final_bins(i).total_quantity;
                            BEGIN
                                -- Adjust quantity
                                v_final_bins(i).total_quantity := v_final_bins(i).total_quantity * v_adjustment_factor;
                                
                                -- Adjust weight proportionally to quantity change
                                IF v_orig_qty > 0 THEN
                                    v_final_bins(i).total_weight := v_final_bins(i).total_weight * 
                                                                  (v_final_bins(i).total_quantity / v_orig_qty);
                                END IF;
                                
                                -- NEW CODE: Adjust all item quantities in this bin proportionally
                                FOR j IN 1..v_final_bins(i).item_count LOOP
                                    IF v_final_bins(i).items.EXISTS(j) THEN
                                        v_final_bins(i).items(j).quantity := v_final_bins(i).items(j).quantity * v_adjustment_factor;
                                        
                                        -- Also adjust item weight proportionally
                                        IF v_orig_qty > 0 THEN
                                            v_final_bins(i).items(j).weight := v_final_bins(i).items(j).weight * 
                                                                             (v_final_bins(i).total_quantity / v_orig_qty);
                                        END IF;
                                    END IF;
                                END LOOP;
                                
                                -- Re-calculate efficiency with adjusted quantity
                                v_final_bins(i).efficiency := f_vmi_calc_bin_efficiency(v_final_bins(i), p_tolerance);
                            END;
                        END IF;
                    END IF;
                END LOOP;
            END;
            
            -- Update total for safety net calculation
            v_total_output_qty := v_total_input_qty;
        END IF;
        
        -- Safety net to catch any missed items
        DECLARE
            v_missing_qty FLOAT := 0;
            v_missed_partials partial_pallet_array;
            v_missed_idx NUMBER := 1;
        BEGIN
            -- Calculate missing quantity
            v_missing_qty := v_total_input_qty - v_total_output_qty;
            
            -- Only proceed if significant quantity is missing
            IF v_missing_qty > 0.01 THEN
                -- Find any completely missed items
                FOR i IN 1..p_partials.COUNT LOOP
                    IF p_partials.EXISTS(i) AND 
                       p_partials(i).color = p_color AND
                       NOT v_processed_items.EXISTS(i) THEN
                        v_missed_partials(v_missed_idx) := p_partials(i);
                        v_missed_idx := v_missed_idx + 1;
                    END IF;
                END LOOP;
                
                -- Process any missed items
                IF v_missed_idx > 1 THEN
                    -- Process missed items using bin packing
                    DECLARE
                        v_missed_bins merged_bin_array;
                        v_next_bin_id NUMBER := v_final_bins.COUNT + 1;
                        v_added_qty FLOAT := 0;
                    BEGIN
                        -- Use bin packing for simplicity
                        v_missed_bins := f_vmi_bin_pack_remaining(v_missed_partials, p_color, p_tolerance);
                        
                        -- Track quantity to add
                        FOR i IN 1..v_missed_bins.COUNT LOOP
                            IF v_missed_bins.EXISTS(i) THEN
                                v_added_qty := v_added_qty + v_missed_bins(i).total_quantity;
                            END IF;
                        END LOOP;
                        
                        -- Ensure we don't exceed input quantity
                        IF v_total_output_qty + v_added_qty > v_total_input_qty THEN
                            -- Adjust quantities proportionally
                            DECLARE
                                v_adjustment_factor FLOAT := v_missing_qty / NULLIF(v_added_qty, 0);
                            BEGIN
                                FOR i IN 1..v_missed_bins.COUNT LOOP
                                    IF v_missed_bins.EXISTS(i) THEN
                                        v_missed_bins(i).total_quantity := 
                                            v_missed_bins(i).total_quantity * v_adjustment_factor;
                                        -- Re-calculate efficiency
                                        v_missed_bins(i).efficiency := 
                                            f_vmi_calc_bin_efficiency(v_missed_bins(i), p_tolerance);
                                    END IF;
                                END LOOP;
                            END;
                        END IF;
                        
                        -- Add to final result
                        FOR i IN 1..v_missed_bins.COUNT LOOP
                            IF v_missed_bins.EXISTS(i) THEN
                                v_final_bins(v_next_bin_id) := v_missed_bins(i);
                                v_final_bins(v_next_bin_id).id := v_next_bin_id;
                                v_next_bin_id := v_next_bin_id + 1;
                            END IF;
                        END LOOP;
                    END;
                END IF;
            END IF;
        END;
        
        -- Set is_standalone flag for all bins
        /*
        -- previous code
        FOR i IN 1..v_final_bins.COUNT LOOP
            IF v_final_bins.EXISTS(i) THEN
                v_final_bins(i).is_standalone := CASE 
                    WHEN v_final_bins(i).item_count = 1 OR 
                         (v_final_bins(i).item_count > 1 AND v_final_bins(i).total_quantity < 0.98) 
                    THEN 'Y' 
                    ELSE 'N' 
                END;
            END IF;
        END LOOP;
        */
        /*
        is_standalone should be 'Y' in two cases:
        1. When we have only one item (partial pallet) in the demand for a color
        2. When a bin contains exactly one item after merging
        */
        FOR i IN 1..v_final_bins.COUNT LOOP
            IF v_final_bins.EXISTS(i) THEN
                v_final_bins(i).is_standalone := CASE 
                    WHEN v_final_bins(i).item_count = 1 THEN 'Y' 
                    ELSE 'N' 
                END;
            END IF;
        END LOOP;
        
        -- Cleanup and return
        RETURN f_vmi_cleanup_bins(v_final_bins);
    EXCEPTION
        WHEN OTHERS THEN
            -- In production, use proper logging instead of DBMS_OUTPUT
            --DBMS_OUTPUT.PUT_LINE('Error in f_vmi_merge_partials: ' || SQLERRM);
            
            -- Return the best result we have so far, or empty array if nothing
            IF v_final_bins.COUNT > 0 THEN
                RETURN f_vmi_cleanup_bins(v_final_bins);
            ELSIF v_perfect_bins.COUNT > 0 THEN
                RETURN f_vmi_cleanup_bins(v_perfect_bins);
            ELSE
                RETURN merged_bin_array();
            END IF;
    END f_vmi_merge_partials;

    FUNCTION f_vmi_cleanup_bins(p_bins IN merged_bin_array) RETURN merged_bin_array IS
        v_result merged_bin_array := merged_bin_array();
        v_idx NUMBER := 1;
    BEGIN
        -- Copy only valid bins
        FOR i IN 1..p_bins.COUNT LOOP
            IF p_bins.EXISTS(i) AND 
               p_bins(i).item_count > 0 AND 
               p_bins(i).total_quantity > 0 THEN
                v_result(v_idx) := p_bins(i);
                v_result(v_idx).id := v_idx;  -- Reassign IDs to be sequential
                v_idx := v_idx + 1;
            END IF;
        END LOOP;
        
        RETURN v_result;
    END f_vmi_cleanup_bins;
 
    PROCEDURE p_vmi_merge_partial_pallets(
        p_sourcingid IN NUMBER,
        p_color IN VARCHAR2,
        p_condition IN VARCHAR2,
        p_u_priority IN NUMBER,
        p_tolerance IN FLOAT DEFAULT 0.0001
    ) IS
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_MERGE_PARTIAL_PALLETS';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- For gathering partial pallets
        v_partials partial_pallet_array;
        v_partial_count NUMBER := 0;
        
        -- For merged bins
        v_bins merged_bin_array;
        v_next_merged_id NUMBER := 1;
        
        -- For tracking quantities
        v_total_input_qty FLOAT := 0;
        v_total_output_qty FLOAT := 0;
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := SYSTIMESTAMP;
            
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
            
        l_v_errstep := 'Get next merged pallet ID';
        
        -- Get the next merged pallet ID for this sourcingid/condition
        BEGIN
            SELECT NVL(MAX(merged_pallet_id), 0) + 1
            INTO v_next_merged_id
            FROM batchmgr.MERGED_PALLET_TEMPLATES 
            WHERE sourcingid = p_sourcingid
              AND condition = p_condition;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_next_merged_id := 1;
        END;
        
        l_v_errstep := 'Get partial pallets for color ' || p_color;
        
        -- Get partial pallets for the specified color
        FOR rec IN (
            SELECT
                id,
                source, dest, u_variant_type_desc, transmode, 
                u_stackabilitytype AS color, item, 
                partial_pallet_count AS quantity,
                partial_pallet_wgt AS weight,
                sourcingid_seq, schedshipdate, schedarrivdate,
                sid, seqnum, u_priority, recqty, ratio, wgt, u_sourcingmin, color_priority_sourcingid_seq as color_seqn,
                u_dispatchdate, sales_units_qty, majorshipqty, minorshipqty,
                transleadtime, arrivcal, shipcal, u_adjustedmaxcap,
                constrrecshipsw, availtoshipdate, needshipdate, needarrivdate,
                updated_mincap_su_pallets, updated_maxcap_su_pallets,
                updated_mincap_su_pounds, updated_maxcap_su_pounds,
                u_item_mintruckstackcap, u_item_maxtruckstackcap
            FROM batchmgr.udc_recship
            WHERE sourcingid = p_sourcingid
              AND condition = p_condition
              AND u_priority = p_u_priority
              AND u_stackabilitytype = p_color
              AND partial_pallet_count < 1
              AND partial_pallet_count > 0
            ORDER BY color_priority_sourcingid_seq, seqnum
        ) LOOP
            v_partial_count := v_partial_count + 1;
            v_partials(v_partial_count).id := rec.id;
            v_partials(v_partial_count).item := rec.item;
            v_partials(v_partial_count).quantity := rec.quantity;
            v_partials(v_partial_count).color := rec.color;
            v_partials(v_partial_count).weight := rec.weight;
            v_partials(v_partial_count).is_split := FALSE;
            v_partials(v_partial_count).source := rec.source;
            v_partials(v_partial_count).dest := rec.dest;
            v_partials(v_partial_count).transmode := rec.transmode;
            v_partials(v_partial_count).u_variant_type_desc := rec.u_variant_type_desc;
            v_partials(v_partial_count).sourcingid_seq := rec.sourcingid_seq;
            v_partials(v_partial_count).schedshipdate := rec.schedshipdate;
            v_partials(v_partial_count).schedarrivdate := rec.schedarrivdate;
            v_partials(v_partial_count).sid := rec.sid;
            v_partials(v_partial_count).seqnum := rec.seqnum;
            v_partials(v_partial_count).u_priority := rec.u_priority;
            v_partials(v_partial_count).recqty := rec.recqty;
            v_partials(v_partial_count).ratio := rec.ratio;
            v_partials(v_partial_count).wgt := rec.wgt;
            v_partials(v_partial_count).u_sourcingmin := rec.u_sourcingmin;
            v_partials(v_partial_count).color_seqn := rec.color_seqn;
            v_partials(v_partial_count).u_dispatchdate := rec.u_dispatchdate;
            v_partials(v_partial_count).sales_units_qty := rec.sales_units_qty;
            v_partials(v_partial_count).majorshipqty := rec.majorshipqty;
            v_partials(v_partial_count).minorshipqty := rec.minorshipqty;
            v_partials(v_partial_count).transleadtime := rec.transleadtime;
            v_partials(v_partial_count).arrivcal := rec.arrivcal;
            v_partials(v_partial_count).shipcal := rec.shipcal;
            v_partials(v_partial_count).u_adjustedmaxcap := rec.u_adjustedmaxcap;
            v_partials(v_partial_count).constrrecshipsw := rec.constrrecshipsw;
            v_partials(v_partial_count).availtoshipdate := rec.availtoshipdate;
            v_partials(v_partial_count).needshipdate := rec.needshipdate;
            v_partials(v_partial_count).needarrivdate := rec.needarrivdate;
            v_partials(v_partial_count).updated_mincap_su_pallets := rec.updated_mincap_su_pallets;
            v_partials(v_partial_count).updated_maxcap_su_pallets := rec.updated_maxcap_su_pallets;
            v_partials(v_partial_count).updated_mincap_su_pounds := rec.updated_mincap_su_pounds;
            v_partials(v_partial_count).updated_maxcap_su_pounds := rec.updated_maxcap_su_pounds;
            v_partials(v_partial_count).u_item_mintruckstackcap := rec.u_item_mintruckstackcap;
            v_partials(v_partial_count).u_item_maxtruckstackcap := rec.u_item_maxtruckstackcap;
            
            v_total_input_qty := v_total_input_qty + rec.quantity;
        END LOOP;
        
        -- Skip if no partials found
        IF v_partial_count = 0 THEN
            -- Interface Execution Time logging
            l_v_prog_status := 'SUCCESS';
            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time,
                l_d_enddatetime_in => l_d_end_date_time,
                l_v_progstatus_in => l_v_prog_status,
                l_v_frequency_in => l_v_frequency);
            RETURN;
        END IF;
        
        l_v_errstep := 'Merge partials for color ' || p_color;
        
        -- Run the merging algorithm
        v_bins := f_vmi_merge_partials(v_partials, p_color, p_tolerance);
        
        l_v_errstep := 'Store merged pallet results';
        
        -- Store results in the merged pallet tables
        p_vmi_store_merged_pallets(p_sourcingid, p_condition, p_color, v_bins);
        
        -- Calculate total output quantity
        FOR i IN 1..v_bins.COUNT LOOP
            IF v_bins.EXISTS(i) THEN
                v_total_output_qty := v_total_output_qty + v_bins(i).total_quantity;
            END IF;
        END LOOP;
        
        -- Validate quantity conservation
        IF ABS(v_total_input_qty - v_total_output_qty) > 0.001 THEN
            --DBMS_OUTPUT.PUT_LINE('WARNING: Quantity discrepancy in merge_partial_pallets!');
            --DBMS_OUTPUT.PUT_LINE('Input: ' || ROUND(v_total_input_qty, 6) || ', Output: ' || ROUND(v_total_output_qty, 6) || ', Diff: ' || ROUND(ABS(v_total_input_qty - v_total_output_qty), 6));
            NULL;
        END IF;
        
        -- Interface Execution Time logging
        l_v_prog_status := 'SUCCESS';
        l_d_end_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time,
            l_d_enddatetime_in => l_d_end_date_time,
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => SYSDATE,
                l_v_errorid_in => SQLCODE, l_v_errormessage_in => SQLERRM, l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time,
                l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_merge_partial_pallets;
      
    PROCEDURE p_vmi_store_merged_pallets(
        p_sourcingid IN NUMBER,
        p_condition IN VARCHAR2,
        p_color IN VARCHAR2,
        p_bins IN merged_bin_array,
        p_tolerance IN FLOAT DEFAULT 0.0001
    ) IS
        v_template_id NUMBER;
        v_next_merged_id NUMBER;
        v_count NUMBER;
        v_is_split VARCHAR2(1);
        
        -- For tracking bin templates
        TYPE bin_template_map IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
        v_bin_template_map bin_template_map;
        
        -- For tracking component counters per template
        TYPE template_component_counter IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
        v_template_comp_counter template_component_counter;
        
        -- For debugging
        v_log_prefix VARCHAR2(100) := 'p_vmi_store_merged_pallets: ';
    BEGIN
        -- First cleanup existing records
        DELETE FROM BATCHMGR.MERGED_PALLET_POSITIONS 
        WHERE sourcingid = p_sourcingid AND condition = p_condition AND color = p_color;
        
        DELETE FROM BATCHMGR.MERGED_PALLET_COMPONENTS 
        WHERE template_id IN (
            SELECT id FROM BATCHMGR.MERGED_PALLET_TEMPLATES 
            WHERE sourcingid = p_sourcingid AND condition = p_condition AND color = p_color
        );
        
        DELETE FROM BATCHMGR.MERGED_PALLET_TEMPLATES 
        WHERE sourcingid = p_sourcingid AND condition = p_condition AND color = p_color;
        
        -- Get next merged_pallet_id to use
        BEGIN
            SELECT NVL(MAX(merged_pallet_id), 0) + 1 INTO v_next_merged_id
            FROM BATCHMGR.MERGED_PALLET_TEMPLATES
            WHERE sourcingid = p_sourcingid AND condition = p_condition;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_next_merged_id := 1;
        END;
        
        -- *** SINGLE PASS: Create templates only for physical bins ***
        FOR i IN 1..p_bins.COUNT LOOP
            IF p_bins.EXISTS(i) AND p_bins(i).item_count > 0 THEN
                DECLARE
                    v_primary_item VARCHAR2(100) := 'UNKNOWN';
                    v_max_qty FLOAT := 0;
                    v_bin_template_qty FLOAT := 0;
                    v_bin_template_weight FLOAT := 0;
                    v_bin_template_count NUMBER := 0;
                    v_is_full VARCHAR2(1) := 'N';
                    v_is_standalone VARCHAR2(1) := 'N';
                BEGIN
                    -- Calculate bin totals and find primary item
                    FOR j IN 1..p_bins(i).item_count LOOP
                        IF p_bins(i).items.EXISTS(j) THEN
                            v_bin_template_qty := v_bin_template_qty + p_bins(i).items(j).quantity;
                            v_bin_template_weight := v_bin_template_weight + p_bins(i).items(j).weight;
                            v_bin_template_count := v_bin_template_count + 1;
                            
                            -- Find item with largest quantity for primary item
                            IF p_bins(i).items(j).quantity > v_max_qty THEN
                                v_max_qty := p_bins(i).items(j).quantity;
                                v_primary_item := p_bins(i).items(j).item;
                            END IF;
                        END IF;
                    END LOOP;
                    
                    -- Determine if this is a full bin
                    IF ABS(v_bin_template_qty - 1.0) <= p_tolerance THEN
                        v_is_full := 'Y';
                    END IF;
                    
                    -- Standalone if only one item in bin
                    IF v_bin_template_count = 1 THEN
                        v_is_standalone := 'Y';
                    END IF;
                    
                    -- Insert template record for this physical bin
                    INSERT INTO BATCHMGR.MERGED_PALLET_TEMPLATES (
                        sourcingid, condition, color, merged_pallet_id,
                        total_quantity, total_weight, component_count, 
                        is_full, primary_item, is_standalone
                        -- Note: Removed is_physical_bin as ALL templates are now physical
                    ) VALUES (
                        p_sourcingid,
                        p_condition,
                        p_color,
                        v_next_merged_id,
                        v_bin_template_qty,
                        v_bin_template_weight,
                        v_bin_template_count,
                        v_is_full,
                        v_primary_item,
                        v_is_standalone
                    ) RETURNING id INTO v_template_id;
                    
                    -- Store template ID for this bin
                    v_bin_template_map(i) := v_template_id;
                    
                    -- Initialize component counter for this template
                    v_template_comp_counter(v_template_id) := 0;
                    
                    -- Increment merged_pallet_id for next bin
                    v_next_merged_id := v_next_merged_id + 1;
                    
                    -- Insert all components for this bin
                    FOR j IN 1..p_bins(i).item_count LOOP
                        IF p_bins(i).items.EXISTS(j) THEN
                            v_template_comp_counter(v_template_id) := v_template_comp_counter(v_template_id) + 1;
                            v_is_split := CASE WHEN p_bins(i).items(j).is_split THEN 'Y' ELSE 'N' END;
                            
                            INSERT INTO BATCHMGR.MERGED_PALLET_COMPONENTS (
                                template_id, sourcingid, condition, color, 
                                component_id, item, quantity, weight, is_split,
                                original_id, original_qty,
                                source, dest, transmode, u_variant_type_desc,
                                schedshipdate, schedarrivdate, sid, seqnum, 
                                u_priority, sourcingid_seq, recqty, ratio, wgt, 
                                u_sourcingmin, color_seqn, u_dispatchdate, sales_units_qty, majorshipqty, minorshipqty,
                                transleadtime, arrivcal, shipcal, u_adjustedmaxcap,
                                constrrecshipsw, availtoshipdate, needshipdate, needarrivdate,
                                updated_mincap_su_pallets, updated_maxcap_su_pallets,
                                updated_mincap_su_pounds, updated_maxcap_su_pounds,
                                u_item_mintruckstackcap, u_item_maxtruckstackcap
                            ) VALUES (
                                v_template_id,
                                p_sourcingid,
                                p_condition,
                                p_color,
                                v_template_comp_counter(v_template_id),
                                p_bins(i).items(j).item,
                                p_bins(i).items(j).quantity,
                                p_bins(i).items(j).weight,
                                v_is_split,
                                p_bins(i).items(j).original_id,
                                p_bins(i).items(j).original_qty,
                                p_bins(i).items(j).source,
                                p_bins(i).items(j).dest,
                                p_bins(i).items(j).transmode,
                                p_bins(i).items(j).u_variant_type_desc,
                                p_bins(i).items(j).schedshipdate,
                                p_bins(i).items(j).schedarrivdate,
                                p_bins(i).items(j).sid,
                                p_bins(i).items(j).seqnum,
                                p_bins(i).items(j).u_priority,
                                p_bins(i).items(j).sourcingid_seq,
                                p_bins(i).items(j).recqty,
                                p_bins(i).items(j).ratio,
                                p_bins(i).items(j).wgt,
                                p_bins(i).items(j).u_sourcingmin,
                                p_bins(i).items(j).color_seqn,
                                p_bins(i).items(j).u_dispatchdate,
                                p_bins(i).items(j).sales_units_qty,
                                p_bins(i).items(j).majorshipqty,
                                p_bins(i).items(j).minorshipqty,
                                p_bins(i).items(j).transleadtime,
                                p_bins(i).items(j).arrivcal,
                                p_bins(i).items(j).shipcal,
                                p_bins(i).items(j).u_adjustedmaxcap,
                                p_bins(i).items(j).constrrecshipsw,
                                p_bins(i).items(j).availtoshipdate,
                                p_bins(i).items(j).needshipdate,
                                p_bins(i).items(j).needarrivdate,
                                p_bins(i).items(j).updated_mincap_su_pallets,
                                p_bins(i).items(j).updated_maxcap_su_pallets,
                                p_bins(i).items(j).updated_mincap_su_pounds,
                                p_bins(i).items(j).updated_maxcap_su_pounds,
                                p_bins(i).items(j).u_item_mintruckstackcap,
                                p_bins(i).items(j).u_item_maxtruckstackcap
                            );
                        END IF;
                    END LOOP;
                END;
            END IF;
        END LOOP;
        
        -- Verify component counts match template expectations
        FOR template_rec IN (
            SELECT id, component_count, merged_pallet_id
            FROM BATCHMGR.MERGED_PALLET_TEMPLATES
            WHERE sourcingid = p_sourcingid
              AND condition = p_condition
              AND color = p_color
        ) LOOP
            SELECT COUNT(*) INTO v_count
            FROM BATCHMGR.MERGED_PALLET_COMPONENTS
            WHERE template_id = template_rec.id;
            
            IF template_rec.component_count <> v_count THEN
                -- Update to match reality
                UPDATE BATCHMGR.MERGED_PALLET_TEMPLATES
                SET component_count = v_count
                WHERE id = template_rec.id;
            END IF;
        END LOOP;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END p_vmi_store_merged_pallets;
    
    PROCEDURE p_vmi_load_merged_pallets(
        p_sourcingid IN NUMBER,
        p_condition IN VARCHAR2,
        p_color IN VARCHAR2
    ) IS
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       VARCHAR2(100) := 'US_VMI_STACKABILITY.P_VMI_LOAD_MERGED_PALLETS';
        l_v_prog_status     VARCHAR2(20) := 'FAILURE';
        l_v_frequency       VARCHAR2(20) := 'WEEKLY';
        
        -- For tracking merged demands
        TYPE merged_demand_rec IS RECORD (
            source VARCHAR2(100),
            dest VARCHAR2(100),
            u_variant_type_desc VARCHAR2(100),
            u_stackabilitytype VARCHAR2(20),
            item VARCHAR2(100),
            transmode VARCHAR2(100),
            merged_pallet_id NUMBER,
            quantity FLOAT,
            weight FLOAT,
            schedshipdate DATE,
            schedarrivdate DATE,
            is_merged VARCHAR2(1),
            ratio NUMBER,
            wgt NUMBER,
            sourcingid_seq NUMBER,
            sid NUMBER,
            seqnum NUMBER,
            u_priority NUMBER,
            u_sourcingmin NUMBER,
            is_standalone VARCHAR2(1),
            u_dispatchdate DATE,
            sales_units_qty NUMBER,
            majorshipqty NUMBER,        
            minorshipqty NUMBER,
            transleadtime NUMBER,
            arrivcal VARCHAR2(1000),
            shipcal VARCHAR2(1000),
            u_adjustedmaxcap NUMBER,
            constrrecshipsw NUMBER,
            availtoshipdate DATE,
            needshipdate DATE,
            needarrivdate DATE,
            updated_mincap_su_pallets NUMBER,
            updated_maxcap_su_pallets NUMBER,
            updated_mincap_su_pounds FLOAT,
            updated_maxcap_su_pounds FLOAT,
            u_item_mintruckstackcap NUMBER,
            u_item_maxtruckstackcap NUMBER
        );
        
        TYPE merged_demand_array IS TABLE OF merged_demand_rec INDEX BY BINARY_INTEGER;
        v_merged_demands merged_demand_array;
        v_merged_count NUMBER := 0;
    BEGIN
        l_d_start_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
        
        l_v_errstep := 'Load merged pallets into demands';
        
        -- Load merged pallets (ALL templates are now physical bins)
        FOR template_rec IN (
            SELECT DISTINCT
                t.id AS template_id,
                t.sourcingid,
                t.condition,
                t.color,
                t.merged_pallet_id,
                t.total_quantity,
                t.total_weight,
                t.is_standalone,
                t.primary_item,
                -- Get details from first component
                c.source,
                c.dest,
                c.transmode,
                c.u_variant_type_desc,
                c.schedshipdate,
                c.schedarrivdate,
                c.sourcingid_seq,
                c.sid,
                c.seqnum,
                c.u_priority,
                c.ratio,
                c.wgt,
                c.u_sourcingmin,
                c.COLOR_SEQN as color_priority_sourcingid_seq,
                c.u_dispatchdate,
                c.sales_units_qty,
                c.majorshipqty,
                c.minorshipqty,
                c.transleadtime,
                c.arrivcal,
                c.shipcal,
                c.u_adjustedmaxcap,
                c.constrrecshipsw,
                c.availtoshipdate,
                c.needshipdate,
                c.needarrivdate,
                c.updated_mincap_su_pallets,
                c.updated_maxcap_su_pallets,
                c.updated_mincap_su_pounds,
                c.updated_maxcap_su_pounds,
                c.u_item_mintruckstackcap,
                c.u_item_maxtruckstackcap
            FROM
                BATCHMGR.MERGED_PALLET_TEMPLATES t
                JOIN BATCHMGR.MERGED_PALLET_COMPONENTS c ON t.id = c.template_id
                /*
                JOIN batchmgr.udc_recship cp ON (
                    cp.sourcingid = t.sourcingid AND
                    cp.condition = t.condition AND
                    cp.u_stackabilitytype = t.color AND
                    cp.item = c.item AND
                    cp.u_priority = c.u_priority
                )*/
            WHERE
                t.sourcingid = p_sourcingid
                AND t.condition = p_condition
                AND (p_color IS NULL OR t.color = p_color)
                AND c.component_id = 1  -- Get first component for reference
                --AND cp.partial_pallet_count > 0 AND cp.partial_pallet_count < 1
                -- Note: Removed is_physical_bin check as all are physical now
            ORDER BY
                c.COLOR_SEQN, t.merged_pallet_id
        ) LOOP
            v_merged_count := v_merged_count + 1;
            v_merged_demands(v_merged_count).source := template_rec.source;
            v_merged_demands(v_merged_count).dest := template_rec.dest;
            v_merged_demands(v_merged_count).transmode := template_rec.transmode;
            v_merged_demands(v_merged_count).u_variant_type_desc := template_rec.u_variant_type_desc;
            v_merged_demands(v_merged_count).u_stackabilitytype := template_rec.color;
            v_merged_demands(v_merged_count).item := template_rec.primary_item;
            v_merged_demands(v_merged_count).merged_pallet_id := template_rec.merged_pallet_id;
            v_merged_demands(v_merged_count).quantity := 1; -- Always 1 for truck loading
            v_merged_demands(v_merged_count).weight := template_rec.total_weight;
            v_merged_demands(v_merged_count).schedshipdate := template_rec.schedshipdate;
            v_merged_demands(v_merged_count).schedarrivdate := template_rec.schedarrivdate;
            v_merged_demands(v_merged_count).is_merged := 'Y';
            v_merged_demands(v_merged_count).ratio := template_rec.ratio;
            v_merged_demands(v_merged_count).wgt := template_rec.wgt;
            v_merged_demands(v_merged_count).sourcingid_seq := template_rec.sourcingid_seq;
            v_merged_demands(v_merged_count).sid := template_rec.sid;
            v_merged_demands(v_merged_count).seqnum := template_rec.seqnum;
            v_merged_demands(v_merged_count).u_priority := template_rec.u_priority;
            v_merged_demands(v_merged_count).u_sourcingmin := template_rec.u_sourcingmin;
            v_merged_demands(v_merged_count).is_standalone := template_rec.is_standalone;
            v_merged_demands(v_merged_count).u_dispatchdate := template_rec.u_dispatchdate;
            v_merged_demands(v_merged_count).sales_units_qty := template_rec.sales_units_qty;
            v_merged_demands(v_merged_count).majorshipqty := template_rec.majorshipqty;
            v_merged_demands(v_merged_count).minorshipqty := template_rec.minorshipqty;
            v_merged_demands(v_merged_count).transleadtime := template_rec.transleadtime;
            v_merged_demands(v_merged_count).arrivcal := template_rec.arrivcal;
            v_merged_demands(v_merged_count).shipcal := template_rec.shipcal;
            v_merged_demands(v_merged_count).u_adjustedmaxcap := template_rec.u_adjustedmaxcap;
            v_merged_demands(v_merged_count).constrrecshipsw := template_rec.constrrecshipsw;
            v_merged_demands(v_merged_count).availtoshipdate := template_rec.availtoshipdate;
            v_merged_demands(v_merged_count).needshipdate := template_rec.needshipdate;
            v_merged_demands(v_merged_count).needarrivdate := template_rec.needarrivdate;
            v_merged_demands(v_merged_count).updated_mincap_su_pallets := template_rec.updated_mincap_su_pallets;
            v_merged_demands(v_merged_count).updated_maxcap_su_pallets := template_rec.updated_maxcap_su_pallets;
            v_merged_demands(v_merged_count).updated_mincap_su_pounds := template_rec.updated_mincap_su_pounds;
            v_merged_demands(v_merged_count).updated_maxcap_su_pounds := template_rec.updated_maxcap_su_pounds;
            v_merged_demands(v_merged_count).u_item_mintruckstackcap := template_rec.u_item_mintruckstackcap;
            v_merged_demands(v_merged_count).u_item_maxtruckstackcap := template_rec.u_item_maxtruckstackcap;
        END LOOP;
        
        -- Now add all the merged pallets to the demands collection
        FOR i IN 1..v_merged_count LOOP
            DECLARE
                v_added BOOLEAN := FALSE;
                v_next_idx NUMBER := demands.COUNT + 1;
            BEGIN
                -- First check for empty slots
                FOR j IN 1..demands.COUNT LOOP
                    IF demands.EXISTS(j) AND demands(j).quantity = 0 THEN
                        -- Reuse this slot for the merged pallet
                        demands(j).source := v_merged_demands(i).source;
                        demands(j).dest := v_merged_demands(i).dest;
                        demands(j).u_variant_type_desc := v_merged_demands(i).u_variant_type_desc;
                        demands(j).color := v_merged_demands(i).u_stackabilitytype;
                        demands(j).item := v_merged_demands(i).item;
                        demands(j).quantity := v_merged_demands(i).quantity;
                        demands(j).actual_weight_per_pallet := v_merged_demands(i).weight;
                        demands(j).schedshipdate := v_merged_demands(i).schedshipdate;
                        demands(j).schedarrivdate := v_merged_demands(i).schedarrivdate;
                        demands(j).ratio := v_merged_demands(i).ratio;
                        demands(j).wgt := v_merged_demands(i).wgt;
                        demands(j).sourcingid_seq := v_merged_demands(i).sourcingid_seq;
                        demands(j).sid := v_merged_demands(i).sid;
                        demands(j).seqnum := v_merged_demands(i).seqnum;
                        demands(j).u_priority := v_merged_demands(i).u_priority;
                        demands(j).u_sourcingmin := v_merged_demands(i).u_sourcingmin;
                        demands(j).u_dispatchdate := v_merged_demands(i).u_dispatchdate;
                        demands(j).sales_units_qty := v_merged_demands(i).sales_units_qty;
                        demands(j).majorshipqty := v_merged_demands(i).majorshipqty;
                        demands(j).minorshipqty := v_merged_demands(i).minorshipqty;
                        demands(j).transleadtime := v_merged_demands(i).transleadtime;
                        demands(j).arrivcal := v_merged_demands(i).arrivcal;
                        demands(j).shipcal := v_merged_demands(i).shipcal;
                        demands(j).u_adjustedmaxcap := v_merged_demands(i).u_adjustedmaxcap;
                        demands(j).constrrecshipsw := v_merged_demands(i).constrrecshipsw;
                        demands(j).availtoshipdate := v_merged_demands(i).availtoshipdate;
                        demands(j).needshipdate := v_merged_demands(i).needshipdate;
                        demands(j).needarrivdate := v_merged_demands(i).needarrivdate;
                        demands(j).updated_mincap_su_pallets := v_merged_demands(i).updated_mincap_su_pallets;
                        demands(j).updated_maxcap_su_pallets := v_merged_demands(i).updated_maxcap_su_pallets;
                        demands(j).updated_mincap_su_pounds := v_merged_demands(i).updated_mincap_su_pounds;
                        demands(j).updated_maxcap_su_pounds := v_merged_demands(i).updated_maxcap_su_pounds;
                        demands(j).u_item_mintruckstackcap := v_merged_demands(i).u_item_mintruckstackcap;
                        demands(j).u_item_maxtruckstackcap := v_merged_demands(i).u_item_maxtruckstackcap;
                        
                        -- Set flags for merged pallet tracking
                        demands(j).is_merged := 'Y';
                        demands(j).merged_pallet_id := v_merged_demands(i).merged_pallet_id;
                        demands(j).pallet_type := CASE 
                            WHEN v_merged_demands(i).is_standalone = 'Y' THEN 'STANDALONE' 
                            ELSE 'MERGED' 
                        END;
                        
                        v_added := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
                
                -- If no empty slot found, add at the end
                IF NOT v_added THEN
                    demands(v_next_idx).source := v_merged_demands(i).source;
                    demands(v_next_idx).dest := v_merged_demands(i).dest;
                    demands(v_next_idx).u_variant_type_desc := v_merged_demands(i).u_variant_type_desc;
                    demands(v_next_idx).color := v_merged_demands(i).u_stackabilitytype;
                    demands(v_next_idx).item := v_merged_demands(i).item;
                    demands(v_next_idx).quantity := v_merged_demands(i).quantity;
                    demands(v_next_idx).actual_weight_per_pallet := v_merged_demands(i).weight;
                    demands(v_next_idx).schedshipdate := v_merged_demands(i).schedshipdate;
                    demands(v_next_idx).schedarrivdate := v_merged_demands(i).schedarrivdate;
                    demands(v_next_idx).ratio := v_merged_demands(i).ratio;
                    demands(v_next_idx).wgt := v_merged_demands(i).wgt;
                    demands(v_next_idx).sourcingid_seq := v_merged_demands(i).sourcingid_seq;
                    demands(v_next_idx).sid := v_merged_demands(i).sid;
                    demands(v_next_idx).seqnum := v_merged_demands(i).seqnum;
                    demands(v_next_idx).u_priority := v_merged_demands(i).u_priority;
                    demands(v_next_idx).u_sourcingmin := v_merged_demands(i).u_sourcingmin;
                    
                    -- Add all new columns for new slot
                    demands(v_next_idx).u_dispatchdate := v_merged_demands(i).u_dispatchdate;
                    demands(v_next_idx).sales_units_qty := v_merged_demands(i).sales_units_qty;
                    demands(v_next_idx).majorshipqty := v_merged_demands(i).majorshipqty;
                    demands(v_next_idx).minorshipqty := v_merged_demands(i).minorshipqty;
                    demands(v_next_idx).transleadtime := v_merged_demands(i).transleadtime;
                    demands(v_next_idx).arrivcal := v_merged_demands(i).arrivcal;
                    demands(v_next_idx).shipcal := v_merged_demands(i).shipcal;
                    demands(v_next_idx).u_adjustedmaxcap := v_merged_demands(i).u_adjustedmaxcap;
                    demands(v_next_idx).constrrecshipsw := v_merged_demands(i).constrrecshipsw;
                    demands(v_next_idx).availtoshipdate := v_merged_demands(i).availtoshipdate;
                    demands(v_next_idx).needshipdate := v_merged_demands(i).needshipdate;
                    demands(v_next_idx).needarrivdate := v_merged_demands(i).needarrivdate;
                    demands(v_next_idx).updated_mincap_su_pallets := v_merged_demands(i).updated_mincap_su_pallets;
                    demands(v_next_idx).updated_maxcap_su_pallets := v_merged_demands(i).updated_maxcap_su_pallets;
                    demands(v_next_idx).updated_mincap_su_pounds := v_merged_demands(i).updated_mincap_su_pounds;
                    demands(v_next_idx).updated_maxcap_su_pounds := v_merged_demands(i).updated_maxcap_su_pounds;
                    demands(v_next_idx).u_item_mintruckstackcap := v_merged_demands(i).u_item_mintruckstackcap;
                    demands(v_next_idx).u_item_maxtruckstackcap := v_merged_demands(i).u_item_maxtruckstackcap;
                    
                    -- Set merged pallet flags
                    demands(v_next_idx).is_merged := 'Y';
                    demands(v_next_idx).merged_pallet_id := v_merged_demands(i).merged_pallet_id;
                    demands(v_next_idx).pallet_type := CASE 
                        WHEN v_merged_demands(i).is_standalone = 'Y' THEN 'STANDALONE' 
                        ELSE 'MERGED' 
                    END;
                END IF;
            END;
        END LOOP;
        
        l_v_prog_status := 'SUCCESS';
        l_d_end_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time,
            l_d_enddatetime_in => l_d_end_date_time,
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
        
    EXCEPTION
        WHEN OTHERS THEN
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                l_d_datetime_in => SYSDATE,
                l_v_errorid_in => SQLCODE, 
                l_v_errormessage_in => SQLERRM, 
                l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, 
                l_v_frequency_in => l_v_frequency);
            
            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, 
                l_d_enddatetime_in => l_d_end_date_time,
                l_v_progstatus_in => l_v_prog_status, 
                l_v_frequency_in => l_v_frequency);
            
            RAISE;
    END p_vmi_load_merged_pallets;
    
    PROCEDURE p_vmi_create_positioned_pallet(
        p_sourcingid IN NUMBER,
        p_condition IN VARCHAR2,
        p_color IN VARCHAR2,
        p_merged_pallet_id IN NUMBER,
        p_loadid IN NUMBER,
        p_load_sequence IN NUMBER,
        p_stack_position IN VARCHAR2,
        p_position_id OUT NUMBER,
        p_is_standalone IN VARCHAR2 DEFAULT NULL  -- Make parameter optional
    ) IS
        v_template_id NUMBER;
        v_original_id NUMBER;
        v_is_standalone VARCHAR2(1) := 'N';  -- Default value
        v_log_prefix VARCHAR2(100) := 'p_vmi_create_positioned_pallet: ';
        v_found BOOLEAN := FALSE;
    BEGIN
        -- First, check if this is a positioned ID (1001, 1002, etc.)
        -- and calculate the potential original ID
        IF p_merged_pallet_id >= 1000 THEN
            v_original_id := MOD(p_merged_pallet_id, 1000);
            -- If MOD returns 0, use 1 as default
            IF v_original_id = 0 THEN
                v_original_id := 1;
            END IF;
        ELSE
            v_original_id := p_merged_pallet_id;
        END IF;
        
        -- Try to find template first with exact ID match
        BEGIN
            -- Get the is_standalone value from the template
            SELECT id, NVL(is_standalone, 'N') INTO v_template_id, v_is_standalone
            FROM BATCHMGR.MERGED_PALLET_TEMPLATES
            WHERE sourcingid = p_sourcingid
              AND condition = p_condition
              AND color = p_color
              AND merged_pallet_id = p_merged_pallet_id;
              
            v_found := TRUE;
            --DBMS_OUTPUT.PUT_LINE(v_log_prefix || 'Found template with exact ID match: ' || v_template_id || ', is_standalone=' || v_is_standalone);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_found := FALSE;
        END;
        
        -- If not found with exact match, try with original ID
        IF NOT v_found THEN
            BEGIN
                -- Also get is_standalone here
                SELECT id, NVL(is_standalone, 'N') INTO v_template_id, v_is_standalone
                FROM BATCHMGR.MERGED_PALLET_TEMPLATES
                WHERE sourcingid = p_sourcingid
                  AND condition = p_condition
                  AND color = p_color
                  AND merged_pallet_id = v_original_id;
                  
                v_found := TRUE;
                --DBMS_OUTPUT.PUT_LINE(v_log_prefix || 'Found template with original ID: ' || v_template_id || ' (original_id=' || v_original_id || ', is_standalone=' || v_is_standalone || ')');
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    RAISE_APPLICATION_ERROR(-20001, 'Template not found for pallet: ' || 
                                         p_sourcingid || '/' || p_condition || '/' || 
                                         p_color || '/' || p_merged_pallet_id || 
                                         ' or original id ' || v_original_id);
            END;
        END IF;
        
        -- Override with parameter value if provided
        IF p_is_standalone IS NOT NULL THEN
            v_is_standalone := p_is_standalone;
        END IF;
        
        -- Check if positioned instance already exists
        BEGIN
            SELECT id INTO p_position_id
            FROM BATCHMGR.MERGED_PALLET_POSITIONS
            WHERE sourcingid = p_sourcingid
              AND condition = p_condition
              AND color = p_color
              AND loadid = p_loadid
              AND load_sequence = p_load_sequence
              AND stack_position = p_stack_position;
              
            -- Already exists, update it in case template changed
            UPDATE BATCHMGR.MERGED_PALLET_POSITIONS
            SET template_id = v_template_id,
                merged_pallet_id = p_merged_pallet_id,
                original_merged_id = v_original_id,  -- Store the original ID for reference
                is_standalone = v_is_standalone  -- Use the resolved value
            WHERE id = p_position_id;
            
            --DBMS_OUTPUT.PUT_LINE(v_log_prefix || 'Updated existing position ' || p_position_id || ' for pallet ' || p_merged_pallet_id || ' (original_id=' || v_original_id || ', is_standalone=' || v_is_standalone ||') in truck ' || p_loadid || ', pos ' || p_load_sequence || ', ' || p_stack_position);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- Create new positioned instance
                INSERT INTO BATCHMGR.MERGED_PALLET_POSITIONS (
                    template_id, sourcingid, condition, color, merged_pallet_id,
                    loadid, load_sequence, stack_position, original_merged_id, is_standalone
                ) VALUES (
                    v_template_id, p_sourcingid, p_condition, p_color, p_merged_pallet_id,
                    p_loadid, p_load_sequence, p_stack_position, v_original_id, v_is_standalone
                ) RETURNING id INTO p_position_id;
                
                --DBMS_OUTPUT.PUT_LINE(v_log_prefix || 'Created new position ' || p_position_id || ' for pallet ' || p_merged_pallet_id || ' (original_id=' || v_original_id || ', is_standalone=' || v_is_standalone ||') in truck ' || p_loadid || ', pos ' || p_load_sequence || ', ' || p_stack_position);
        END;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE(v_log_prefix || 'Error: ' || SQLERRM);
            RAISE;
    END p_vmi_create_positioned_pallet;
    
    PROCEDURE p_vmi_insert_visualization_results (
        p_sourcingid   NUMBER,
        p_truck_number NUMBER,
        p_condition    VARCHAR2,
        p_bottom_row   sys.odcivarchar2list,
        p_top_row      sys.odcivarchar2list,
        p_bottom_info  pallet_info_list,
        p_top_info     pallet_info_list
    ) IS 
    /******************************************************************
      Procedure : P_VMI_INSERT_VISUALIZATION_RESULTS
      Description : Enhanced to track merged pallet information
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; 
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INSERT_VISUALIZATION_RESULTS';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := SYSTIMESTAMP;

        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate Table SCPOMGR.P_VMI_INSERT_VISUALIZATION_RESULTS';

        -- Insert bottom row data
        FOR i IN 1..p_bottom_row.count LOOP
            IF p_bottom_row(i) != 'EMPTY' THEN
                INSERT INTO batchmgr.temp_visualization_results(
                    SOURCE, DEST, TRANSMODE, U_VARIANT_TYPE_DESC, 
                    SOURCINGID, LOADID, CONDITION, STACK_POSITION, LOAD_SEQUENCE, 
                    U_STACKABILITYTYPE, ITEM, PALLETS_QTY, WEIGHT, 
                    SCHEDSHIPDATE, SOURCINGID_SEQ, U_PRIORITY, SID, SEQNUM, U_SOURCINGMIN,
                    -- Add merged pallet tracking fields
                    IS_MERGED, PALLET_TYPE, MERGED_PALLET_ID, IS_STANDALONE, POSITION_ID, ORIGINAL_MERGED_ID,
                    ACTUAL_QUANTITY
                )
                VALUES (
                    p_bottom_info(i).source,
                    p_bottom_info(i).dest,
                    p_bottom_info(i).transmode,
                    p_bottom_info(i).u_variant_type_desc,
                    p_sourcingid,
                    p_truck_number,
                    p_condition,
                    'bottom',
                    i,
                    p_bottom_info(i).u_stackabilitytype,
                    p_bottom_info(i).item,
                    p_bottom_info(i).pallets_qty,
                    p_bottom_info(i).actual_loaded_weight,
                    p_bottom_info(i).schedshipdate,
                    p_bottom_info(i).sourcingid_seq,
                    p_bottom_info(i).u_priority,
                    p_bottom_info(i).sid,
                    p_bottom_info(i).seqnum,
                    p_bottom_info(i).u_sourcingmin,
                    -- Track merged pallet information 
                    NVL(p_bottom_info(i).is_merged, 'N'),
                    --NVL(p_bottom_info(i).pallet_type, 'FULL'),
                    CASE 
                        WHEN p_bottom_info(i).is_merged = 'Y' THEN 
                            CASE WHEN p_bottom_info(i).is_standalone = 'Y' THEN 'STANDALONE' 
                            ELSE 'MERGED' 
                            END
                        ELSE 'FULL'
                    END,
                    p_bottom_info(i).merged_pallet_id,
                    NVL(p_bottom_info(i).is_standalone, 'N'),
                    p_bottom_info(i).position_id,
                    p_bottom_info(i).original_merged_id,
                    p_bottom_info(i).actual_quantity
                );
            END IF;
        END LOOP;

        -- Insert top row data
        FOR i IN 1..p_top_row.count LOOP
            IF p_top_row(i) NOT IN ('EMPTY', 'unavailable') THEN
                INSERT INTO batchmgr.temp_visualization_results(
                    SOURCE, DEST, TRANSMODE, U_VARIANT_TYPE_DESC, 
                    SOURCINGID, LOADID, CONDITION, STACK_POSITION, LOAD_SEQUENCE, 
                    U_STACKABILITYTYPE, ITEM, PALLETS_QTY, WEIGHT, 
                    SCHEDSHIPDATE, SOURCINGID_SEQ, U_PRIORITY, SID, SEQNUM, U_SOURCINGMIN,
                    -- Add merged pallet tracking fields
                    IS_MERGED, PALLET_TYPE, MERGED_PALLET_ID, IS_STANDALONE, POSITION_ID, ORIGINAL_MERGED_ID,
                    ACTUAL_QUANTITY
                )
                VALUES (
                    p_top_info(i).source,
                    p_top_info(i).dest,
                    p_top_info(i).transmode,
                    p_top_info(i).u_variant_type_desc,
                    p_sourcingid,
                    p_truck_number,
                    p_condition,
                    'top',
                    i,
                    p_top_info(i).u_stackabilitytype,
                    p_top_info(i).item,
                    p_top_info(i).pallets_qty,
                    p_top_info(i).actual_loaded_weight,
                    p_top_info(i).schedshipdate,
                    p_top_info(i).sourcingid_seq,
                    p_top_info(i).u_priority,
                    p_top_info(i).sid,
                    p_top_info(i).seqnum,
                    p_top_info(i).u_sourcingmin,
                    -- Track merged pallet information 
                    NVL(p_top_info(i).is_merged, 'N'),
                    --NVL(p_top_info(i).pallet_type, 'FULL'),
                    CASE 
                        WHEN p_top_info(i).is_merged = 'Y' THEN 
                            CASE WHEN p_bottom_info(i).is_standalone = 'Y' THEN 'STANDALONE' 
                            ELSE 'MERGED' 
                            END
                        ELSE 'FULL'
                    END,
                    p_top_info(i).merged_pallet_id,
                    NVL(p_top_info(i).is_standalone, 'N'),
                    p_top_info(i).position_id,
                    p_top_info(i).original_merged_id,
                    p_top_info(i).actual_quantity
                );
            END IF;
        END LOOP;

        l_d_end_date_time := SYSTIMESTAMP;
        l_v_prog_status := 'SUCCESS';

        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time,
            l_d_enddatetime_in => l_d_end_date_time,
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => SYSDATE,
                l_v_errorid_in => SQLCODE, l_v_errormessage_in => SQLERRM, l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

            -- Interface Time logging
            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time,
                l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_insert_visualization_results;

    PROCEDURE p_vmi_transfer_to_urecship IS 
        -- Standard variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_TRANSFER_TO_URECSHIP';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- Track processing
        v_total_rows        NUMBER := 0;
        v_merged_rows       NUMBER := 0;
        v_regular_rows      NUMBER := 0;
        v_template_id       NUMBER;
        v_utilization       NUMBER;
        v_position_id       NUMBER;
        v_merged_pallet_id  NUMBER;
    BEGIN
        -- Initialize interface
        l_d_start_date_time := systimestamp;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
    
        l_v_errstep := 'Transferring temp_visualization_results to u_recship';
        
        -- Process each pallet position from visualization results
        FOR vr_rec IN (
            SELECT 
                t.sourcingid,
                t.source,
                t.dest,
                t.u_variant_type_desc,
                t.u_priority,
                t.loadid,
                t.load_sequence,
                t.condition,
                t.stack_position,
                t.u_stackabilitytype,
                t.item,
                t.weight,
                t.schedshipdate,
                t.sourcingid_seq,
                t.sid,
                t.seqnum,
                t.pallets_qty,
                t.u_sourcingmin,
                t.transmode,
                
                -- Add merged pallet tracking fields with explicit aliases
                CASE WHEN pos.template_id IS NOT NULL THEN 'Y' ELSE 'N' END AS is_merged_flag,
                pos.template_id AS merged_template_id,
                pos.merged_pallet_id AS merged_pallet_id_val,
                pos.original_merged_id AS original_merged_id_val,
                pos.is_standalone AS is_standalone_flag,
                pos.id AS position_id_val
                
            FROM 
                batchmgr.temp_visualization_results t
                LEFT JOIN batchmgr.merged_pallet_positions pos ON (
                    t.sourcingid = pos.sourcingid
                    AND t.condition = pos.condition
                    AND t.u_stackabilitytype = pos.color
                    AND t.loadid = pos.loadid
                    AND t.load_sequence = pos.load_sequence
                    AND t.stack_position = pos.stack_position
                )
            ORDER BY
                t.sourcingid,
                t.loadid,
                t.stack_position,
                t.load_sequence
        ) LOOP
            -- Calculate utilization for this truck
            v_utilization := f_vmi_calculate_truck_utilization(vr_rec.sourcingid, vr_rec.loadid);
            v_utilization := CASE WHEN v_utilization > 100 THEN 100 ELSE v_utilization END;
            
            -- Determine if this is a merged pallet
            IF vr_rec.is_merged_flag = 'Y' THEN
                -- This is a merged pallet - get template ID
                v_template_id := vr_rec.merged_template_id;
                v_merged_pallet_id := vr_rec.merged_pallet_id_val;
                v_position_id := vr_rec.position_id_val;
                
                -- Get components for this template
                FOR comp_rec IN (
                    SELECT 
                        c.*
                    FROM 
                        batchmgr.merged_pallet_components c
                    WHERE 
                        c.template_id = v_template_id
                    ORDER BY
                        c.component_id
                ) LOOP
                    -- Insert each component into u_recship
                    INSERT INTO batchmgr.u_recship (
                        -- Standard fields
                        sourcingid, sourcingid_seq, condition, u_priority, loadid, 
                        load_sequence, loaded, utilization, u_sourcingmin, schedshipdate,
                        schedarrivdate, source, dest, transmode, u_variant_type_desc,
                        item, u_stackabilitytype, stack_position,
                        
                        -- Quantity and weight from component
                        pallets_qty, updated_wgt,
                        
                        -- Additional reference fields from UDC_RECSHIP
                        updated_mincap_su_pallets, updated_maxcap_su_pallets,
                        updated_mincap_su_pounds, updated_maxcap_su_pounds,
                        u_item_mintruckstackcap, u_item_maxtruckstackcap,
                        sid, seqnum, u_dispatchdate, ratio,
                        recqty, sales_units_qty, majorshipqty, minorshipqty,
                        status, transleadtime, arrivcal, shipcal, u_adjustedmaxcap, wgt,
                        constrrecshipsw, availtoshipdate, needshipdate, needarrivdate,
                        
                        -- Merged pallet tracking fields
                        is_merged, is_component, parent_pallet_id, is_split, 
                        original_pallet_id, component_sequence, pallet_type, 
                        actual_quantity, component_id, position_id, is_standalone,
                        merged_flag, contribution_pct
                    )
                    SELECT 
                        vr_rec.sourcingid,
                        comp_rec.sourcingid_seq,
                        vr_rec.condition,
                        comp_rec.u_priority,
                        vr_rec.loadid,
                        vr_rec.load_sequence,
                        'Y' AS loaded,
                        ROUND(v_utilization, 2),
                        comp_rec.u_sourcingmin,
                        comp_rec.schedshipdate,
                        comp_rec.schedarrivdate,
                        comp_rec.source,
                        comp_rec.dest,
                        comp_rec.transmode,
                        comp_rec.u_variant_type_desc,
                        comp_rec.item,
                        vr_rec.u_stackabilitytype,
                        vr_rec.stack_position,
                        
                        -- Use original component quantity and weight
                        comp_rec.quantity,
                        comp_rec.weight,
                        
                        -- Get remaining fields from UDC_RECSHIP
                        ud.updated_mincap_su_pallets,
                        ud.updated_maxcap_su_pallets,
                        ud.updated_mincap_su_pounds,
                        ud.updated_maxcap_su_pounds,
                        ud.u_item_mintruckstackcap,
                        ud.u_item_maxtruckstackcap,
                        comp_rec.sid,
                        comp_rec.seqnum,
                        ud.u_dispatchdate,
                        comp_rec.ratio,
                        comp_rec.recqty,
                        ROUND(comp_rec.ratio * comp_rec.recqty, 2),
                        ud.majorshipqty,
                        ud.minorshipqty,
                        'loaded' AS status,
                        ud.transleadtime,
                        ud.arrivcal,
                        ud.shipcal,
                        ud.u_adjustedmaxcap,
                        comp_rec.wgt,
                        ud.constrrecshipsw,
                        ud.availtoshipdate,
                        ud.needshipdate,
                        ud.needarrivdate,
                        
                        -- Set merged pallet tracking fields
                        'Y',                             -- is_merged
                        'Y',                             -- is_component
                        v_merged_pallet_id,              -- parent_pallet_id
                        comp_rec.is_split,               -- is_split
                        comp_rec.original_id,            -- original_pallet_id
                        comp_rec.component_id,           -- component_sequence
                        CASE 
                            WHEN vr_rec.is_standalone_flag = 'Y' THEN 'STANDALONE'
                            ELSE 'MERGED'
                        END,                             -- pallet_type
                        comp_rec.quantity,               -- actual_quantity
                        comp_rec.component_id,           -- component_id
                        v_position_id,                   -- position_id
                        vr_rec.is_standalone_flag,       -- is_standalone
                        'Y',                             -- merged_flag
                        ROUND(comp_rec.quantity * 100, 2) -- contribution_pct (as percentage)
                    FROM 
                        batchmgr.udc_recship ud
                    WHERE 
                        ud.sourcingid = vr_rec.sourcingid
                        AND ud.source = comp_rec.source
                        AND ud.dest = comp_rec.dest
                        AND substr(ud.u_variant_type_desc,1,2) = substr(comp_rec.u_variant_type_desc,1,2)
                        AND ud.u_priority = comp_rec.u_priority
                        AND ud.condition = vr_rec.condition
                        AND ud.u_stackabilitytype = vr_rec.u_stackabilitytype
                        AND ud.item = comp_rec.item
                        AND ud.schedshipdate = comp_rec.schedshipdate
                        AND ud.sourcingid_seq = comp_rec.sourcingid_seq
                        AND ud.sid = comp_rec.sid
                        AND ud.seqnum = comp_rec.seqnum
                        AND ROWNUM = 1;  -- Just need one matching record
                    
                    v_merged_rows := v_merged_rows + 1;
                    v_total_rows := v_total_rows + 1;
                    COMMIT;
                END LOOP;
            ELSE
                -- Regular pallet - process as before
                INSERT INTO batchmgr.u_recship (
                    sourcingid, sourcingid_seq, condition, u_priority, loadid, 
                    load_sequence, loaded, utilization, u_sourcingmin, schedshipdate,
                    schedarrivdate, source, dest, transmode, u_variant_type_desc,
                    item, u_stackabilitytype, pallets_qty, updated_wgt, 
                    updated_mincap_su_pallets, updated_maxcap_su_pallets,
                    updated_mincap_su_pounds, updated_maxcap_su_pounds,
                    u_item_mintruckstackcap, u_item_maxtruckstackcap,
                    sid, seqnum, stack_position, u_dispatchdate, ratio,
                    recqty, sales_units_qty, majorshipqty, minorshipqty,
                    status, transleadtime, arrivcal, shipcal, u_adjustedmaxcap, wgt,
                    constrrecshipsw, availtoshipdate, needshipdate, needarrivdate,
                    is_merged, pallet_type
                )
                SELECT 
                    vr_rec.sourcingid,
                    vr_rec.sourcingid_seq,
                    vr_rec.condition,
                    vr_rec.u_priority,
                    vr_rec.loadid,
                    vr_rec.load_sequence,
                    'Y' AS loaded,
                    ROUND(v_utilization, 2),
                    vr_rec.u_sourcingmin,
                    vr_rec.schedshipdate,
                    b.schedarrivdate,
                    vr_rec.source,
                    vr_rec.dest,
                    vr_rec.transmode,
                    vr_rec.u_variant_type_desc,
                    vr_rec.item,
                    vr_rec.u_stackabilitytype,
                    vr_rec.pallets_qty,
                    vr_rec.weight AS updated_wgt,
                    b.updated_mincap_su_pallets,
                    b.updated_maxcap_su_pallets,
                    b.updated_mincap_su_pounds,
                    b.updated_maxcap_su_pounds,
                    b.u_item_mintruckstackcap,
                    b.u_item_maxtruckstackcap,
                    vr_rec.sid,
                    vr_rec.seqnum,
                    vr_rec.stack_position,
                    b.u_dispatchdate,
                    b.ratio,
                    b.recqty,
                    b.sales_units_qty,
                    b.majorshipqty,
                    b.minorshipqty,
                    'loaded' AS status,
                    b.transleadtime,
                    b.arrivcal,
                    b.shipcal,
                    b.u_adjustedmaxcap,
                    b.wgt,
                    b.constrrecshipsw, 
                    b.availtoshipdate,
                    b.needshipdate,
                    b.needarrivdate,
                    'N',             -- is_merged
                    'FULL'           -- pallet_type
                FROM 
                    batchmgr.udc_recship b
                WHERE 
                    b.sourcingid = vr_rec.sourcingid
                    AND b.source = vr_rec.source
                    AND b.dest = vr_rec.dest
                    AND substr(b.u_variant_type_desc,1,2) = substr(vr_rec.u_variant_type_desc,1,2)
                    AND b.u_priority = vr_rec.u_priority
                    AND b.condition = vr_rec.condition
                    AND b.u_stackabilitytype = vr_rec.u_stackabilitytype
                    AND b.item = vr_rec.item
                    AND b.schedshipdate = vr_rec.schedshipdate
                    AND b.sourcingid_seq = vr_rec.sourcingid_seq
                    AND b.sid = vr_rec.sid
                    AND b.seqnum = vr_rec.seqnum
                    AND ROWNUM = 1;
                    
                v_regular_rows := v_regular_rows + 1;
                v_total_rows := v_total_rows + 1;
                COMMIT;
            END IF;
        END LOOP;
    
        COMMIT;
        
        /*
        -- Log statistics
        dbms_output.put_line('Total rows processed: ' || v_total_rows); 
        dbms_output.put_line('  - Regular pallets: ' || v_regular_rows);
        dbms_output.put_line('  - Merged components: ' || v_merged_rows);
        */
        
        -- Interface Execution Time logging
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, 
            l_d_enddatetime_in => l_d_end_date_time, 
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
    
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                l_d_datetime_in => sysdate, 
                l_v_errorid_in => sqlcode, 
                l_v_errormessage_in => sqlerrm, 
                l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, 
                l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                l_d_startdatetime_in => l_d_start_date_time, 
                l_d_enddatetime_in => l_d_end_date_time, 
                l_v_progstatus_in => l_v_prog_status,
                l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_transfer_to_urecship;

    PROCEDURE p_vmi_optimize_load IS
        l_d_start_date_time          iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time            iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep                  iio_error_log.error_step%TYPE;
        l_n_id                       iio_interface_timing_log.id%TYPE;

        l_v_prog_name                scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_optimize_load';
        l_v_prog_status              scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency                scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';

        sourcingid_var               NUMBER;
        truck_number                 NUMBER := 1;
        max_pallets                  NUMBER;
        updated_maxcap_su_pallets    NUMBER;
        updated_maxcap_su_pounds     FLOAT;
        u_sourcingmin                NUMBER;
        ventilation                  FLOAT;
        last_truck_modified          BOOLEAN := false;
        current_demand_index         NUMBER := 1;
        max_bottom_row               NUMBER;
        v_min_pallets                NUMBER;
        v_min_pounds                 NUMBER;
        truck_weight                 NUMBER := 0;
        color                        VARCHAR2(4000);
        current_top_color            VARCHAR2(4000);
        v_tolerance                  FLOAT := 0.0001;

        CURSOR c_sourcingid IS
           SELECT DISTINCT
               sourcingid,
               MAX(updated_maxcap_su_pallets)          AS maxcap,
               round(MIN(updated_mincap_su_pallets))   AS min_pallets,
               round(MIN(updated_mincap_su_pounds), 2) AS min_pounds,
               MAX(updated_maxcap_su_pallets)          AS max_pallets,
               MAX(updated_maxcap_su_pounds)           AS max_pounds,
               MAX(u_sourcingmin)                      AS u_sourcingmin,
               MAX(u_adjustedmaxcap)                   AS u_adjustedmaxcap
           FROM batchmgr.udc_recship
           WHERE condition IN ('FIRST', 'SECOND')
             AND u_priority = 1
           GROUP BY sourcingid
           ORDER BY sourcingid;

    BEGIN
        l_d_start_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');

        BEGIN
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.u_recship';
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.u_recship_mincap';
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.temp_visualization_results';
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.merged_pallet_positions';  -- This references templates
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.merged_pallet_components'; -- This references templates
            EXECUTE IMMEDIATE 'TRUNCATE TABLE batchmgr.merged_pallet_templates';  -- This is referenced by the above
            COMMIT; -- Commit truncates
        END;

        -- Initialize stackability_map 
        stackability_map('RED') := '';
        stackability_map('BLACK') := 'YELLOW,GREEN,DS';
        stackability_map('GREEN') := 'YELLOW,DS,GREEN';
        stackability_map('YELLOW') := '';
        stackability_map('SS') := '';
        stackability_map('DS') := 'DS,GREEN'; 
        
        -- Set up color priority (lower number = higher priority)
        v_color_priority('RED') := 1;
        v_color_priority('SS') := 2;
        v_color_priority('BLACK') := 3;
        v_color_priority('GREEN') := 4; 
        v_color_priority('DS') := 5;
        v_color_priority('YELLOW') := 6;

        FOR src IN c_sourcingid LOOP
            sourcingid_var := src.sourcingid;
            max_pallets := src.maxcap;
            updated_maxcap_su_pallets := src.max_pallets;
            updated_maxcap_su_pounds := src.max_pounds;
            v_min_pallets := src.min_pallets;
            v_min_pounds := src.min_pounds;
            max_bottom_row := floor(max_pallets / 2);
            u_sourcingmin := src.u_sourcingmin;
            ventilation := src.max_pallets - src.u_adjustedmaxcap;
            
            -- Check if there are any FIRST condition pallets for this sourcingid
            DECLARE
                v_first_count NUMBER;
            BEGIN
                SELECT COUNT(*) INTO v_first_count
                FROM batchmgr.udc_recship
                WHERE sourcingid = sourcingid_var
                  AND condition = 'FIRST'
                  AND u_priority = 1;
                  
                IF v_first_count = 0 THEN
                    -- No FIRST condition pallets, skip to next sourcingid
                    CONTINUE;
                END IF;
            END;
            
            -- Pre-process and merge partial pallets for FIRST condition
            l_v_errstep := 'Preprocessing - Merge Partial Pallets for SourcingID: ' || sourcingid_var;
            
            -- Process each color with merging
            FOR color_rec IN (
                SELECT DISTINCT u_stackabilitytype AS color, color_priority_sourcingid_seq
                FROM batchmgr.udc_recship 
                WHERE sourcingid = sourcingid_var
                  AND condition = 'FIRST'
                  AND u_priority = 1
                  AND partial_pallet_count > 0 AND partial_pallet_count < 1
                ORDER BY color_priority_sourcingid_seq
            ) LOOP
                -- Merge partials for this color
                p_vmi_merge_partial_pallets(
                    p_sourcingid => sourcingid_var,
                    p_color => color_rec.color,
                    p_condition => 'FIRST',
                    p_u_priority => 1,
                    p_tolerance => v_tolerance
                );
            END LOOP;
    
            -- Fetch item capacity constraints
            item_constraints.DELETE;
            FOR constraint_rec IN (
                SELECT
                    u_stackabilitytype,
                    MIN(u_item_mintruckstackcap) AS min_capacity,
                    MAX(u_item_maxtruckstackcap) AS max_capacity
                FROM batchmgr.udc_recship
                WHERE sourcingid = sourcingid_var
                  AND condition IN ('FIRST','SECOND')
                  AND u_priority = 1
                GROUP BY u_stackabilitytype
            ) LOOP
                item_constraints(item_constraints.count + 1).u_stackabilitytype := constraint_rec.u_stackabilitytype;
                item_constraints(item_constraints.count).min_capacity := constraint_rec.min_capacity;
                item_constraints(item_constraints.count).max_capacity := constraint_rec.max_capacity;
            END LOOP;
    
            p_vmi_calculate_src_wgts(sourcingid_var);
    
            ------------------------------- FIRST Condition Pallets -------------------------------
            
            -- Clear demands collection
            demands.DELETE;
            all_trucks.DELETE;
            current_demand_index := 1;
            
            -- STEP 1: Load full pallets
            FOR rec IN (
                SELECT
                    id,  -- Include id for reference
                    source,
                    dest,
                    transmode,
                    u_variant_type_desc,
                    u_stackabilitytype AS color,
                    item,
                    full_pallet_count AS quantity,  -- Only consider full pallets here
                    full_pallet_wgt,
                    sourcingid_seq,
                    schedshipdate,
                    schedarrivdate,
                    sid,
                    seqnum,
                    u_priority,
                    ratio,
                    wgt,
                    u_sourcingmin,
                    color_priority_sourcingid_seq
                FROM batchmgr.udc_recship
                WHERE sourcingid = sourcingid_var
                  AND condition = 'FIRST'
                  AND u_priority = 1
                  AND full_pallet_count >= 1  -- Only full pallets
                  
                ORDER BY color_priority_sourcingid_seq, seqnum
            ) LOOP
                FOR i IN 1..rec.quantity LOOP
                    -- For each full pallet, create separate demand entries to ensure uniqueness
                    demands(current_demand_index).source := rec.source;
                    demands(current_demand_index).dest := rec.dest;
                    demands(current_demand_index).transmode := rec.transmode;
                    demands(current_demand_index).u_variant_type_desc := rec.u_variant_type_desc;
                    demands(current_demand_index).color := rec.color;
                    demands(current_demand_index).item := rec.item;
                    demands(current_demand_index).quantity := 1; -- Each entry represents exactly one full pallet
                    demands(current_demand_index).sourcingid_seq := rec.sourcingid_seq;
                    demands(current_demand_index).schedshipdate := rec.schedshipdate;
                    demands(current_demand_index).schedarrivdate := rec.schedarrivdate;
                    demands(current_demand_index).sid := rec.sid;
                    demands(current_demand_index).seqnum := rec.seqnum;
                    demands(current_demand_index).u_priority := rec.u_priority;
                    demands(current_demand_index).ratio := rec.ratio;
                    demands(current_demand_index).wgt := rec.wgt;
                    demands(current_demand_index).u_sourcingmin := rec.u_sourcingmin;
                    demands(current_demand_index).actual_weight_per_pallet := rec.full_pallet_wgt / rec.quantity;
                    
                    -- Set fields for pallet tracking
                    demands(current_demand_index).pallet_type := 'FULL';
                    demands(current_demand_index).is_merged := 'N';
                    demands(current_demand_index).merged_pallet_id := NULL;
                    demands(current_demand_index).position_id := NULL;
                    demands(current_demand_index).original_merged_id := NULL;
                    
                    current_demand_index := current_demand_index + 1;
                END LOOP;
            END LOOP;
            
            -- STEP 2: Load merged pallets (both merged and standalone)
            FOR template_rec IN (
                SELECT DISTINCT
                    t.id AS template_id,
                    t.sourcingid,
                    t.condition,
                    t.color,
                    t.merged_pallet_id,
                    t.total_quantity,
                    t.total_weight,
                    t.is_standalone,
                    t.primary_item,
                    -- Join with components to get the primary component details
                    c.source,
                    c.dest,
                    c.transmode,
                    c.u_variant_type_desc,
                    c.schedshipdate,
                    c.schedarrivdate,
                    c.sourcingid_seq,
                    c.sid,
                    c.seqnum,
                    c.u_priority,
                    c.ratio,
                    c.wgt,
                    c.u_sourcingmin,
                    cp.color_priority_sourcingid_seq
                FROM
                    BATCHMGR.MERGED_PALLET_TEMPLATES t
                    JOIN BATCHMGR.MERGED_PALLET_COMPONENTS c ON t.id = c.template_id
                    JOIN batchmgr.udc_recship cp ON (
                        cp.sourcingid = t.sourcingid AND
                        cp.condition = t.condition AND
                        cp.u_stackabilitytype = t.color AND
                        cp.item = c.item AND
                        cp.u_priority = c.u_priority
                    )
                WHERE
                    t.sourcingid = sourcingid_var
                    AND t.condition = 'FIRST'
                    AND c.component_id = 1.  -- Just get the first component for reference
                    AND cp.partial_pallet_count > 0 and cp.partial_pallet_count < 1
                    --AND t.is_physical_bin = 'Y'
                GROUP BY
                    t.id, t.sourcingid, t.condition, t.color, t.merged_pallet_id, 
                    t.total_quantity, t.total_weight, t.is_standalone, t.primary_item,
                    c.source, c.dest, c.transmode, c.u_variant_type_desc, 
                    c.schedshipdate, c.schedarrivdate, c.sourcingid_seq, c.sid, 
                    c.seqnum, c.u_priority, c.ratio, c.wgt, c.u_sourcingmin,
                    cp.color_priority_sourcingid_seq
                ORDER BY
                    cp.color_priority_sourcingid_seq, t.is_standalone DESC, t.merged_pallet_id
            ) LOOP
                demands(current_demand_index).source := template_rec.source;
                demands(current_demand_index).dest := template_rec.dest;
                demands(current_demand_index).transmode := template_rec.transmode;
                demands(current_demand_index).u_variant_type_desc := template_rec.u_variant_type_desc;
                demands(current_demand_index).color := template_rec.color;
                demands(current_demand_index).item := template_rec.primary_item;
                demands(current_demand_index).quantity := 1; -- Always 1 for truck loading purposes
                demands(current_demand_index).sourcingid_seq := template_rec.sourcingid_seq;
                demands(current_demand_index).schedshipdate := template_rec.schedshipdate;
                demands(current_demand_index).schedarrivdate := template_rec.schedarrivdate;
                demands(current_demand_index).sid := template_rec.sid;
                demands(current_demand_index).seqnum := template_rec.seqnum;
                demands(current_demand_index).u_priority := template_rec.u_priority;
                demands(current_demand_index).ratio := template_rec.ratio; -- Keep original ratio for reference
                demands(current_demand_index).wgt := template_rec.wgt; -- Keep original wgt for reference
                demands(current_demand_index).u_sourcingmin := template_rec.u_sourcingmin;
                demands(current_demand_index).actual_weight_per_pallet := template_rec.total_weight;
                demands(current_demand_index).actual_quantity := template_rec.total_quantity;
                
                -- Set fields for merged pallet tracking
                demands(current_demand_index).pallet_type := CASE 
                    WHEN template_rec.is_standalone = 'Y' THEN 'STANDALONE' 
                    ELSE 'MERGED' 
                END;
                demands(current_demand_index).is_merged := 'Y';
                demands(current_demand_index).merged_pallet_id := template_rec.merged_pallet_id;
                demands(current_demand_index).position_id := NULL; -- Will be set when positioned
                demands(current_demand_index).original_merged_id := template_rec.merged_pallet_id;
                
                current_demand_index := current_demand_index + 1;
            END LOOP;
    
            truck_number := 1; 
            last_truck_modified := false;
            
            -- Start color_sort if we have demands to sort based on color_sequence 
            IF demands.COUNT > 1 THEN
                color_sort(1, demands.COUNT);
            END IF;
    
            WHILE f_vmi_has_remaining_demand(demands) LOOP
                truck_load_bottom := sys.odcivarchar2list();
                truck_load_top := sys.odcivarchar2list();
                truck_load_bottom_info.DELETE;
                truck_load_top_info.DELETE;
                truck_weight := 0;  
    
                p_vmi_init_item_constr;
    
                -- Fill bottom row (FIRST condition)
                FOR i IN 1..demands.count LOOP
                    IF NOT demands.EXISTS(i) OR demands(i).quantity <= 0 THEN
                        CONTINUE;
                    END IF;
                    
                    color := demands(i).color;
                    
                    IF truck_load_bottom.count >= max_bottom_row OR 
                       NOT f_vmi_can_add_pallet(color) THEN
                        CONTINUE;
                    END IF;
            
                    -- Check if adding this pallet would exceed truck weight capacity
                    IF (truck_weight + demands(i).actual_weight_per_pallet) <= updated_maxcap_su_pounds THEN
                        truck_load_bottom.extend;
                        truck_load_bottom(truck_load_bottom.count) := color;

                        v_pallet_info.source := demands(i).source;
                        v_pallet_info.dest := demands(i).dest;
                        v_pallet_info.transmode := demands(i).transmode;
                        v_pallet_info.u_variant_type_desc := demands(i).u_variant_type_desc;
                        v_pallet_info.u_stackabilitytype := demands(i).color;
                        v_pallet_info.item := demands(i).item;
                        v_pallet_info.schedshipdate := demands(i).schedshipdate;
                        v_pallet_info.schedarrivdate := demands(i).schedarrivdate;
                        v_pallet_info.condition := 'FIRST';
                        v_pallet_info.sourcingid := sourcingid_var;
                        v_pallet_info.sourcingid_seq := demands(i).sourcingid_seq;
                        v_pallet_info.u_priority := demands(i).u_priority;
                        v_pallet_info.sid := demands(i).sid;
                        v_pallet_info.seqnum := demands(i).seqnum;
                        v_pallet_info.pallets_qty := 1; -- Always 1 for visualization
                        v_pallet_info.actual_loaded_weight := demands(i).actual_weight_per_pallet;
                        v_pallet_info.u_sourcingmin := demands(i).u_sourcingmin;
                        
                        -- Add additional tracking information for merged pallets
                        IF demands(i).is_merged = 'Y' THEN
                            v_pallet_info.pallet_type := demands(i).pallet_type;
                            v_pallet_info.merged_pallet_id := demands(i).merged_pallet_id;
                            v_pallet_info.is_merged := demands(i).is_merged;
                            v_pallet_info.actual_quantity := demands(i).actual_quantity;
                            v_pallet_info.original_merged_id := demands(i).original_merged_id;
                            
                            -- Create positioned pallet record
                            p_vmi_create_positioned_pallet(
                                p_sourcingid => sourcingid_var,
                                p_condition => 'FIRST',
                                p_color => demands(i).color,
                                p_merged_pallet_id => demands(i).merged_pallet_id,
                                p_loadid => truck_number,
                                p_load_sequence => truck_load_bottom.count,
                                p_stack_position => 'bottom',
                                p_position_id => demands(i).position_id,
                                p_is_standalone => CASE WHEN demands(i).pallet_type = 'STANDALONE' THEN 'Y' ELSE 'N' END
                            );
                        END IF;
                        
                        truck_load_bottom_info(truck_load_bottom.count) := v_pallet_info;
                        
                        -- Mark this demand as used
                        demands(i).quantity := 0;
                        
                        -- Update truck weight and item capacity
                        truck_weight := truck_weight + demands(i).actual_weight_per_pallet;
                        p_vmi_update_truck_item_capacity(color);
                    END IF;
                END LOOP;
    
                -- Fill top row (FIRST condition)
                FOR i IN 1..truck_load_bottom.count LOOP
                    color := truck_load_bottom(i);
                    
                    IF i > (max_bottom_row - ventilation) THEN
                        -- Ventilation area - no stacking allowed
                        truck_load_top.extend;
                        truck_load_top(truck_load_top.count) := 'unavailable';
                        truck_load_top_info(truck_load_top.count) := NULL;
                    ELSIF f_vmi_is_single_stack(color) THEN
                        -- Cannot stack on this color
                        truck_load_top.extend;
                        truck_load_top(truck_load_top.count) := 'unavailable';
                        truck_load_top_info(truck_load_top.count) := NULL;
                    ELSIF f_vmi_is_stackable(color) THEN
                        -- Find a color that can stack on this bottom color
                        current_top_color := f_vmi_get_next_top_color(color, demands);
                        
                        IF current_top_color <> 'EMPTY' AND f_vmi_can_add_pallet(current_top_color) THEN
                            -- Find a demand with the compatible top color
                            DECLARE
                                found_pallet BOOLEAN := FALSE;
                                v_position_id NUMBER;
                            BEGIN
                                FOR j IN 1..demands.count LOOP
                                    IF demands.EXISTS(j) AND demands(j).color = current_top_color AND demands(j).quantity > 0 THEN
                                        -- Check if adding this pallet would exceed truck weight capacity
                                        IF (truck_weight + demands(j).actual_weight_per_pallet) <= updated_maxcap_su_pounds THEN
                                            truck_load_top.extend;
                                            truck_load_top(truck_load_top.count) := current_top_color;
                                            
                                            v_pallet_info.source := demands(j).source;
                                            v_pallet_info.dest := demands(j).dest;
                                            v_pallet_info.transmode := demands(j).transmode;
                                            v_pallet_info.u_variant_type_desc := demands(j).u_variant_type_desc;                                        
                                            v_pallet_info.u_stackabilitytype := demands(j).color;
                                            v_pallet_info.item := demands(j).item;
                                            v_pallet_info.schedshipdate := demands(j).schedshipdate;
                                            v_pallet_info.schedarrivdate := demands(j).schedarrivdate;
                                            v_pallet_info.condition := 'FIRST';
                                            v_pallet_info.sourcingid := sourcingid_var;
                                            v_pallet_info.sourcingid_seq := demands(j).sourcingid_seq;
                                            v_pallet_info.u_priority := demands(j).u_priority;
                                            v_pallet_info.sid := demands(j).sid;
                                            v_pallet_info.seqnum := demands(j).seqnum;
                                            v_pallet_info.pallets_qty := 1; -- Always 1 for visualization
                                            v_pallet_info.actual_loaded_weight := demands(j).actual_weight_per_pallet;
                                            v_pallet_info.u_sourcingmin := demands(j).u_sourcingmin;
                                            
                                            -- Add additional tracking information for merged pallets
                                            IF demands(j).is_merged = 'Y' THEN
                                                v_pallet_info.pallet_type := demands(j).pallet_type;
                                                v_pallet_info.merged_pallet_id := demands(j).merged_pallet_id;
                                                v_pallet_info.is_merged := demands(j).is_merged;
                                                v_pallet_info.actual_quantity := demands(j).actual_quantity;
                                                v_pallet_info.original_merged_id := demands(j).original_merged_id;
                                                
                                                -- Create positioned pallet record
                                                p_vmi_create_positioned_pallet(
                                                    p_sourcingid => sourcingid_var,
                                                    p_condition => 'FIRST',
                                                    p_color => demands(j).color,
                                                    p_merged_pallet_id => demands(j).merged_pallet_id,
                                                    p_loadid => truck_number,
                                                    p_load_sequence => i,  -- Use the position of the bottom pallet
                                                    p_stack_position => 'top',
                                                    p_position_id => v_position_id,
                                                    p_is_standalone => CASE WHEN demands(j).pallet_type = 'STANDALONE' THEN 'Y' ELSE 'N' END
                                                );
                                            END IF;
                                            
                                            truck_load_top_info(truck_load_top.count) := v_pallet_info;
                                            
                                            -- Mark this demand as used
                                            demands(j).quantity := 0;
                                            
                                            -- Update truck weight and capacity tracking
                                            truck_weight := truck_weight + demands(j).actual_weight_per_pallet;
                                            p_vmi_update_truck_item_capacity(current_top_color);
                                            
                                            found_pallet := TRUE;
                                            EXIT;
                                        ELSE
                                            -- Would exceed weight - leave empty
                                            truck_load_top.extend;
                                            truck_load_top(truck_load_top.count) := 'EMPTY';
                                            truck_load_top_info(truck_load_top.count) := NULL;
                                            found_pallet := TRUE;
                                            EXIT;
                                        END IF;
                                    END IF;
                                END LOOP;
    
                                IF NOT found_pallet THEN
                                    -- No compatible pallet found - leave empty
                                    truck_load_top.extend;
                                    truck_load_top(truck_load_top.count) := 'EMPTY';
                                    truck_load_top_info(truck_load_top.count) := NULL;
                                END IF;
                            END;
                        ELSE
                            -- No compatible color found or capacity constraints - leave empty
                            truck_load_top.extend;
                            truck_load_top(truck_load_top.count) := 'EMPTY';
                            truck_load_top_info(truck_load_top.count) := NULL;
                        END IF;
                    ELSE
                        -- Not stackable - leave empty
                        truck_load_top.extend;
                        truck_load_top(truck_load_top.count) := 'EMPTY';
                        truck_load_top_info(truck_load_top.count) := NULL;
                    END IF;
                END LOOP;
    
                -- Store truck information
                all_trucks(truck_number).bottom_row := truck_load_bottom;
                all_trucks(truck_number).top_row := truck_load_top;
                all_trucks(truck_number).bottom_info := truck_load_bottom_info;
                all_trucks(truck_number).top_info := truck_load_top_info;
                all_trucks(truck_number).utilization := f_vmi_calculate_utilization_plnt(truck_load_bottom, truck_load_top, src.u_adjustedmaxcap);
    
                -- Save visualization results
                p_vmi_insert_visualization_results(
                    sourcingid_var, 
                    truck_number, 
                    'FIRST',
                    all_trucks(truck_number).bottom_row,
                    all_trucks(truck_number).top_row,
                    all_trucks(truck_number).bottom_info,
                    all_trucks(truck_number).top_info
                );
    
                -- Check if more demands need to be processed
                IF f_vmi_has_remaining_demand(demands) THEN
                    truck_number := truck_number + 1;
                END IF;
            END LOOP;

            ------------------------------- SECOND Condition pallets loading -------------------------------
            IF u_sourcingmin <> 0 THEN
                max_bottom_row := LEAST(u_sourcingmin, max_bottom_row);
            END IF;
            IF truck_load_bottom IS NOT NULL AND truck_load_top IS NOT NULL THEN
                -- Check if last truck is not fully utilized, attempt to fill with SECOND condition
                IF (truck_load_bottom.count < max_bottom_row OR truck_load_top.count < max_bottom_row) THEN
                    demands.DELETE;
                    current_demand_index := 1;
                    FOR rec IN (
                        SELECT
                            source,
                            dest,
                            u_variant_type_desc,
                            u_stackabilitytype AS color,
                            SUM(pallets_qty) AS quantity,
                            sourcingid_seq,
                            item,
                            schedshipdate,
                            schedarrivdate,
                            sid,
                            seqnum,
                            u_priority,
                            color_priority_sourcingid_seq,
                            ratio,
                            wgt,
                            u_sourcingmin
                        FROM batchmgr.udc_recship
                        WHERE sourcingid = sourcingid_var
                          AND condition = 'SECOND'
                          AND u_priority = 1
                        GROUP BY source, dest, u_variant_type_desc, u_stackabilitytype, sourcingid_seq, item, schedshipdate, schedarrivdate, sid, seqnum, u_priority, color_priority_sourcingid_seq, ratio, wgt, u_sourcingmin
                        ORDER BY sourcingid_seq, color_priority_sourcingid_seq, seqnum
                    ) LOOP
                        demands(current_demand_index).source := rec.source;
                        demands(current_demand_index).dest := rec.dest;
                        demands(current_demand_index).u_variant_type_desc := rec.u_variant_type_desc;
                        demands(current_demand_index).color := rec.color;
                        demands(current_demand_index).quantity := rec.quantity; -- 1;
                        demands(current_demand_index).sourcingid_seq := rec.sourcingid_seq;
                        demands(current_demand_index).item := rec.item;
                        demands(current_demand_index).schedshipdate := rec.schedshipdate;
                        demands(current_demand_index).schedarrivdate := rec.schedarrivdate;
                        demands(current_demand_index).sid := rec.sid;
                        demands(current_demand_index).seqnum := rec.seqnum;
                        demands(current_demand_index).u_priority := rec.u_priority;
                        demands(current_demand_index).ratio := rec.ratio;
                        demands(current_demand_index).wgt := rec.wgt;
                        demands(current_demand_index).u_sourcingmin := rec.u_sourcingmin;
                        current_demand_index := current_demand_index + 1;
                        
                    END LOOP;

                    -- Fill bottom row with SECOND condition pallets
                    FOR i IN 1..demands.count LOOP
                        color := demands(i).color;
                        
                        WHILE demands(i).quantity > 0
                              AND truck_load_bottom.count < (
                                  CASE WHEN u_sourcingmin <> 0 THEN LEAST(u_sourcingmin, max_bottom_row) ELSE max_bottom_row END
                              )
                              AND f_vmi_can_add_pallet(color)
                        LOOP
                            DECLARE
                                v_pallet_weight NUMBER;
                                is_full_pallet BOOLEAN;
                                partial_su NUMBER;
                            BEGIN
                                IF demands(i).quantity >= 1 THEN
                                    v_pallet_weight := demands(i).ratio * demands(i).wgt;
                                    is_full_pallet := TRUE;
                                ELSE
                                    partial_su := demands(i).quantity * demands(i).ratio;
                                    v_pallet_weight := partial_su * demands(i).wgt;
                                    is_full_pallet := FALSE;
                                END IF;

                                IF (truck_weight + v_pallet_weight) > updated_maxcap_su_pounds THEN
                                    EXIT; 
                                END IF;

                                truck_load_bottom.extend;
                                truck_load_bottom(truck_load_bottom.count) := color;

                                v_pallet_info.source := demands(i).source;
                                v_pallet_info.dest := demands(i).dest;
                                v_pallet_info.u_variant_type_desc := demands(i).u_variant_type_desc;
                                v_pallet_info.u_stackabilitytype := demands(i).color;
                                v_pallet_info.item := demands(i).item;
                                v_pallet_info.schedshipdate := demands(i).schedshipdate;
                                v_pallet_info.schedarrivdate := demands(i).schedarrivdate;
                                v_pallet_info.condition := 'SECOND';
                                v_pallet_info.sourcingid := sourcingid_var;
                                v_pallet_info.sourcingid_seq := demands(i).sourcingid_seq;
                                v_pallet_info.u_priority := demands(i).u_priority;
                                v_pallet_info.sid := demands(i).sid;
                                v_pallet_info.seqnum := demands(i).seqnum;
                                --v_pallet_info.pallets_qty := demands(i).quantity;
                                IF is_full_pallet THEN
                                    v_pallet_info.pallets_qty :=1;
                                ELSE
                                    v_pallet_info.pallets_qty := demands(i).quantity;
                                END IF;
                                v_pallet_info.actual_loaded_weight := v_pallet_weight;
                                v_pallet_info.u_sourcingmin := demands(i).u_sourcingmin;
                                truck_load_bottom_info(truck_load_bottom.count) := v_pallet_info;

                                IF is_full_pallet THEN
                                    demands(i).quantity := demands(i).quantity - 1;
                                ELSE
                                    demands(i).quantity := 0;
                                END IF;

                                truck_weight := truck_weight + v_pallet_weight;
                                p_vmi_update_truck_item_capacity(color);

                                truck_load_top.extend;
                                truck_load_top(truck_load_top.count) := 'EMPTY';
                                truck_load_top_info(truck_load_top.count) := NULL;
                            END;
                        END LOOP;
                    END LOOP;

                    -- Fill top row for SECOND condition
                    FOR i IN 1..truck_load_bottom.count LOOP
                        color := truck_load_bottom(i);
                        IF i > (max_bottom_row - ventilation) THEN
                            truck_load_top(i) := 'unavailable';
                            truck_load_top_info(i) := NULL;
                        ELSE
                            IF f_vmi_is_single_stack(color) THEN
                                truck_load_top(i) := 'unavailable';
                                truck_load_top_info(i) := NULL;
                            ELSIF f_vmi_is_stackable(color) THEN
                                DECLARE
                                    bottom_sourcingid_seq NUMBER := NULL;
                                    found_pallet BOOLEAN := FALSE;
                                    v_pallet_weight NUMBER;
                                    is_full_pallet BOOLEAN;
                                    partial_su NUMBER;
                                    current_top_color VARCHAR2(1000);
                                BEGIN
                                    FOR j IN 1..demands.count LOOP
                                        IF demands(j).color = color THEN
                                            bottom_sourcingid_seq := demands(j).sourcingid_seq;
                                            EXIT;
                                        END IF;
                                    END LOOP;

                                    IF bottom_sourcingid_seq IS NOT NULL THEN
                                        current_top_color := f_vmi_seq_get_next_top_color(color, bottom_sourcingid_seq, demands);

                                        IF current_top_color <> 'EMPTY' AND f_vmi_can_add_pallet(current_top_color) THEN
                                            FOR k IN 1..demands.count LOOP
                                                IF demands(k).color = current_top_color AND demands(k).quantity > 0 THEN
                                                    IF demands(k).quantity >= 1 THEN
                                                        v_pallet_weight := demands(k).ratio * demands(k).wgt;
                                                        is_full_pallet := TRUE;
                                                    ELSE
                                                        partial_su := demands(k).quantity * demands(k).ratio;
                                                        v_pallet_weight := partial_su * demands(k).wgt;
                                                        is_full_pallet := FALSE;
                                                    END IF;

                                                    IF (truck_weight + v_pallet_weight) <= updated_maxcap_su_pounds THEN
                                                        truck_load_top(i) := current_top_color;

                                                        v_pallet_info.source := demands(k).source;
                                                        v_pallet_info.dest := demands(k).dest;
                                                        v_pallet_info.u_variant_type_desc := demands(k).u_variant_type_desc;
                                                        v_pallet_info.u_stackabilitytype := demands(k).color;
                                                        v_pallet_info.item := demands(k).item;
                                                        v_pallet_info.schedshipdate := demands(k).schedshipdate;
                                                        v_pallet_info.schedarrivdate := demands(k).schedarrivdate;
                                                        v_pallet_info.condition := 'SECOND';
                                                        v_pallet_info.sourcingid := sourcingid_var;
                                                        v_pallet_info.sourcingid_seq := demands(k).sourcingid_seq;
                                                        v_pallet_info.u_priority := demands(k).u_priority;
                                                        v_pallet_info.sid := demands(k).sid;
                                                        v_pallet_info.seqnum := demands(k).seqnum;
                                                        --v_pallet_info.pallets_qty := demands(k).quantity;
                                                        IF is_full_pallet THEN
                                                            v_pallet_info.pallets_qty :=1;
                                                        ELSE
                                                            v_pallet_info.pallets_qty := demands(k).quantity;
                                                        END IF;
                                                        v_pallet_info.actual_loaded_weight := v_pallet_weight;
                                                        v_pallet_info.u_sourcingmin := demands(k).u_sourcingmin;
                                                        truck_load_top_info(i) := v_pallet_info;

                                                        truck_weight := truck_weight + v_pallet_weight;
                                                        p_vmi_update_truck_item_capacity(current_top_color);

                                                        IF is_full_pallet THEN
                                                            demands(k).quantity := demands(k).quantity - 1;
                                                        ELSE
                                                            demands(k).quantity := 0;
                                                        END IF;

                                                        found_pallet := TRUE;
                                                        EXIT;
                                                    ELSE
                                                        truck_load_top(i) := 'EMPTY';
                                                        truck_load_top_info(i) := NULL;
                                                        found_pallet := TRUE;
                                                        EXIT;
                                                    END IF;
                                                END IF;
                                            END LOOP;

                                            IF NOT found_pallet THEN
                                                truck_load_top(i) := 'EMPTY';
                                                truck_load_top_info(i) := NULL;
                                            END IF;
                                        ELSE
                                            truck_load_top(i) := 'EMPTY';
                                            truck_load_top_info(i) := NULL;
                                        END IF;
                                    ELSE
                                        truck_load_top(i) := 'EMPTY';
                                        truck_load_top_info(i) := NULL;
                                    END IF;
                                END;
                            ELSE
                                truck_load_top(i) := 'EMPTY';
                                truck_load_top_info(i) := NULL;
                            END IF;
                        END IF;
                    END LOOP;

                    IF truck_load_bottom.count > all_trucks(truck_number).bottom_row.count
                       OR truck_load_top.count > all_trucks(truck_number).top_row.count THEN
                        last_truck_modified := true;

                        all_trucks(truck_number).bottom_row := truck_load_bottom;
                        all_trucks(truck_number).top_row := truck_load_top;
                        all_trucks(truck_number).bottom_info := truck_load_bottom_info;
                        all_trucks(truck_number).top_info := truck_load_top_info;
                        all_trucks(truck_number).utilization := f_vmi_calculate_utilization_plnt(truck_load_bottom, truck_load_top, src.u_adjustedmaxcap);

                        p_vmi_insert_visualization_results(sourcingid_var, truck_number, 'SECOND',
                                                           all_trucks(truck_number).bottom_row,
                                                           all_trucks(truck_number).top_row,
                                                           all_trucks(truck_number).bottom_info,
                                                           all_trucks(truck_number).top_info);
                    END IF;
                END IF;
            END IF;
        END LOOP; 

        p_vmi_transfer_to_urecship();

        DELETE FROM batchmgr.u_recship
        WHERE id NOT IN (
            SELECT MIN(id)
            FROM batchmgr.u_recship
            GROUP BY
                SOURCINGID, SOURCINGID_SEQ, CONDITION, U_PRIORITY, LOADID, LOAD_SEQUENCE, LOADED, UTILIZATION, U_SOURCINGMIN, SCHEDSHIPDATE, SCHEDARRIVDATE, SOURCE, DEST, TRANSMODE, U_VARIANT_TYPE_DESC, ITEM, U_STACKABILITYTYPE, PALLETS_QTY, UPDATED_WGT, UPDATED_MINCAP_SU_PALLETS, UPDATED_MAXCAP_SU_PALLETS, UPDATED_MINCAP_SU_POUNDS, UPDATED_MAXCAP_SU_POUNDS, U_ITEM_MINTRUCKSTACKCAP, U_ITEM_MAXTRUCKSTACKCAP, SID, SEQNUM, STACK_POSITION, U_DISPATCHDATE, RATIO, RECQTY, SALES_UNITS_QTY, MAJORSHIPQTY, MINORSHIPQTY, STATUS, SOURCING, TRANSLEADTIME, ARRIVCAL, SHIPCAL, CREATED_AT, U_ADJUSTEDMAXCAP, WGT, SYSTEM_UPDATED_WGT, SYSTEM_SALES_UNITS_QTY, AVAILTOSHIPDATE, CONSTRRECSHIPSW
        );

        COMMIT;

        l_d_end_date_time := SYSTIMESTAMP;
        l_v_prog_status := 'SUCCESS';
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time,
            l_d_enddatetime_in => l_d_end_date_time,
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => SYSDATE, 
                l_v_errorid_in => SQLCODE, l_v_errormessage_in => SQLERRM, l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time, 
                l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_optimize_load;
    
    PROCEDURE p_vmi_calculate_src_wgts (
        p_sourcingid NUMBER
    ) IS
      /******************************************************************
      Procedure : P_VMI_CALCULATE_SRC_WGTS
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_CALCULATE_SRC_WGTS';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate P_VMI_CALCULATE_SRC_WGTS';
        FOR rec IN (
            SELECT
                sourcingid,
                item,
                u_stackabilitytype,
                SUM(updated_wgt) AS total_weight,
                SUM(pallets_qty) AS total_pallets
            FROM
                batchmgr.udc_recship
            WHERE
                    sourcingid = p_sourcingid
                AND condition IN ( 'FIRST', 'SECOND' )
                AND u_priority = 1
            GROUP BY
                sourcingid,
                item,
                u_stackabilitytype
        ) LOOP
            --log_debug('Zero Quantity Issue: ' || rec.total_pallets || rec.total_weight || CASE WHEN rec.total_pallets=0 then 1 ELSE rec.total_pallets END);
            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).sourcingid := rec.sourcingid;

            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).item := rec.item;

            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).u_stackabilitytype := rec.u_stackabilitytype;

            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).total_weight := rec.total_weight;

            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).total_pallets := rec.total_pallets;

            weight_calculations(rec.sourcingid
                                || '|'
                                || rec.item
                                || '|'
                                || rec.u_stackabilitytype).weight_per_pallet :=
                CASE
                    WHEN rec.total_pallets > 0 THEN
                        rec.total_weight / rec.total_pallets
                    ELSE 0
                END;

        END LOOP;
        
--       
--     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END p_vmi_calculate_src_wgts;

    PROCEDURE p_vmi_init_item_constr IS
      /******************************************************************
      Procedure : P_VMI_INIT_ITEM_CONSTR
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INIT_ITEM_CONSTR';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate P_VMI_INIT_ITEM_CONSTR';
        truck_item_capacities.DELETE;
        FOR i IN 1..item_constraints.count LOOP
            truck_item_capacities(i).u_stackabilitytype := item_constraints(i).u_stackabilitytype;
            truck_item_capacities(i).current_count := 0;
        END LOOP;
        
--     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END p_vmi_init_item_constr;

    PROCEDURE p_vmi_update_truck_item_capacity (
        p_u_stackabilitytype VARCHAR2
    ) IS
      /******************************************************************
      Procedure : P_VMI_update_truck_item_capacity
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_update_truck_item_capacity';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate P_VMI_update_truck_item_capacity';
        FOR i IN 1..truck_item_capacities.count LOOP
            IF truck_item_capacities(i).u_stackabilitytype = p_u_stackabilitytype THEN
                truck_item_capacities(i).current_count := truck_item_capacities(i).current_count + 1;
                EXIT;
            END IF;
        END LOOP;
        
     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END p_vmi_update_truck_item_capacity;
    
    FUNCTION f_vmi_get_truck_current_pallets (
        p_sourcingid NUMBER,
        p_loadid     NUMBER,
        p_u_priority NUMBER
    ) RETURN NUMBER IS
        v_pallet_count NUMBER := 0;
    BEGIN
        -- Calculate the number of pallets currently assigned to the truck
        -- Note: This assumes 'pallets_qty' in u_recship represents 1 physical pallet slot
        -- Adjust logic if 'pallets_qty' can be fractional and needs summing/ceiling
        SELECT SUM(NVL(case when u_stackabilitytype in ('RED', 'SS') then 2 else 1 end, 0))
        INTO v_pallet_count
        FROM batchmgr.u_recship
        WHERE sourcingid = p_sourcingid
          AND loadid = p_loadid
          AND u_priority = p_u_priority;

        RETURN NVL(v_pallet_count, 0);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
        WHEN OTHERS THEN
            -- Consider logging the error
            RETURN 0; -- Or raise error
    END f_vmi_get_truck_current_pallets;

    FUNCTION f_vmi_get_truck_current_weight (
        p_sourcingid NUMBER,
        p_loadid     NUMBER,
        p_u_priority NUMBER
    ) RETURN FLOAT IS
        v_total_weight FLOAT := 0;
    BEGIN
        -- Calculate the total weight currently assigned to the truck
        -- using the 'updated_wgt' which should hold the actual weight per record
        SELECT SUM(NVL(updated_wgt, 0))
        INTO v_total_weight
        FROM batchmgr.u_recship
        WHERE sourcingid = p_sourcingid
          AND loadid = p_loadid
          AND u_priority = p_u_priority;

        RETURN NVL(v_total_weight, 0);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
        WHEN OTHERS THEN
            -- Consider logging the error
            RETURN 0; -- Or raise error
    END f_vmi_get_truck_current_weight;

    PROCEDURE p_vmi_hub_merge_partial_pallets(
        p_sourcingid IN NUMBER,
        p_condition IN VARCHAR2 DEFAULT 'FIRST',
        p_tolerance IN FLOAT DEFAULT 0.0001
    ) IS
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_HUB_MERGE_PARTIAL_PALLETS';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- For tracking partial pallets
        v_partials partial_pallet_array;
        v_partial_count NUMBER := 0;
        
        -- For merged bins
        v_bins merged_bin_array;
    BEGIN
        -- Initialize interface
        l_d_start_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
        
        -- Process each color with merging
        FOR color_rec IN (
            SELECT DISTINCT u_stackabilitytype AS color, color_priority_sourcingid_seq as color_seqn
            FROM batchmgr.priority_shift_pallets 
            WHERE sourcingid = p_sourcingid
              AND (pallets_qty > 0 and pallets_qty < 1)
            ORDER BY color_seqn
        ) LOOP
            -- Reset arrays for this color
            v_partials.DELETE;
            v_partial_count := 0;
            
            -- Get partial pallets for this color
            FOR rec IN (
                SELECT
                    min(id) as id, source, dest, u_variant_type_desc, transmode, 
                    u_stackabilitytype AS color, item, 
                    sum(pallets_qty) AS quantity,
                    sum(updated_wgt) AS weight,
                    sourcingid_seq, schedshipdate, schedarrivdate,
                    sid, seqnum, u_priority, recqty, ratio, wgt, u_sourcingmin, 
                    color_priority_sourcingid_seq,
                    min(updated_mincap_su_pallets) as updated_mincap_su_pallets,
                    min(updated_maxcap_su_pallets) as updated_maxcap_su_pallets,
                    min(updated_mincap_su_pounds) as updated_mincap_su_pounds,
                    min(updated_maxcap_su_pounds) as updated_maxcap_su_pounds,
                    min(u_item_mintruckstackcap) as u_item_mintruckstackcap,
                    min(u_item_maxtruckstackcap) as u_item_maxtruckstackcap,
                    min(u_dispatchdate) as u_dispatchdate,
                    sum(sales_units_qty) as sales_units_qty,
                    min(majorshipqty) as majorshipqty,
                    min(minorshipqty) as minorshipqty,
                    min(transleadtime) as transleadtime,
                    min(arrivcal) as arrivcal,
                    min(shipcal) as shipcal,
                    min(u_adjustedmaxcap) as u_adjustedmaxcap,
                    min(constrrecshipsw) as constrrecshipsw,
                    min(availtoshipdate) as availtoshipdate,
                    min(needshipdate) as needshipdate,
                    min(needarrivdate) as needarrivdate
                FROM batchmgr.priority_shift_pallets
                WHERE sourcingid = p_sourcingid
                  AND condition = p_condition
                  AND u_stackabilitytype = color_rec.color
                  AND (pallets_qty > 0 and pallets_qty < 1)
                GROUP BY
                    source, dest, transmode, u_variant_type_desc, u_stackabilitytype, item, 
                    sourcingid_seq, schedshipdate, schedarrivdate, sid, seqnum, u_priority, 
                    recqty, ratio, wgt, u_sourcingmin, color_priority_sourcingid_seq
                ORDER BY
                    color_priority_sourcingid_seq, seqnum
            ) LOOP
                v_partial_count := v_partial_count + 1;
                v_partials(v_partial_count).id := rec.id;
                v_partials(v_partial_count).item := rec.item;
                v_partials(v_partial_count).quantity := rec.quantity;
                v_partials(v_partial_count).color := rec.color;
                v_partials(v_partial_count).weight := rec.weight;
                v_partials(v_partial_count).is_split := FALSE;
                v_partials(v_partial_count).source := rec.source;
                v_partials(v_partial_count).dest := rec.dest;
                v_partials(v_partial_count).transmode := rec.transmode;
                v_partials(v_partial_count).u_variant_type_desc := rec.u_variant_type_desc;
                v_partials(v_partial_count).sourcingid_seq := rec.sourcingid_seq;
                v_partials(v_partial_count).schedshipdate := rec.schedshipdate;
                v_partials(v_partial_count).schedarrivdate := rec.schedarrivdate;
                v_partials(v_partial_count).sid := rec.sid;
                v_partials(v_partial_count).seqnum := rec.seqnum;
                v_partials(v_partial_count).u_priority := rec.u_priority;
                v_partials(v_partial_count).recqty := rec.recqty;
                v_partials(v_partial_count).ratio := rec.ratio;
                v_partials(v_partial_count).wgt := rec.wgt;
                v_partials(v_partial_count).u_sourcingmin := rec.u_sourcingmin;
                v_partials(v_partial_count).color_seqn := rec.color_priority_sourcingid_seq;
                v_partials(v_partial_count).u_dispatchdate := rec.u_dispatchdate;
                v_partials(v_partial_count).sales_units_qty := rec.sales_units_qty;
                v_partials(v_partial_count).majorshipqty := rec.majorshipqty;
                v_partials(v_partial_count).minorshipqty := rec.minorshipqty;
                v_partials(v_partial_count).transleadtime := rec.transleadtime;
                v_partials(v_partial_count).arrivcal := rec.arrivcal;
                v_partials(v_partial_count).shipcal := rec.shipcal;
                v_partials(v_partial_count).u_adjustedmaxcap := rec.u_adjustedmaxcap;
                v_partials(v_partial_count).constrrecshipsw := rec.constrrecshipsw;
                v_partials(v_partial_count).availtoshipdate := rec.availtoshipdate;
                v_partials(v_partial_count).needshipdate := rec.needshipdate;
                v_partials(v_partial_count).needarrivdate := rec.needarrivdate;
                v_partials(v_partial_count).updated_mincap_su_pallets := rec.updated_mincap_su_pallets;
                v_partials(v_partial_count).updated_maxcap_su_pallets := rec.updated_maxcap_su_pallets;
                v_partials(v_partial_count).updated_mincap_su_pounds := rec.updated_mincap_su_pounds;
                v_partials(v_partial_count).updated_maxcap_su_pounds := rec.updated_maxcap_su_pounds;
                v_partials(v_partial_count).u_item_mintruckstackcap := rec.u_item_mintruckstackcap;
                v_partials(v_partial_count).u_item_maxtruckstackcap := rec.u_item_maxtruckstackcap;
            END LOOP;
            
            -- Skip if no partials found
            IF v_partial_count = 0 THEN
                CONTINUE;
            END IF;
            
            -- Run the merging algorithm
            v_bins := f_vmi_merge_partials(v_partials, color_rec.color, p_tolerance);
            
            -- Store results in the merged pallet tables
            p_vmi_store_merged_pallets(p_sourcingid, p_condition, color_rec.color, v_bins);
        END LOOP;
        
        -- Success path
        l_v_prog_status := 'SUCCESS';
        l_d_end_date_time := SYSTIMESTAMP;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
            l_d_startdatetime_in => l_d_start_date_time,
            l_d_enddatetime_in => l_d_end_date_time,
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Error handling
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => SYSDATE,
                l_v_errorid_in => SQLCODE, l_v_errormessage_in => SQLERRM, l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
            l_d_end_date_time := SYSTIMESTAMP;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time,
                l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_hub_merge_partial_pallets;
    
    PROCEDURE p_vmi_process_priority_shift IS
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_process_priority_shift';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_count             NUMBER;
        max_sourcingid      NUMBER := 0;
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                      l_d_startdatetime_in => l_d_start_date_time, 
                                      l_v_progstatus_in => 'Started..');
    
        l_v_errstep := 'Calculate P_VMI_process_priority_shift';
        
        EXECUTE IMMEDIATE 'TRUNCATE TABLE priority_shift_pallets';
        
        -- Main process - existing code
        FOR rec IN (
            SELECT
                sourcingid,
                loadid,
                substr(u_variant_type_desc,1,2) as u_variant_type_desc,
                u_priority
            FROM
                batchmgr.u_recship
            GROUP BY 
                sourcingid,
                loadid,
                substr(u_variant_type_desc,1,2),
                u_priority
            ORDER BY
                sourcingid,
                loadid,
                substr(u_variant_type_desc,1,2),
                u_priority
        ) LOOP
            IF f_vmi_check_sourcingmin(rec.sourcingid, rec.loadid, rec.u_variant_type_desc, rec.u_priority) THEN
                UPDATE batchmgr.u_recship
                SET
                    status = 'loaded'
                WHERE
                    sourcingid = rec.sourcingid
                    AND loadid = rec.loadid
                    AND substr(u_variant_type_desc,1,2) = substr(rec.u_variant_type_desc,1,2)
                    AND u_priority = rec.u_priority;
                COMMIT;
            ELSE
                UPDATE batchmgr.u_recship
                SET
                    status = 'conversion'
                WHERE
                    sourcingid = rec.sourcingid
                    AND loadid = rec.loadid
                    AND substr(u_variant_type_desc,1,2) = rec.u_variant_type_desc
                    AND u_priority = rec.u_priority;
                COMMIT;
    
                p_vmi_prepare_priority_shift_pallets(rec.sourcingid, rec.loadid, rec.u_variant_type_desc, rec.u_priority);
                COMMIT;
            END IF;
        END LOOP;
         
        EXECUTE IMMEDIATE 'TRUNCATE TABLE priority_shift_pallets_conv';
        EXECUTE IMMEDIATE 'INSERT INTO priority_shift_pallets_conv SELECT * FROM priority_shift_pallets';
    
        p_vmi_apply_priority_shift_rules();
        COMMIT;
        
        SELECT MAX(sourcingid) INTO max_sourcingid FROM udc_recship;
        
        -- update sourcingid & sourcingid_seq                                                      
        MERGE /*+parallel(16) */ INTO batchmgr.priority_shift_pallets t  
        USING (
              WITH ranked_data AS (
                  SELECT
                      ROWID AS rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      substr(u_variant_type_desc, 1, 2) AS u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      DENSE_RANK() OVER(
                          PARTITION BY 
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN 1 
                                  ELSE 0 
                              END
                          ORDER BY
                              source, 
                              dest, 
                              transmode, 
                              substr(u_variant_type_desc, 1, 2),
                              u_priority,
                              CASE 
                                  WHEN constrrecshipsw != 0 THEN availtoshipdate
                              END
                      ) AS sourcingid
                  FROM
                      batchmgr.priority_shift_pallets
              ), final_data AS (
                  SELECT
                      rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      sourcingid,
                      DENSE_RANK() OVER(
                          PARTITION BY sourcingid
                          ORDER BY
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN schedshipdate
                                  ELSE availtoshipdate
                              END
                      ) AS sourcingid_seq
                  FROM
                      ranked_data
              )
              SELECT
                  rid,
                  schedshipdate,
                  source,
                  dest,
                  transmode,
                  u_variant_type_desc,
                  u_priority,
                  constrrecshipsw,
                  sourcingid,
                  sourcingid_seq
              FROM
                  final_data
          ) temp ON (t.rowid = temp.rid)
        WHEN MATCHED THEN UPDATE
        SET t.sourcingid = temp.sourcingid,
        t.sourcingid_seq = temp.sourcingid_seq;
        
        COMMIT;
        
        UPDATE priority_shift_pallets SET sourcingid = sourcingid + max_sourcingid;
        
        COMMIT;
        
        UPDATE priority_shift_pallets SET color_priority_sourcingid_seq = CASE
                WHEN u_stackabilitytype = 'RED' THEN 1
                WHEN u_stackabilitytype = 'SS' THEN 2
                WHEN u_stackabilitytype = 'BLACK' THEN 3
                WHEN u_stackabilitytype = 'GREEN' THEN 4
                WHEN u_stackabilitytype = 'DS' THEN 5
                WHEN u_stackabilitytype = 'YELLOW' THEN 6
                ELSE 7
            END;
        COMMIT;
                
        -- NEW SECTION: Process merged pallets for each sourcingid
        l_v_errstep := 'Process merged pallets for hub truck building';
        FOR src IN (
            SELECT DISTINCT sourcingid
            FROM batchmgr.priority_shift_pallets
            ORDER BY sourcingid
        ) LOOP
            -- Call our new hub merging procedure
            p_vmi_hub_merge_partial_pallets(src.sourcingid);
        END LOOP;
        COMMIT;
        
        -- Continue with existing truck building process
        FOR src IN (
            SELECT DISTINCT
                sourcingid
            FROM
                batchmgr.priority_shift_pallets
            ORDER BY
                sourcingid
        ) LOOP
            p_vmi_create_priority_shift_trucks(src.sourcingid);
            COMMIT;
            
            -- Add a check to see if records were inserted
            SELECT
                COUNT(*)
            INTO v_count
            FROM
                batchmgr.u_recship
            WHERE
                sourcingid = src.sourcingid;
        END LOOP;
    
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                      l_d_startdatetime_in => l_d_start_date_time, 
                                      l_d_enddatetime_in => l_d_end_date_time, 
                                      l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                                    l_d_datetime_in => sysdate, 
                                    l_v_errorid_in => sqlcode, 
                                    l_v_errormessage_in => sqlerrm, 
                                    l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, 
                                    l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                          l_d_startdatetime_in => l_d_start_date_time, 
                                          l_d_enddatetime_in => l_d_end_date_time, 
                                          l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_process_priority_shift;

    PROCEDURE p_vmi_prepare_priority_shift_pallets (
            p_sourcingid NUMBER,
            p_loadid     NUMBER,
            p_u_variant_type_desc VARCHAR2,
            p_u_priority NUMBER
    ) IS
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_prepare_priority_shift_pallets';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_u_sourcingmin     NUMBER;
        v_count             NUMBER;
        max_sourcingid      NUMBER := 0;
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
    
        -- Main process
        l_v_errstep := 'Getting u_sourcingmin';
        
        /*
        -- Get minimum sourcingmin
        SELECT
            nvl(MIN(u_sourcingmin), 0)
        INTO v_u_sourcingmin
        FROM
            batchmgr.udc_recship
        WHERE
            sourcingid = p_sourcingid
            AND substr(u_variant_type_desc,1,2) = substr(p_u_variant_type_desc,1,2)
            AND u_priority = p_u_priority
            AND ROWNUM = 1;
        */
        
        l_v_errstep := 'Inserting into priority_shift_pallets with consolidation';
        
        -- Insert into priority_shift_pallets with grouping to consolidate same items
        INSERT /*+parallel(16) */ INTO batchmgr.priority_shift_pallets (
            sourcingid,
            sourcingid_seq,
            condition,
            u_priority,
            u_sourcingmin,
            schedshipdate,
            schedarrivdate,
            source,
            dest,
            transmode,
            u_variant_type_desc,
            item,
            u_stackabilitytype,
            pallets_qty,
            updated_wgt,
            updated_mincap_su_pallets,
            updated_maxcap_su_pallets,
            updated_mincap_su_pounds,
            updated_maxcap_su_pounds,
            u_item_mintruckstackcap,
            u_item_maxtruckstackcap,
            sid,
            seqnum,
            status,
            u_dispatchdate,
            ratio,
            recqty,
            sales_units_qty,
            majorshipqty,
            minorshipqty,
            transleadtime,
            arrivcal,
            shipcal,
            u_adjustedmaxcap,
            wgt,
            constrrecshipsw,
            availtoshipdate,
            needshipdate,
            needarrivdate
        )
        SELECT
            sourcingid,
            sourcingid_seq,
            condition,
            u_priority,
            u_sourcingmin,
            schedshipdate,
            schedarrivdate,
            source,
            dest,
            transmode,
            u_variant_type_desc,
            item,
            u_stackabilitytype,
            pallets_qty,
            updated_wgt,
            updated_mincap_su_pallets,
            updated_maxcap_su_pallets,
            updated_mincap_su_pounds,
            updated_maxcap_su_pounds,
            u_item_mintruckstackcap,
            u_item_maxtruckstackcap,
            sid,
            seqnum,
            'priority_shift'            AS status,
            u_dispatchdate,
            ratio,
            recqty,
            sales_units_qty,
            majorshipqty,
            minorshipqty,
            transleadtime,
            arrivcal,
            shipcal,
            u_adjustedmaxcap,
            wgt,
            constrrecshipsw,
            availtoshipdate,
            needshipdate,
            needarrivdate
        FROM
            batchmgr.u_recship
        WHERE
               sourcingid               = p_sourcingid
          AND  loadid                   = p_loadid
          AND  SUBSTR(u_variant_type_desc,1,2) = SUBSTR(p_u_variant_type_desc,1,2)
          AND  u_priority               = p_u_priority
          AND  condition                = 'FIRST';
          --AND  pallets_qty < v_u_sourcingmin;
        
        commit;

        l_v_errstep := 'Deleting from u_recship';
        
        -- Delete the original records from u_recship
        DELETE FROM batchmgr.u_recship
        WHERE
            sourcingid = p_sourcingid
            AND loadid = p_loadid
            AND substr(u_variant_type_desc,1,2) = substr(p_u_variant_type_desc,1,2)
            AND u_priority = p_u_priority;
            --AND condition = 'FIRST';
            --AND pallets_qty < v_u_sourcingmin;
        commit;
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, 
            l_d_enddatetime_in => l_d_end_date_time, 
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
         
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                l_d_datetime_in => sysdate, 
                l_v_errorid_in => sqlcode, 
                l_v_errormessage_in => sqlerrm, 
                l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, 
                l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                l_d_startdatetime_in => l_d_start_date_time, 
                l_d_enddatetime_in => l_d_end_date_time, 
                l_v_progstatus_in => l_v_prog_status,
                l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_prepare_priority_shift_pallets;

    PROCEDURE p_vmi_apply_priority_shift_rules IS
    /******************************************************************
      Procedure : P_VMI_apply_priority_shift_rules
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_apply_priority_shift_rules';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_u_sourcingmin     NUMBER;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_apply_priority_shift_rules';
        FOR rule IN (
            SELECT
                *
            FROM
                batchmgr.priority_shift
        ) LOOP
            UPDATE batchmgr.priority_shift_pallets
            SET
                source = rule.source2,
                transmode = rule.transmode2,
                u_stackabilitytype = rule.u_stackabilitytype2,
                u_priority = rule.u_priority2,
                u_sourcingmin = rule.u_sourcingmin2
            WHERE
                    dest = rule.dest
                --AND transmode = rule.transmode
                AND substr(u_variant_type_desc,1,2) = substr(rule.u_variant_type_desc,1,2)
                AND item = rule.item
                AND sid = rule.sid
                AND source = rule.source1
                AND transmode = rule.transmode1
                AND u_stackabilitytype = rule.u_stackabilitytype1
                AND u_priority = rule.u_priority1
                AND u_sourcingmin = rule.u_sourcingmin1;

         END LOOP;     
        
        -- change of shipcal from priority 1 -> 2
        UPDATE batchmgr.priority_shift_pallets SET shipcal='RULE_' || SOURCE where shipcal <> ' ';
        
        -- change of arrivcal from priority 1 -> 2
        UPDATE batchmgr.priority_shift_pallets SET arrivcal='RULE_' || DEST where arrivcal <> ' ';
       
       
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_apply_priority_shift_rules;

    PROCEDURE p_vmi_create_priority_shift_trucks (
        p_sourcingid NUMBER
    ) IS
        /******************************************************************
          Procedure : P_VMI_create_priority_shift_trucks
          Description : Builds optimized trucks from pallets with proper defensive coding
                        and enhanced merged pallet handling
          Revision History:
          ------------------
          Date            Author                    Description
          ----            -----                     ------------
          May-13-2025     Vinay Kumar Govardhanam   Fixed NULL value handling and improved logic
          06-June-2024    Vinay Kumar Govardhanam   Modified Version
        *******************************************************************/
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_create_priority_shift_trucks';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    
        -- Truck building variables
        max_pallets         NUMBER;
        min_pallets         NUMBER;
        min_weight          NUMBER;
        max_weight          FLOAT;
        v_current_weight    FLOAT := 0;
        v_current_pallets   NUMBER := 0;
        v_truck_number      NUMBER := 1;
        v_u_adjustedmaxcap  NUMBER;
        ventilation         FLOAT;
        
        -- Row tracking
        v_bottom_row        sys.odcivarchar2list := sys.odcivarchar2list();
        v_top_row           sys.odcivarchar2list := sys.odcivarchar2list();
        v_bottom_info       pallet_list_info := pallet_list_info();
        v_top_info          pallet_list_info := pallet_list_info();
        
        -- Collected pallets (all types)
        v_all_pallets_info  pallet_list_info := pallet_list_info();
        
        -- Color priority for sorting
        v_local_color_priority color_priority_map;
        
        -- For stacking logic
        v_can_stack        BOOLEAN;
        v_weight_capacity  BOOLEAN;
        v_pallet_info      each_pallet_info;
        min_item_capacity   NUMBER; 
        max_item_capacity   NUMBER;
        
        -- For tracking merged pallets
        v_position_id      NUMBER;
        
        -- For error tracking
        v_function_name    VARCHAR2(100);
        v_error_message    VARCHAR2(4000);
    BEGIN
        -- Initialize logging
        l_d_start_date_time := systimestamp;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
    
        EXECUTE IMMEDIATE 'TRUNCATE TABLE vmi_pallet_report';
    
        l_v_errstep := 'Get constraints for P_VMI_create_priority_shift_trucks';
    
        -- Get truck constraints
        BEGIN
            SELECT
                MAX(round(updated_mincap_su_pounds, 2)),
                MAX(updated_maxcap_su_pounds),
                MAX(round(updated_mincap_su_pallets)),
                MAX(updated_maxcap_su_pallets),
                MAX(u_adjustedmaxcap)
            INTO
                min_weight,
                max_weight,
                min_pallets,
                max_pallets,
                v_u_adjustedmaxcap
            FROM
                batchmgr.priority_shift_pallets
            WHERE
                sourcingid = p_sourcingid;
            
            /*
            -- DEBUG: capacity calculations
            DBMS_OUTPUT.PUT_LINE('=== CAPACITY DEBUG FOR SOURCINGID: ' || p_sourcingid || ' ===');
            DBMS_OUTPUT.PUT_LINE('max_pallets: ' || max_pallets);
            DBMS_OUTPUT.PUT_LINE('v_u_adjustedmaxcap: ' || v_u_adjustedmaxcap);
            DBMS_OUTPUT.PUT_LINE('min_pallets: ' || min_pallets);
            DBMS_OUTPUT.PUT_LINE('max_weight: ' || max_weight);
            DBMS_OUTPUT.PUT_LINE('min_weight: ' || min_weight);
            */
                
             -- Fetch item capacity constraints
            item_constraints.DELETE;
            FOR constraint_rec IN (
                SELECT
                    u_stackabilitytype,
                    MIN(u_item_mintruckstackcap) AS min_capacity,
                    MAX(u_item_maxtruckstackcap) AS max_capacity
                FROM batchmgr.udc_recship
                WHERE sourcingid = p_sourcingid
                GROUP BY u_stackabilitytype
            ) LOOP
                min_item_capacity := constraint_rec.min_capacity;
                max_item_capacity := constraint_rec.max_capacity;
                item_constraints(item_constraints.count + 1).u_stackabilitytype := constraint_rec.u_stackabilitytype;
                item_constraints(item_constraints.count).min_capacity := constraint_rec.min_capacity;
                item_constraints(item_constraints.count).max_capacity := constraint_rec.max_capacity;
            END LOOP;
    
            p_vmi_calculate_src_wgts(p_sourcingid);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                l_v_errstep := 'No constraint data found for sourcingID: ' || p_sourcingid;
                RAISE_APPLICATION_ERROR(-20001, 'No constraint data found for sourcingID: ' || p_sourcingid);
        END;
    
        -- Validate essential values
        IF max_weight IS NULL OR max_pallets IS NULL OR v_u_adjustedmaxcap IS NULL THEN
            l_v_errstep := 'Invalid constraint values for sourcingID: ' || p_sourcingid;
            RAISE_APPLICATION_ERROR(-20002, 'Invalid constraint values for sourcingID: ' || p_sourcingid);
        END IF;
    
        -- Calculate ventilation
        ventilation := NVL(max_pallets - v_u_adjustedmaxcap, 0);
        --DBMS_OUTPUT.PUT_LINE('ventilation: ' || ventilation);
        
        -- Initialize color priority map for sorting
        v_local_color_priority('RED') := 1;
        v_local_color_priority('SS') := 2;
        v_local_color_priority('BLACK') := 3;
        v_local_color_priority('GREEN') := 4; 
        v_local_color_priority('DS') := 5;
        v_local_color_priority('YELLOW') := 6;
        
        -- Clear pallet list
        v_all_pallets_info.DELETE;
        all_trucks_hub.DELETE;
        
        -- Step 1: Load regular full pallets from priority_shift_pallets
        l_v_errstep := 'Loading regular pallets for sourcingid ' || p_sourcingid;
        
        FOR reg_pallet IN (
            SELECT 
                p.source, p.dest, p.transmode, p.u_variant_type_desc, 
                p.u_stackabilitytype, p.item, 
                p.pallets_qty,
                p.updated_wgt, p.schedshipdate, p.schedarrivdate, 
                p.sourcingid, p.sourcingid_seq, p.u_priority, p.sid, p.seqnum, 
                p.u_dispatchdate, p.ratio, p.sales_units_qty, p.recqty, 
                p.majorshipqty, p.minorshipqty, p.updated_mincap_su_pallets, 
                p.updated_maxcap_su_pallets, p.updated_mincap_su_pounds, 
                p.updated_maxcap_su_pounds, p.u_item_mintruckstackcap, 
                p.u_item_maxtruckstackcap, p.transleadtime, p.arrivcal, 
                p.shipcal, p.u_adjustedmaxcap, p.wgt, p.u_sourcingmin, 
                p.constrrecshipsw, p.availtoshipdate, p.needshipdate, 
                p.needarrivdate, p.color_priority_sourcingid_seq
            FROM 
                batchmgr.priority_shift_pallets p
            WHERE 
                sourcingid = p_sourcingid
                AND pallets_qty = 1  -- Only full pallets
            ORDER BY 
                color_priority_sourcingid_seq
        ) LOOP
            -- Skip invalid pallets
            --IF reg_pallet.updated_wgt <= 0 OR reg_pallet.u_stackabilitytype IS NULL THEN
            --    CONTINUE;
            --END IF;
            
            -- Add to our collection
            v_all_pallets_info.EXTEND;
            v_pallet_info := each_pallet_info();
            
            -- Basic fields
            v_pallet_info.source := reg_pallet.source;
            v_pallet_info.dest := reg_pallet.dest;
            v_pallet_info.transmode := reg_pallet.transmode;
            v_pallet_info.u_variant_type_desc := reg_pallet.u_variant_type_desc;
            v_pallet_info.u_stackabilitytype := reg_pallet.u_stackabilitytype;
            v_pallet_info.item := reg_pallet.item;
            v_pallet_info.pallets_qty := 1; -- One full pallet at a time
            v_pallet_info.weight := reg_pallet.ratio * reg_pallet.wgt; -- For internal usage
            v_pallet_info.schedshipdate := reg_pallet.schedshipdate;
            v_pallet_info.schedarrivdate := reg_pallet.schedarrivdate;
            v_pallet_info.sourcingid := reg_pallet.sourcingid;
            v_pallet_info.sourcingid_seq := reg_pallet.sourcingid_seq;
            v_pallet_info.u_priority := reg_pallet.u_priority;
            v_pallet_info.sid := reg_pallet.sid;
            v_pallet_info.seqnum := reg_pallet.seqnum;
            
            -- Additional fields
            v_pallet_info.u_dispatchdate := reg_pallet.u_dispatchdate;
            v_pallet_info.ratio := reg_pallet.ratio;
            v_pallet_info.sales_units_qty := reg_pallet.sales_units_qty;
            v_pallet_info.recqty := reg_pallet.recqty;
            v_pallet_info.majorshipqty := reg_pallet.majorshipqty;
            v_pallet_info.minorshipqty := reg_pallet.minorshipqty;
            v_pallet_info.updated_mincap_su_pallets := reg_pallet.updated_mincap_su_pallets;
            v_pallet_info.updated_maxcap_su_pallets := reg_pallet.updated_maxcap_su_pallets;
            v_pallet_info.updated_mincap_su_pounds := reg_pallet.updated_mincap_su_pounds;
            v_pallet_info.updated_maxcap_su_pounds := reg_pallet.updated_maxcap_su_pounds;
            v_pallet_info.u_item_mintruckstackcap := reg_pallet.u_item_mintruckstackcap;
            v_pallet_info.u_item_maxtruckstackcap := reg_pallet.u_item_maxtruckstackcap;
            v_pallet_info.transleadtime := reg_pallet.transleadtime;
            v_pallet_info.arrivcal := reg_pallet.arrivcal;
            v_pallet_info.shipcal := reg_pallet.shipcal;
            v_pallet_info.u_adjustedmaxcap := reg_pallet.u_adjustedmaxcap;
            v_pallet_info.wgt := reg_pallet.wgt;
            v_pallet_info.u_sourcingmin := reg_pallet.u_sourcingmin;
            v_pallet_info.constrrecshipsw := reg_pallet.constrrecshipsw;
            v_pallet_info.availtoshipdate := reg_pallet.availtoshipdate;
            v_pallet_info.needshipdate := reg_pallet.needshipdate;
            v_pallet_info.needarrivdate := reg_pallet.needarrivdate;
            
            -- Merged pallet specific fields with default values for regular pallets
            v_pallet_info.pallet_type := 'FULL';
            v_pallet_info.is_merged := 'N';
            v_pallet_info.merged_pallet_id := NULL;
            v_pallet_info.component_id := NULL;
            v_pallet_info.original_id := NULL;
            v_pallet_info.actual_quantity := reg_pallet.pallets_qty;
            v_pallet_info.is_split := 'N';
            v_pallet_info.is_component := 'N';
            v_pallet_info.parent_pallet_id := NULL;
            v_pallet_info.position_id := NULL;
            v_pallet_info.original_merged_id := NULL;
            v_pallet_info.is_standalone := 'N';
            v_pallet_info.actual_loaded_weight := reg_pallet.updated_wgt; -- Set final weight
            
            v_all_pallets_info(v_all_pallets_info.COUNT) := v_pallet_info;
        END LOOP;
        
        -- Step 2: Load merged pallets from merged_pallet_templates and components
        l_v_errstep := 'Loading merged pallets for sourcingid ' || p_sourcingid;
        
        BEGIN
            FOR merged_pallet IN (
                SELECT DISTINCT
                    t.id AS template_id,
                    c.source, c.dest, c.transmode, c.u_variant_type_desc, 
                    t.color AS u_stackabilitytype, t.primary_item AS item, 
                    t.total_quantity, t.total_weight, c.schedshipdate, c.schedarrivdate, 
                    t.sourcingid, c.sourcingid_seq, c.u_priority, c.sid, c.seqnum, 
                    c.u_dispatchdate, c.ratio, c.sales_units_qty, 
                    c.recqty, c.majorshipqty, c.minorshipqty,
                    c.updated_mincap_su_pallets, c.updated_maxcap_su_pallets,
                    c.updated_mincap_su_pounds, c.updated_maxcap_su_pounds,
                    c.u_item_mintruckstackcap, c.u_item_maxtruckstackcap,
                    c.transleadtime, c.arrivcal, c.shipcal, 
                    c.u_adjustedmaxcap, c.wgt, c.u_sourcingmin, 
                    c.constrrecshipsw, c.availtoshipdate, 
                    c.needshipdate, c.needarrivdate,
                    -- Merged pallet specific fields
                    t.merged_pallet_id, t.is_standalone, 
                    c.component_id,
                    c.color_seqn
                FROM 
                    batchmgr.merged_pallet_templates t
                JOIN 
                    batchmgr.merged_pallet_components c ON t.id = c.template_id AND c.component_id = 1
                /*
                JOIN
                    batchmgr.priority_shift_pallets p 
                on  p.source=c.source and 
                    p.dest=c.dest and 
                    p.transmode = c.transmode and 
                    p.u_variant_type_desc = c.u_variant_type_desc and 
                    p.u_stackabilitytype = c.color and 
                    p.item = c.item and 
                    p.schedshipdate = c.schedshipdate and 
                    p.schedarrivdate = c.schedarrivdate and 
                    p.sourcingid = c.sourcingid and 
                    p.sourcingid_seq = c.sourcingid_seq and 
                    p.condition = c.condition and 
                    p.u_priority = c.u_priority and 
                    p.sid = c.sid and 
                    p.seqnum = c.seqnum and 
                    p.ratio = c.ratio and 
                    p.recqty = c.recqty and 
                    p.wgt = c.wgt and 
                    p.u_sourcingmin = c.u_sourcingmin and 
                    p.color_priority_sourcingid_seq = c.color_seqn
                */
                WHERE 
                    t.sourcingid = p_sourcingid
                    AND t.condition = 'FIRST'
                    --AND p.pallets_qty > 0 and p.pallets_qty < 1
                    --AND t.is_physical_bin = 'Y'
                ORDER BY
                    color_seqn
            ) LOOP
                -- Skip invalid merged pallets
                IF merged_pallet.u_stackabilitytype IS NULL OR 
                   NVL(merged_pallet.total_weight, 0) <= 0 THEN
                    CONTINUE;
                END IF;
                
                -- Add to our collection
                v_all_pallets_info.EXTEND;
                v_pallet_info := each_pallet_info();
                
                -- Basic fields
                v_pallet_info.source := merged_pallet.source;
                v_pallet_info.dest := merged_pallet.dest;
                v_pallet_info.transmode := merged_pallet.transmode;
                v_pallet_info.u_variant_type_desc := merged_pallet.u_variant_type_desc;
                v_pallet_info.u_stackabilitytype := merged_pallet.u_stackabilitytype;
                v_pallet_info.item := merged_pallet.item;
                v_pallet_info.pallets_qty := 1; -- Treat as one pallet for truck building
                v_pallet_info.weight := merged_pallet.total_weight;
                v_pallet_info.schedshipdate := merged_pallet.schedshipdate;
                v_pallet_info.schedarrivdate := merged_pallet.schedarrivdate;
                v_pallet_info.sourcingid := merged_pallet.sourcingid;
                v_pallet_info.sourcingid_seq := merged_pallet.sourcingid_seq;
                v_pallet_info.u_priority := merged_pallet.u_priority;
                v_pallet_info.sid := merged_pallet.sid;
                v_pallet_info.seqnum := merged_pallet.seqnum;
                
                -- Additional fields
                v_pallet_info.u_dispatchdate := merged_pallet.u_dispatchdate;
                v_pallet_info.ratio := merged_pallet.ratio;
                v_pallet_info.sales_units_qty := merged_pallet.sales_units_qty;
                v_pallet_info.recqty := merged_pallet.recqty;
                v_pallet_info.majorshipqty := merged_pallet.majorshipqty;
                v_pallet_info.minorshipqty := merged_pallet.minorshipqty;
                v_pallet_info.updated_mincap_su_pallets := merged_pallet.updated_mincap_su_pallets;
                v_pallet_info.updated_maxcap_su_pallets := merged_pallet.updated_maxcap_su_pallets;
                v_pallet_info.updated_mincap_su_pounds := merged_pallet.updated_mincap_su_pounds;
                v_pallet_info.updated_maxcap_su_pounds := merged_pallet.updated_maxcap_su_pounds;
                v_pallet_info.u_item_mintruckstackcap := merged_pallet.u_item_mintruckstackcap;
                v_pallet_info.u_item_maxtruckstackcap := merged_pallet.u_item_maxtruckstackcap;
                v_pallet_info.transleadtime := merged_pallet.transleadtime;
                v_pallet_info.arrivcal := merged_pallet.arrivcal;
                v_pallet_info.shipcal := merged_pallet.shipcal;
                v_pallet_info.u_adjustedmaxcap := merged_pallet.u_adjustedmaxcap;
                v_pallet_info.wgt := merged_pallet.wgt;
                v_pallet_info.u_sourcingmin := merged_pallet.u_sourcingmin;
                v_pallet_info.constrrecshipsw := merged_pallet.constrrecshipsw;
                v_pallet_info.availtoshipdate := merged_pallet.availtoshipdate;
                v_pallet_info.needshipdate := merged_pallet.needshipdate;
                v_pallet_info.needarrivdate := merged_pallet.needarrivdate;
                
                -- Merged pallet specific fields
                v_pallet_info.pallet_type := CASE WHEN merged_pallet.is_standalone = 'Y' THEN 'STANDALONE' ELSE 'MERGED' END;
                v_pallet_info.is_merged := 'Y';
                v_pallet_info.merged_pallet_id := merged_pallet.merged_pallet_id;
                v_pallet_info.component_id := merged_pallet.component_id;
                v_pallet_info.original_id := NULL;
                v_pallet_info.actual_quantity := merged_pallet.total_quantity;
                v_pallet_info.is_split := 'N';
                v_pallet_info.is_component := 'N'; -- This is the parent record
                v_pallet_info.parent_pallet_id := NULL;
                v_pallet_info.position_id := NULL; -- Will be set during positioning
                v_pallet_info.original_merged_id := merged_pallet.template_id;
                v_pallet_info.is_standalone := merged_pallet.is_standalone;
                v_pallet_info.actual_loaded_weight := merged_pallet.total_weight;
                
                v_all_pallets_info(v_all_pallets_info.COUNT) := v_pallet_info;
            END LOOP;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- This is not an error, just means no merged pallets
                NULL;
            WHEN OTHERS THEN
                v_function_name := 'Loading merged pallets';
                v_error_message := SQLERRM;
                l_v_errstep := 'Error ' || v_function_name || ': ' || v_error_message;
                RAISE_APPLICATION_ERROR(-20003, 'Error in ' || v_function_name || ': ' || v_error_message);
        END;
        
        -- Step 3: Sort pallets by color priority
        l_v_errstep := 'Sorting pallets by color priority';
        --dbms_output.put_line('BEFORE SORT: First pallet type=' || v_all_pallets_info(1).u_stackabilitytype);
        
        BEGIN
            IF v_all_pallets_info.COUNT > 1 THEN
                -- Use the quicksort implementation for better performance
                hub_color_sort(
                    p_pallets => v_all_pallets_info,
                    p_low => 1,
                    p_high => v_all_pallets_info.COUNT,
                    p_color_priority => v_local_color_priority
                );
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                -- If sorting fails, log but continue with unsorted list
                l_v_errstep := 'Warning: Sorting failed, continuing with unsorted list: ' || SQLERRM;
        END;
        
        /*
        -- demand visualization
        DECLARE
            v_stackability_counts VARCHAR2(1000);
            v_ss_count NUMBER := 0;
            v_ds_count NUMBER := 0;
            v_red_count NUMBER := 0;
            v_black_count NUMBER := 0;
            v_green_count NUMBER := 0;
            v_yellow_count NUMBER := 0;
            v_other_count NUMBER := 0;
            v_current_color VARCHAR2(20) := '';
            v_color_transitions NUMBER := 0;
        BEGIN
            dbms_output.put_line('=====================================================');
            dbms_output.put_line('PALLET SORTING ANALYSIS - BEFORE TRUCK BUILDING');
            dbms_output.put_line('=====================================================');
            dbms_output.put_line('IDX | STACK_TYPE | MERGED | WEIGHT    | MERGED_ID  | ITEM');
            dbms_output.put_line('----|------------|--------|-----------|------------|------------------');
            
            -- Output each pallet's details and count by type
            FOR i IN 1..v_all_pallets_info.COUNT LOOP
                -- Track color transitions to verify sorting
                IF v_current_color != v_all_pallets_info(i).u_stackabilitytype THEN
                    v_color_transitions := v_color_transitions + 1;
                    v_current_color := v_all_pallets_info(i).u_stackabilitytype;
                END IF;
                
                -- Count by type
                CASE v_all_pallets_info(i).u_stackabilitytype
                    WHEN 'SS' THEN v_ss_count := v_ss_count + 1;
                    WHEN 'DS' THEN v_ds_count := v_ds_count + 1;
                    WHEN 'RED' THEN v_red_count := v_red_count + 1;
                    WHEN 'BLACK' THEN v_black_count := v_black_count + 1;
                    WHEN 'GREEN' THEN v_green_count := v_green_count + 1;
                    WHEN 'YELLOW' THEN v_yellow_count := v_yellow_count + 1;
                    ELSE v_other_count := v_other_count + 1;
                END CASE;
                
                -- Format and display each pallet
                dbms_output.put_line(
                    LPAD(TO_CHAR(i), 3, ' ') || ' | ' ||
                    RPAD(NVL(v_all_pallets_info(i).u_stackabilitytype, 'NULL'), 10, ' ') || ' | ' ||
                    RPAD(NVL(v_all_pallets_info(i).is_merged, 'N'), 6, ' ') || ' | ' ||
                    LPAD(TO_CHAR(ROUND(NVL(v_all_pallets_info(i).weight, 0), 2)), 9, ' ') || ' | ' ||
                    LPAD(NVL(TO_CHAR(v_all_pallets_info(i).merged_pallet_id), 'N/A'), 10, ' ') || ' | ' ||
                    SUBSTR(NVL(v_all_pallets_info(i).item, 'N/A'), 1, 18)
                );
                
                -- After every 25 pallets, insert a separator for readability
                IF MOD(i, 25) = 0 THEN
                    dbms_output.put_line('----|------------|--------|-----------|------------|------------------');
                END IF;
            END LOOP;
            
            -- Build summary counts string
            v_stackability_counts := 
                'RED=' || v_red_count || 
                ', BLACK=' || v_black_count || 
                ', GREEN=' || v_green_count || 
                ', YELLOW=' || v_yellow_count || 
                ', DS=' || v_ds_count || 
                ', SS=' || v_ss_count || 
                ', OTHER=' || v_other_count;
            
            -- Output summary statistics
            dbms_output.put_line('=====================================================');
            dbms_output.put_line('SORTING SUMMARY:');
            dbms_output.put_line('Total pallets: ' || v_all_pallets_info.COUNT);
            dbms_output.put_line('Color transitions: ' || v_color_transitions);
            dbms_output.put_line('Counts by type: ' || v_stackability_counts);
            
            -- Check if SS pallets are all at the beginning (optimal sorting)
            IF v_ss_count > 0 THEN
                DECLARE
                    v_all_ss_at_beginning BOOLEAN := TRUE;
                    v_first_non_ss_idx NUMBER := 0;
                BEGIN
                    -- Find the first non-SS pallet
                    FOR i IN 1..v_all_pallets_info.COUNT LOOP
                        IF v_all_pallets_info(i).u_stackabilitytype != 'SS' THEN
                            v_first_non_ss_idx := i;
                            EXIT;
                        END IF;
                    END LOOP;
                    
                    -- Check if any SS pallets appear after this index
                    FOR i IN (v_first_non_ss_idx+1)..v_all_pallets_info.COUNT LOOP
                        IF v_all_pallets_info(i).u_stackabilitytype = 'SS' THEN
                            v_all_ss_at_beginning := FALSE;
                            EXIT;
                        END IF;
                    END LOOP;
                    
                    IF v_all_ss_at_beginning THEN
                        dbms_output.put_line('OPTIMAL: All SS pallets grouped at beginning.');
                    ELSE
                        dbms_output.put_line('WARNING: SS pallets are not all grouped at beginning!');
                    END IF;
                END;
            END IF;
            
            -- Check if merged pallets are interspersed with regular pallets
            DECLARE
                v_merged_count NUMBER := 0;
                v_regular_count NUMBER := 0;
                v_merged_spread NUMBER := 0; -- How many different positions have merged pallets
            BEGIN
                FOR i IN 1..v_all_pallets_info.COUNT LOOP
                    IF v_all_pallets_info(i).is_merged = 'Y' THEN
                        v_merged_count := v_merged_count + 1;
                        
                        -- Check if this position represents a new spread
                        IF i = 1 OR v_all_pallets_info(i-1).is_merged != 'Y' THEN
                            v_merged_spread := v_merged_spread + 1;
                        END IF;
                    ELSE
                        v_regular_count := v_regular_count + 1;
                    END IF;
                END LOOP;
                
                dbms_output.put_line('Merged pallets: ' || v_merged_count || 
                    ' (in ' || v_merged_spread || ' groups)');
                dbms_output.put_line('Regular pallets: ' || v_regular_count);
            END;
            
            dbms_output.put_line('=====================================================');
        END;
        
        dbms_output.put_line('AFTER SORT: First pallet type=' || v_all_pallets_info(1).u_stackabilitytype);
        */
        
        -- Step 4: Build trucks using the combined and sorted pallets
        l_v_errstep := 'Building trucks for sourcingid ' || p_sourcingid;
        
        -- Initialize truck building variables with correct capacities
        DECLARE
            v_max_bottom_capacity NUMBER := FLOOR(max_pallets / 2);
            v_max_top_capacity NUMBER := FLOOR(max_pallets / 2) - ventilation;
            v_bottom_count NUMBER := 0;
            v_top_count NUMBER := 0;
            v_current_bottom_idx NUMBER := 0;
            v_optimal_stacking BOOLEAN := FALSE;
            v_tried_positions NUMBER := 0;
            
        BEGIN
            /*
            DBMS_OUTPUT.PUT_LINE('=== TRUCK CAPACITY DEBUG ===');
            DBMS_OUTPUT.PUT_LINE('v_max_bottom_capacity: ' || v_max_bottom_capacity);
            DBMS_OUTPUT.PUT_LINE('v_max_top_capacity: ' || v_max_top_capacity);
            DBMS_OUTPUT.PUT_LINE('Expected bottom should be: ' || FLOOR(v_u_adjustedmaxcap / 2));
            DBMS_OUTPUT.PUT_LINE('Expected top should be: ' || (FLOOR(v_u_adjustedmaxcap / 2) - ventilation));
            */
            
            -- Initialize item constraint tracking for first truck
            p_vmi_init_item_constr;
            
            -- Debug log to verify initialization
            l_v_errstep := 'Initialized item constraint tracking for first truck';
            
            -- Process all pallets
            FOR i IN 1..v_all_pallets_info.COUNT LOOP
                -- Skip invalid pallets
                IF v_all_pallets_info(i).u_stackabilitytype IS NULL OR
                   NVL(v_all_pallets_info(i).weight, 0) <= 0 THEN
                    CONTINUE;
                END IF;
                
                /*
                DBMS_OUTPUT.PUT_LINE('=== PALLET ' || i || ' DEBUG ===');
                DBMS_OUTPUT.PUT_LINE('Current weight: ' || v_current_weight);
                DBMS_OUTPUT.PUT_LINE('Pallet weight: ' || v_all_pallets_info(i).weight);
                DBMS_OUTPUT.PUT_LINE('Total if added: ' || (v_current_weight + v_all_pallets_info(i).weight));
                DBMS_OUTPUT.PUT_LINE('Max weight limit: ' || max_weight);
                DBMS_OUTPUT.PUT_LINE('Bottom count: ' || v_bottom_count || '/' || v_max_bottom_capacity);
                DBMS_OUTPUT.PUT_LINE('Top count: ' || v_top_count || '/' || v_max_top_capacity);
                */
                
                -- Check if new truck needed - using correct capacity calculations
                IF (v_current_weight + v_all_pallets_info(i).weight > max_weight) OR 
                   (v_bottom_count >= v_max_bottom_capacity AND v_top_count >= v_max_top_capacity) THEN
                    -- Store current truck info
                    all_trucks_hub(v_truck_number).bottom_row := v_bottom_row;
                    all_trucks_hub(v_truck_number).top_row := v_top_row;
                    all_trucks_hub(v_truck_number).bottom_info := v_bottom_info;
                    all_trucks_hub(v_truck_number).top_info := v_top_info;
                    all_trucks_hub(v_truck_number).utilization := f_vmi_calculate_utilization_hub(
                        v_bottom_row, v_top_row, max_pallets
                    );
        
                    -- Start a new truck
                    v_truck_number := v_truck_number + 1;
                    v_current_weight := 0;
                    v_bottom_count := 0;
                    v_top_count := 0;
                    v_current_bottom_idx := 0;
                    v_bottom_row := sys.odcivarchar2list();
                    v_top_row := sys.odcivarchar2list();
                    v_bottom_info := pallet_list_info();
                    v_top_info := pallet_list_info();
                    
                    -- Reset item constraint tracking for new truck
                    p_vmi_init_item_constr;
                END IF;
        
                -- IMPORTANT IMPROVEMENT: Try to find optimal stacking position first
                -- Look for existing bottom positions where this pallet can be stacked
                v_optimal_stacking := FALSE;
                v_tried_positions := 0;
                
                -- Only try to stack if this isn't a SS or RED pallet
                IF v_all_pallets_info(i).u_stackabilitytype NOT IN ('SS', 'RED') THEN
                    -- Scan existing bottom row positions for stacking possibilities
                    FOR j IN 1..v_bottom_row.COUNT LOOP
                        -- Skip positions that already have a top pallet
                        IF v_top_row(j) = 'EMPTY' THEN
                            -- Check if we can stack on this position
                            BEGIN
                                v_can_stack := f_vmi_can_stack_hub(v_bottom_row(j), 
                                                             v_all_pallets_info(i).u_stackabilitytype);
                                
                                -- Check weight capacity
                                v_weight_capacity := (v_current_weight + NVL(v_all_pallets_info(i).weight, 0) <= max_weight);
                                
                                -- Only consider ventilation-free positions
                                v_tried_positions := v_tried_positions + 1;
                                
                                IF v_can_stack AND v_weight_capacity AND j <= (v_max_bottom_capacity - ventilation) THEN
                                    -- Found an optimal position for stacking
                                    v_optimal_stacking := TRUE;
                                    
                                    -- Update weight and position information
                                    v_current_weight := v_current_weight + v_all_pallets_info(i).weight;
                                    v_top_count := v_top_count + 1;
                                    
                                    -- Set the top position
                                    v_top_row(j) := v_all_pallets_info(i).u_stackabilitytype;
                                    
                                    -- Track this item type for truck constraints
                                    p_vmi_update_truck_item_capacity(v_all_pallets_info(i).u_stackabilitytype);
                                    
                                    -- Ensure top_info is properly sized
                                    IF v_top_info.COUNT < j THEN
                                        v_top_info.EXTEND(j - v_top_info.COUNT);
                                    END IF;
                                    
                                    v_top_info(j) := v_all_pallets_info(i);
                                    
                                    -- Position merged pallets
                                    IF v_all_pallets_info(i).is_merged = 'Y' AND 
                                       v_all_pallets_info(i).merged_pallet_id IS NOT NULL THEN
                                        BEGIN
                                            p_vmi_create_positioned_pallet(
                                                p_sourcingid => p_sourcingid,
                                                p_condition => 'FIRST',
                                                p_color => v_all_pallets_info(i).u_stackabilitytype,
                                                p_merged_pallet_id => v_all_pallets_info(i).merged_pallet_id,
                                                p_loadid => v_truck_number,
                                                p_load_sequence => j,
                                                p_stack_position => 'top',
                                                p_position_id => v_position_id,
                                                p_is_standalone => v_all_pallets_info(i).is_standalone
                                            );
                                            v_top_info(j).position_id := v_position_id;
                                        EXCEPTION
                                            WHEN OTHERS THEN
                                                l_v_errstep := 'Warning: Positioning failed for stacked pallet: ' || SQLERRM;
                                        END;
                                    END IF;
                                    
                                    EXIT; -- Found a position, exit the loop
                                END IF;
                            EXCEPTION
                                WHEN OTHERS THEN
                                    v_can_stack := FALSE;
                                    l_v_errstep := 'Warning: Stacking check failed: ' || SQLERRM;
                            END;
                        END IF;
                    END LOOP;
                END IF;
                
                -- If we couldn't find an optimal stacking position, place on bottom row if space
                IF NOT v_optimal_stacking THEN
                    -- First priority: Place on bottom row if space available
                    IF v_bottom_count < v_max_bottom_capacity THEN
                        -- Check if adding this pallet would exceed weight capacity
                        IF v_current_weight + v_all_pallets_info(i).weight <= max_weight THEN
                            -- Add to bottom row
                            v_bottom_count := v_bottom_count + 1;
                            v_current_bottom_idx := v_bottom_count;
                            v_current_weight := v_current_weight + v_all_pallets_info(i).weight;
                            
                            v_bottom_row.extend;
                            v_bottom_row(v_bottom_row.count) := v_all_pallets_info(i).u_stackabilitytype;
                            
                            -- Track this item type for truck constraints
                            p_vmi_update_truck_item_capacity(v_all_pallets_info(i).u_stackabilitytype);
                            
                            -- Clone the pallet info for bottom row
                            v_bottom_info.extend;
                            v_bottom_info(v_bottom_info.count) := v_all_pallets_info(i);
                            
                            -- For merged pallets, create positioned pallet record
                            IF v_all_pallets_info(i).is_merged = 'Y' AND 
                               v_all_pallets_info(i).merged_pallet_id IS NOT NULL THEN
                                BEGIN
                                    p_vmi_create_positioned_pallet(
                                        p_sourcingid => p_sourcingid,
                                        p_condition => 'FIRST',
                                        p_color => v_all_pallets_info(i).u_stackabilitytype,
                                        p_merged_pallet_id => v_all_pallets_info(i).merged_pallet_id,
                                        p_loadid => v_truck_number,
                                        p_load_sequence => v_bottom_row.count,
                                        p_stack_position => 'bottom',
                                        p_position_id => v_position_id,
                                        p_is_standalone => v_all_pallets_info(i).is_standalone
                                    );
                                    
                                    v_bottom_info(v_bottom_info.count).position_id := v_position_id;
                                EXCEPTION
                                    WHEN OTHERS THEN
                                        l_v_errstep := 'Warning: Positioning failed for bottom pallet: ' || SQLERRM;
                                END;
                            END IF;
                            
                            -- Initialize top row position
                            v_top_row.extend;
                            IF v_all_pallets_info(i).u_stackabilitytype IN ('SS', 'RED') OR
                               v_bottom_count > (v_max_bottom_capacity - ventilation) THEN
                                v_top_row(v_top_row.count) := 'unavailable';
                            ELSE
                                v_top_row(v_top_row.count) := 'EMPTY';
                            END IF;
                        ELSE
                            -- Start a new truck if we exceed weight capacity
                            all_trucks_hub(v_truck_number).bottom_row := v_bottom_row;
                            all_trucks_hub(v_truck_number).top_row := v_top_row;
                            all_trucks_hub(v_truck_number).bottom_info := v_bottom_info;
                            all_trucks_hub(v_truck_number).top_info := v_top_info;
                            all_trucks_hub(v_truck_number).utilization := f_vmi_calculate_utilization_hub(
                                v_bottom_row, v_top_row, max_pallets
                            );
                            
                            -- Initialize new truck
                            v_truck_number := v_truck_number + 1;
                            v_current_weight := v_all_pallets_info(i).weight;
                            v_bottom_count := 1;
                            v_top_count := 0;
                            v_current_bottom_idx := 1;
                            
                            -- Create new truck arrays
                            v_bottom_row := sys.odcivarchar2list();
                            v_top_row := sys.odcivarchar2list();
                            v_bottom_info := pallet_list_info();
                            v_top_info := pallet_list_info();
                            
                            -- Reset item constraint tracking for new truck
                            p_vmi_init_item_constr;
                            
                            -- Add current pallet to bottom row
                            v_bottom_row.extend;
                            v_bottom_row(1) := v_all_pallets_info(i).u_stackabilitytype;
                            
                            -- Initialize top row
                            v_top_row.extend;
                            IF v_all_pallets_info(i).u_stackabilitytype IN ('SS', 'RED') THEN
                                v_top_row(1) := 'unavailable';
                            ELSE
                                v_top_row(1) := 'EMPTY';
                            END IF;
                            
                            -- Add pallet info
                            v_bottom_info.extend;
                            v_bottom_info(1) := v_all_pallets_info(i);
                            
                            -- Position merged pallets
                            IF v_all_pallets_info(i).is_merged = 'Y' AND 
                               v_all_pallets_info(i).merged_pallet_id IS NOT NULL THEN
                                BEGIN
                                    p_vmi_create_positioned_pallet(
                                        p_sourcingid => p_sourcingid,
                                        p_condition => 'FIRST',
                                        p_color => v_all_pallets_info(i).u_stackabilitytype,
                                        p_merged_pallet_id => v_all_pallets_info(i).merged_pallet_id,
                                        p_loadid => v_truck_number,
                                        p_load_sequence => 1,
                                        p_stack_position => 'bottom',
                                        p_position_id => v_position_id,
                                        p_is_standalone => v_all_pallets_info(i).is_standalone
                                    );
                                    v_bottom_info(1).position_id := v_position_id;
                                EXCEPTION
                                    WHEN OTHERS THEN
                                        l_v_errstep := 'Warning: Positioning failed for new truck: ' || SQLERRM;
                                END;
                            END IF;
                        END IF;
                    ELSE
                        -- Bottom row is full, start a new truck
                        all_trucks_hub(v_truck_number).bottom_row := v_bottom_row;
                        all_trucks_hub(v_truck_number).top_row := v_top_row;
                        all_trucks_hub(v_truck_number).bottom_info := v_bottom_info;
                        all_trucks_hub(v_truck_number).top_info := v_top_info;
                        all_trucks_hub(v_truck_number).utilization := f_vmi_calculate_utilization_hub(
                            v_bottom_row, v_top_row, max_pallets
                        );
                        
                        -- Initialize new truck
                        v_truck_number := v_truck_number + 1;
                        v_current_weight := v_all_pallets_info(i).weight;
                        v_bottom_count := 1;
                        v_top_count := 0;
                        v_current_bottom_idx := 1;
                        
                        -- Create new truck arrays
                        v_bottom_row := sys.odcivarchar2list();
                        v_top_row := sys.odcivarchar2list();
                        v_bottom_info := pallet_list_info();
                        v_top_info := pallet_list_info();
                        
                        -- Add current pallet to bottom row
                        v_bottom_row.extend;
                        v_bottom_row(1) := v_all_pallets_info(i).u_stackabilitytype;
                        
                        -- Initialize top row
                        v_top_row.extend;
                        IF v_all_pallets_info(i).u_stackabilitytype IN ('SS', 'RED') THEN
                            v_top_row(1) := 'unavailable';
                        ELSE
                            v_top_row(1) := 'EMPTY';
                        END IF;
                        
                        -- Add pallet info
                        v_bottom_info.extend;
                        v_bottom_info(1) := v_all_pallets_info(i);
                        
                        -- Position merged pallets
                        IF v_all_pallets_info(i).is_merged = 'Y' AND 
                           v_all_pallets_info(i).merged_pallet_id IS NOT NULL THEN
                            BEGIN
                                p_vmi_create_positioned_pallet(
                                    p_sourcingid => p_sourcingid,
                                    p_condition => 'FIRST',
                                    p_color => v_all_pallets_info(i).u_stackabilitytype,
                                    p_merged_pallet_id => v_all_pallets_info(i).merged_pallet_id,
                                    p_loadid => v_truck_number,
                                    p_load_sequence => 1,
                                    p_stack_position => 'bottom',
                                    p_position_id => v_position_id,
                                    p_is_standalone => v_all_pallets_info(i).is_standalone
                                );
                                v_bottom_info(1).position_id := v_position_id;
                            EXCEPTION
                                WHEN OTHERS THEN
                                    l_v_errstep := 'Warning: Positioning failed for new truck: ' || SQLERRM;
                            END;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        
            -- Apply ventilation correctly to the top row
            FOR i IN 1..v_top_row.COUNT LOOP
                -- Apply ventilation only to the last 'ventilation' positions
                IF i > (v_max_bottom_capacity - ventilation) AND 
                   i <= v_max_bottom_capacity AND
                   v_top_row(i) = 'EMPTY' THEN
                    v_top_row(i) := 'unavailable';
                    
                    -- Clear any info
                    IF v_top_info.COUNT >= i THEN
                        v_top_info(i) := NULL;
                    END IF;
                END IF;
            END LOOP;
        END;
    
        -- Store last truck info
        all_trucks_hub(v_truck_number).bottom_row := v_bottom_row;
        all_trucks_hub(v_truck_number).top_row := v_top_row;
        all_trucks_hub(v_truck_number).bottom_info := v_bottom_info;
        all_trucks_hub(v_truck_number).top_info := v_top_info;
        all_trucks_hub(v_truck_number).utilization := f_vmi_calculate_utilization_hub(
            v_bottom_row, v_top_row, v_u_adjustedmaxcap
        );
    
        -- Store results in u_recship
        l_v_errstep := 'Storing results for ' || v_truck_number || ' trucks';
        p_vmi_store_results_for_all_trucks(p_sourcingid, v_truck_number, v_u_adjustedmaxcap);
    
        -- Logging
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time, 
            l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);
    
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, 
                l_v_errorid_in => SQLCODE, l_v_errormessage_in => SQLERRM, l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in => l_d_end_date_time, 
                l_v_progstatus_in => l_v_prog_status, l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_create_priority_shift_trucks;
    
    PROCEDURE p_vmi_store_results (
        p_sourcingid   NUMBER,
        p_truck_number NUMBER,
        p_bottom_row   IN sys.odcivarchar2list,
        p_top_row      IN sys.odcivarchar2list,
        p_bottom_info  IN pallet_list_info,
        p_top_info     IN pallet_list_info,
        p_utilization  NUMBER,
        p_condition    VARCHAR2,
        max_pallets    NUMBER
    ) IS
      -- define variables
        l_d_start_date_time   iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time     iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep           iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id                iio_interface_timing_log.id%TYPE;
    
        -- Initialize variables
        l_v_prog_name         scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_store_results';
        l_v_prog_status       scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency         scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_load_sequence       NUMBER := 1;
        v_u_sourcingmin       NUMBER;
        v_weight              NUMBER;
        v_total_weight        NUMBER := 0;
        v_total_pallets       NUMBER := 0;
        v_current_utilization NUMBER;
        v_template_id         NUMBER := NULL;
        v_component_count     NUMBER := 0;
        
        -- For merged pallet tracking
        v_merged_processed    SYS.ODCINUMBERLIST := SYS.ODCINUMBERLIST();
        
        CURSOR c_pallet_data (
            c_sourcingid     NUMBER,
            c_sourcingid_seq NUMBER
        ) IS
        SELECT
            *
        FROM
            (
                SELECT
                    p.*,
                    ROW_NUMBER()
                    OVER(PARTITION BY sourcingid, sourcingid_seq
                         ORDER BY
                             schedshipdate DESC
                    ) AS rn
                FROM
                    priority_shift_pallets p
                WHERE
                        sourcingid = c_sourcingid
                    AND sourcingid_seq = c_sourcingid_seq
            )
        WHERE
            rn = 1;
    
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
    
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');
    
        l_v_errstep := 'Calculate P_VMI_store_results';
    
        -- Process bottom and top rows
        FOR i IN 1..p_bottom_row.count LOOP
            -- Process bottom row pallets
            IF p_bottom_row(i) != 'EMPTY' THEN
                -- Fetch data from priority_shift_pallets         
                /*
                -- DEBUG: Check weight values before storing
                DBMS_OUTPUT.PUT_LINE('=== BOTTOM PALLET ' || i || ' WEIGHT DEBUG ===');
                DBMS_OUTPUT.PUT_LINE('Item: ' || p_bottom_info(i).item);
                DBMS_OUTPUT.PUT_LINE('Stackability: ' || p_bottom_info(i).u_stackabilitytype);
                DBMS_OUTPUT.PUT_LINE('Weight in pallet_info: ' || p_bottom_info(i).weight);
                DBMS_OUTPUT.PUT_LINE('Is merged: ' || p_bottom_info(i).is_merged);
                */
                
                -- For merged pallets, also check component weights
                IF v_template_id IS NOT NULL THEN
                    --DBMS_OUTPUT.PUT_LINE('MERGED PALLET - Components:');
                    FOR comp_rec IN (
                        SELECT c.item, c.weight, c.quantity
                        FROM batchmgr.merged_pallet_components c
                        WHERE c.template_id = v_template_id
                        ORDER BY c.component_id
                    ) LOOP
                        /*
                        DBMS_OUTPUT.PUT_LINE('  Component: ' || comp_rec.item || 
                                           ' Weight: ' || comp_rec.weight || 
                                           ' Qty: ' || comp_rec.quantity);
                        */
                        NULL;
                    END LOOP;
                END IF;
                
                -- Find if this is a merged pallet with a template
                v_template_id := NULL;
                
                -- If this pallet has a merged_pallet_id, then look up the template
                IF p_bottom_info(i).merged_pallet_id IS NOT NULL THEN
                    BEGIN
                        -- Try to get template using original_merged_id (which should have the template ID)
                        SELECT id INTO v_template_id
                        FROM batchmgr.merged_pallet_templates
                        WHERE sourcingid = p_sourcingid
                            AND condition = p_condition
                            AND color = p_bottom_info(i).u_stackabilitytype
                            AND merged_pallet_id = p_bottom_info(i).merged_pallet_id
                            AND ROWNUM = 1;
                        
                        -- If that fails, try using the original_merged_id directly
                        IF v_template_id IS NULL AND p_bottom_info(i).original_merged_id IS NOT NULL THEN
                            SELECT id INTO v_template_id
                            FROM batchmgr.merged_pallet_templates
                            WHERE id = p_bottom_info(i).original_merged_id
                                AND ROWNUM = 1;
                        END IF;
                        
                        --DBMS_OUTPUT.PUT_LINE('TEMPLATE_ID: ' || v_template_id);
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            v_template_id := NULL; -- Not a merged pallet with template
                    END;
                END IF;
                
                -- Now process based on whether it's a merged pallet with components or not
                IF v_template_id IS NOT NULL THEN
                    -- This is a merged pallet - insert all its components
                    v_component_count := 0;
                    
                    FOR comp_rec IN (
                        SELECT 
                            c.*,
                            t.color AS parent_color,
                            t.primary_item AS parent_item,
                            t.total_quantity AS total_quantity,
                            t.total_weight AS total_weight,
                            t.is_standalone AS is_standalone
                        FROM 
                            batchmgr.merged_pallet_components c
                            JOIN batchmgr.merged_pallet_templates t ON c.template_id = t.id
                        WHERE 
                            c.template_id = v_template_id
                        ORDER BY
                            c.component_id
                    ) LOOP
                        -- Insert component into u_recship - using the same load_sequence for all components
                        -- Also include merged pallet information in the insert
                        INSERT INTO batchmgr.u_recship (
                            sourcingid,
                            sourcingid_seq,
                            condition,
                            u_priority,
                            loadid,
                            load_sequence,
                            loaded,
                            utilization,
                            u_sourcingmin,
                            schedshipdate,
                            schedarrivdate,
                            source,
                            dest,
                            transmode,
                            u_variant_type_desc,
                            item,
                            u_stackabilitytype,
                            pallets_qty,
                            updated_wgt,
                            updated_mincap_su_pallets,
                            updated_maxcap_su_pallets,
                            updated_mincap_su_pounds,
                            updated_maxcap_su_pounds,
                            u_item_mintruckstackcap,
                            u_item_maxtruckstackcap,
                            sid,
                            seqnum,
                            stack_position,
                            u_dispatchdate,
                            ratio,
                            recqty,
                            sales_units_qty,
                            majorshipqty,
                            minorshipqty,
                            transleadtime, 
                            arrivcal,
                            shipcal,
                            u_adjustedmaxcap,
                            wgt,
                            constrrecshipsw, 
                            availtoshipdate,
                            needshipdate, 
                            needarrivdate,
                            status,
                            -- Additional merged pallet fields
                            is_merged,
                            component_id,
                            pallet_type,
                            parent_pallet_id,
                            is_component,
                            is_standalone,
                            position_id,
                            original_merged_id,
                            actual_quantity
                        ) VALUES (
                            comp_rec.sourcingid,
                            comp_rec.sourcingid_seq,
                            CASE
                                WHEN p_condition IN ('PRIORITY_SHIFT', 'FIRST') THEN 'FIRST'
                                ELSE p_condition
                            END,
                            comp_rec.u_priority,
                            p_truck_number,
                            v_load_sequence,     -- Same load_sequence for all components
                            'Y',
                            round(v_current_utilization, 2),
                            comp_rec.u_sourcingmin,
                            comp_rec.schedshipdate,
                            comp_rec.schedarrivdate,
                            comp_rec.source,
                            comp_rec.dest,
                            comp_rec.transmode,
                            comp_rec.u_variant_type_desc,
                            comp_rec.item,       -- Use component item, not parent
                            comp_rec.color,      -- Use component color
                            comp_rec.quantity,   -- Component quantity
                            comp_rec.weight,     -- Component weight (p_bottom_info(i).weight)
                            comp_rec.updated_mincap_su_pallets, -- p_bottom_info(i).updated_mincap_su_pallets,
                            comp_rec.updated_maxcap_su_pallets, -- p_bottom_info(i).updated_maxcap_su_pallets,
                            comp_rec.updated_mincap_su_pounds, -- p_bottom_info(i).updated_mincap_su_pounds,
                            comp_rec.updated_maxcap_su_pounds, -- p_bottom_info(i).updated_maxcap_su_pounds,
                            comp_rec.u_item_mintruckstackcap, -- p_bottom_info(i).u_item_mintruckstackcap,
                            comp_rec.u_item_maxtruckstackcap, -- p_bottom_info(i).u_item_maxtruckstackcap,
                            comp_rec.sid,
                            comp_rec.seqnum,
                            'bottom',           -- Always bottom for components in bottom row
                            p_bottom_info(i).u_dispatchdate,
                            comp_rec.ratio,
                            comp_rec.recqty,
                            comp_rec.sales_units_qty, -- p_bottom_info(i).sales_units_qty,
                            comp_rec.majorshipqty, -- p_bottom_info(i).majorshipqty,
                            comp_rec.minorshipqty, -- p_bottom_info(i).minorshipqty,
                            comp_rec.transleadtime, -- p_bottom_info(i).transleadtime,
                            comp_rec.arrivcal, -- p_bottom_info(i).arrivcal,
                            comp_rec.shipcal, -- p_bottom_info(i).shipcal,
                            comp_rec.u_adjustedmaxcap, -- p_bottom_info(i).u_adjustedmaxcap,
                            comp_rec.wgt,
                            comp_rec.constrrecshipsw, -- p_bottom_info(i).constrrecshipsw, 
                            comp_rec.availtoshipdate, -- p_bottom_info(i).availtoshipdate,
                            comp_rec.needshipdate, -- p_bottom_info(i).needshipdate, 
                            comp_rec.needarrivdate, -- p_bottom_info(i).needarrivdate,
                            'loaded',
                            -- Merged pallet specific fields
                            'Y',                           -- is_merged
                            comp_rec.component_id,         -- component_id
                            CASE WHEN comp_rec.is_standalone = 'Y' THEN 'STANDALONE' ELSE 'MERGED' END, -- pallet_type
                            p_bottom_info(i).merged_pallet_id, -- parent_pallet_id
                            'Y',                           -- is_component
                            comp_rec.is_standalone,        -- is_standalone
                            p_bottom_info(i).position_id,  -- position_id
                            comp_rec.template_id,          -- original_merged_id (template ID)
                            comp_rec.quantity             -- actual_quantity
                            --comp_rec.weight                -- total_weight
                        );
                        
                        v_component_count := v_component_count + 1;
                    END LOOP;
                    
                    -- Add the merged pallet ID to processed list
                    IF v_component_count > 0 THEN
                        v_merged_processed.EXTEND;
                        v_merged_processed(v_merged_processed.COUNT) := p_bottom_info(i).merged_pallet_id;
                    END IF;
                ELSE
                    -- Regular pallet - process normally
                    v_total_pallets := v_total_pallets + CASE WHEN p_bottom_info(i).u_stackabilitytype IN ('RED', 'SS') THEN 2 ELSE 1 END;
                    v_current_utilization := (v_total_pallets / max_pallets) * 100;
                    v_current_utilization := CASE WHEN v_current_utilization > 100 THEN 100 ELSE v_current_utilization END;
                    
                    INSERT INTO batchmgr.u_recship (
                        sourcingid,
                        sourcingid_seq,
                        condition,
                        u_priority,
                        loadid,
                        load_sequence,
                        loaded,
                        utilization,
                        u_sourcingmin,
                        schedshipdate,
                        schedarrivdate,
                        source,
                        dest,
                        transmode,
                        u_variant_type_desc,
                        item,
                        u_stackabilitytype,
                        pallets_qty,
                        updated_wgt,
                        updated_mincap_su_pallets,
                        updated_maxcap_su_pallets,
                        updated_mincap_su_pounds,
                        updated_maxcap_su_pounds,
                        u_item_mintruckstackcap,
                        u_item_maxtruckstackcap,
                        sid,
                        seqnum,
                        stack_position,
                        u_dispatchdate,
                        ratio,
                        recqty,
                        sales_units_qty,
                        majorshipqty,
                        minorshipqty,
                        transleadtime, 
                        arrivcal,
                        shipcal,
                        u_adjustedmaxcap,
                        wgt,
                        constrrecshipsw, 
                        availtoshipdate,
                        needshipdate, 
                        needarrivdate,
                        status,
                        is_merged,
                        pallet_type
                    ) VALUES (
                        p_sourcingid,
                        p_bottom_info(i).sourcingid_seq,
                        CASE
                            WHEN p_condition IN ('PRIORITY_SHIFT', 'FIRST') THEN 'FIRST'
                            ELSE p_condition
                        END,
                        p_bottom_info(i).u_priority,
                        p_truck_number,
                        v_load_sequence,
                        'Y',
                        round(v_current_utilization, 2),
                        p_bottom_info(i).u_sourcingmin,
                        p_bottom_info(i).schedshipdate,
                        p_bottom_info(i).schedarrivdate,
                        p_bottom_info(i).source,
                        p_bottom_info(i).dest,
                        p_bottom_info(i).transmode,
                        p_bottom_info(i).u_variant_type_desc,
                        p_bottom_info(i).item,
                        p_bottom_info(i).u_stackabilitytype,
                        p_bottom_info(i).pallets_qty,
                        p_bottom_info(i).actual_loaded_weight,
                        p_bottom_info(i).updated_mincap_su_pallets,
                        p_bottom_info(i).updated_maxcap_su_pallets,
                        p_bottom_info(i).updated_mincap_su_pounds,
                        p_bottom_info(i).updated_maxcap_su_pounds,
                        p_bottom_info(i).u_item_mintruckstackcap,
                        p_bottom_info(i).u_item_maxtruckstackcap,
                        p_bottom_info(i).sid,
                        p_bottom_info(i).seqnum,
                        'bottom',
                        p_bottom_info(i).u_dispatchdate,
                        p_bottom_info(i).ratio,
                        p_bottom_info(i).recqty,
                        p_bottom_info(i).sales_units_qty,
                        p_bottom_info(i).majorshipqty,
                        p_bottom_info(i).minorshipqty,
                        p_bottom_info(i).transleadtime,
                        p_bottom_info(i).arrivcal,
                        p_bottom_info(i).shipcal,
                        p_bottom_info(i).u_adjustedmaxcap,
                        p_bottom_info(i).wgt,
                        p_bottom_info(i).constrrecshipsw, 
                        p_bottom_info(i).availtoshipdate,
                        p_bottom_info(i).needshipdate, 
                        p_bottom_info(i).needarrivdate,
                        'loaded',
                        'N',         -- is_merged
                        'FULL'       -- pallet_type
                    );
                END IF;
            END IF;
    
            -- Process top row pallets
            IF p_top_row(i) NOT IN ('EMPTY', 'unavailable') THEN
                -- Fetch data from priority_shift_pallets
                -- Find if this is a merged pallet with a template
                v_template_id := NULL;
                
                -- If this pallet has a merged_pallet_id and hasn't been processed yet
                IF p_top_info(i).merged_pallet_id IS NOT NULL THEN
                    -- Check if already processed from bottom row
                    DECLARE
                        v_already_processed BOOLEAN := FALSE;
                    BEGIN
                        FOR j IN 1..v_merged_processed.COUNT LOOP
                            IF v_merged_processed(j) = p_top_info(i).merged_pallet_id THEN
                                v_already_processed := TRUE;
                                EXIT;
                            END IF;
                        END LOOP;
                        
                        IF NOT v_already_processed THEN
                            BEGIN
                                -- Try to get template ID
                                SELECT id INTO v_template_id
                                FROM batchmgr.merged_pallet_templates
                                WHERE sourcingid = p_sourcingid
                                    AND condition = p_condition
                                    AND color = p_top_info(i).u_stackabilitytype
                                    AND merged_pallet_id = p_top_info(i).merged_pallet_id
                                    AND ROWNUM = 1;
                                    
                                -- If that fails, try using the original_merged_id directly
                                IF v_template_id IS NULL AND p_top_info(i).original_merged_id IS NOT NULL THEN
                                    SELECT id INTO v_template_id
                                    FROM batchmgr.merged_pallet_templates
                                    WHERE id = p_top_info(i).original_merged_id
                                        AND ROWNUM = 1;
                                END IF;
                            EXCEPTION
                                WHEN NO_DATA_FOUND THEN
                                    v_template_id := NULL; -- Not a merged pallet with template
                            END;
                        END IF;
                    END;
                END IF;
                
                -- Process merged pallet or regular pallet
                IF v_template_id IS NOT NULL THEN
                    -- This is a merged pallet - insert all its components
                    v_component_count := 0;
                    
                    FOR comp_rec IN (
                        SELECT 
                            c.*,
                            t.color AS parent_color,
                            t.primary_item AS parent_item,
                            t.total_quantity AS total_quantity,
                            t.total_weight AS total_weight,
                            t.is_standalone AS is_standalone
                        FROM 
                            batchmgr.merged_pallet_components c
                            JOIN batchmgr.merged_pallet_templates t ON c.template_id = t.id
                        WHERE 
                            c.template_id = v_template_id
                        ORDER BY
                            c.component_id
                    ) LOOP
                        -- Insert component with same load_sequence
                        INSERT INTO batchmgr.u_recship (
                            sourcingid,
                            sourcingid_seq,
                            condition,
                            u_priority,
                            loadid,
                            load_sequence,
                            loaded,
                            utilization,
                            u_sourcingmin,
                            schedshipdate,
                            schedarrivdate,
                            source,
                            dest,
                            transmode,
                            u_variant_type_desc,
                            item,
                            u_stackabilitytype,
                            pallets_qty,
                            updated_wgt,
                            updated_mincap_su_pallets,
                            updated_maxcap_su_pallets,
                            updated_mincap_su_pounds,
                            updated_maxcap_su_pounds,
                            u_item_mintruckstackcap,
                            u_item_maxtruckstackcap,
                            sid,
                            seqnum,
                            stack_position,
                            u_dispatchdate,
                            ratio,
                            recqty,
                            sales_units_qty,
                            majorshipqty,
                            minorshipqty,
                            transleadtime, 
                            arrivcal,
                            shipcal,
                            u_adjustedmaxcap,
                            wgt,
                            constrrecshipsw, 
                            availtoshipdate,
                            needshipdate, 
                            needarrivdate,
                            status,
                            -- Additional merged pallet fields
                            is_merged,
                            component_id,
                            pallet_type,
                            parent_pallet_id,
                            is_component,
                            is_standalone,
                            position_id,
                            original_merged_id,
                            actual_quantity
                        ) VALUES (
                            comp_rec.sourcingid,
                            comp_rec.sourcingid_seq,
                            CASE
                                WHEN p_condition IN ('PRIORITY_SHIFT', 'FIRST') THEN 'FIRST'
                                ELSE p_condition
                            END,
                            comp_rec.u_priority,
                            p_truck_number,
                            v_load_sequence,     -- Same load_sequence for all components
                            'Y',
                            round(v_current_utilization, 2),
                            comp_rec.u_sourcingmin,
                            comp_rec.schedshipdate,
                            comp_rec.schedarrivdate,
                            comp_rec.source,
                            comp_rec.dest,
                            comp_rec.transmode,
                            comp_rec.u_variant_type_desc,
                            comp_rec.item,       -- Use component item
                            comp_rec.color,      -- Use component color
                            comp_rec.quantity,   -- Component quantity
                            comp_rec.weight,     -- Component weight (p_top_info(i).weight)
                            comp_rec.updated_mincap_su_pallets, -- p_top_info(i).updated_mincap_su_pallets,
                            comp_rec.updated_maxcap_su_pallets, -- p_top_info(i).updated_maxcap_su_pallets,
                            comp_rec.updated_mincap_su_pounds, -- p_top_info(i).updated_mincap_su_pounds,
                            comp_rec.updated_maxcap_su_pounds, -- p_top_info(i).updated_maxcap_su_pounds,
                            comp_rec.u_item_mintruckstackcap, -- p_top_info(i).u_item_mintruckstackcap,
                            comp_rec.u_item_maxtruckstackcap, -- p_top_info(i).u_item_maxtruckstackcap,
                            comp_rec.sid,
                            comp_rec.seqnum,
                            'top',               -- Always top for components in top row
                            comp_rec.u_dispatchdate, -- p_top_info(i).u_dispatchdate,
                            comp_rec.ratio,
                            comp_rec.recqty,
                            comp_rec.sales_units_qty, -- p_top_info(i).sales_units_qty,
                            comp_rec.majorshipqty, -- p_top_info(i).majorshipqty,
                            comp_rec.minorshipqty, -- p_top_info(i).minorshipqty,
                            comp_rec.transleadtime, -- p_top_info(i).transleadtime,
                            comp_rec.arrivcal, -- p_top_info(i).arrivcal,
                            comp_rec.shipcal, -- p_top_info(i).shipcal,
                            comp_rec.u_adjustedmaxcap, -- p_top_info(i).u_adjustedmaxcap,
                            comp_rec.wgt,
                            comp_rec.constrrecshipsw, -- p_top_info(i).constrrecshipsw, 
                            comp_rec.availtoshipdate, -- p_top_info(i).availtoshipdate,
                            comp_rec.needshipdate, -- p_top_info(i).needshipdate, 
                            comp_rec.needarrivdate, -- p_top_info(i).needarrivdate,
                            'loaded',
                            -- Merged pallet specific fields
                            'Y',                         -- is_merged
                            comp_rec.component_id,       -- component_id
                            CASE WHEN comp_rec.is_standalone = 'Y' THEN 'STANDALONE' ELSE 'MERGED' END, -- pallet_type
                            p_top_info(i).merged_pallet_id, -- parent_pallet_id
                            'Y',                         -- is_component
                            comp_rec.is_standalone,      -- is_standalone
                            p_top_info(i).position_id,   -- position_id
                            comp_rec.template_id,        -- original_merged_id (template ID)
                            comp_rec.quantity           -- actual_quantity
                            --comp_rec.weight              -- total_weight
                        );
                        
                        v_component_count := v_component_count + 1;
                    END LOOP;
                    
                    -- Add the merged pallet ID to processed list
                    IF v_component_count > 0 THEN
                        v_merged_processed.EXTEND;
                        v_merged_processed(v_merged_processed.COUNT) := p_top_info(i).merged_pallet_id;
                    END IF;
                ELSE
                    -- Regular pallet - process normally
                    v_total_pallets := v_total_pallets + CASE WHEN p_top_info(i).u_stackabilitytype IN ('RED', 'SS') THEN 2 ELSE 1 END;
                    v_current_utilization := (v_total_pallets / max_pallets) * 100;
                    v_current_utilization := CASE WHEN v_current_utilization > 100 THEN 100 ELSE v_current_utilization END;
                    
                    INSERT INTO batchmgr.u_recship (
                        sourcingid,
                        sourcingid_seq,
                        condition,
                        u_priority,
                        loadid,
                        load_sequence,
                        loaded,
                        utilization,
                        u_sourcingmin,
                        schedshipdate,
                        schedarrivdate,
                        source,
                        dest,
                        transmode,
                        u_variant_type_desc,
                        item,
                        u_stackabilitytype,
                        pallets_qty,
                        updated_wgt,
                        updated_mincap_su_pallets,
                        updated_maxcap_su_pallets,
                        updated_mincap_su_pounds,
                        updated_maxcap_su_pounds,
                        u_item_mintruckstackcap,
                        u_item_maxtruckstackcap,
                        sid,
                        seqnum,
                        stack_position,
                        u_dispatchdate,
                        ratio,
                        recqty,
                        sales_units_qty,
                        majorshipqty,
                        minorshipqty,
                        transleadtime,
                        arrivcal,
                        shipcal,
                        u_adjustedmaxcap,
                        wgt,
                        constrrecshipsw, 
                        availtoshipdate,
                        needshipdate, 
                        needarrivdate,
                        status,
                        is_merged,
                        pallet_type
                    ) VALUES (
                        p_sourcingid,
                        p_top_info(i).sourcingid_seq,
                        CASE
                            WHEN p_condition IN ('PRIORITY_SHIFT', 'FIRST') THEN 'FIRST'
                            ELSE p_condition
                        END,
                        p_top_info(i).u_priority,
                        p_truck_number,
                        v_load_sequence,
                        'Y',
                        round(v_current_utilization, 2),
                        p_top_info(i).u_sourcingmin,
                        p_top_info(i).schedshipdate,
                        p_top_info(i).schedarrivdate,
                        p_top_info(i).source,
                        p_top_info(i).dest,
                        p_top_info(i).transmode,
                        p_top_info(i).u_variant_type_desc,
                        p_top_info(i).item,
                        p_top_info(i).u_stackabilitytype,
                        p_top_info(i).pallets_qty,
                        p_top_info(i).actual_loaded_weight,
                        p_top_info(i).updated_mincap_su_pallets,
                        p_top_info(i).updated_maxcap_su_pallets,
                        p_top_info(i).updated_mincap_su_pounds,
                        p_top_info(i).updated_maxcap_su_pounds,
                        p_top_info(i).u_item_mintruckstackcap,
                        p_top_info(i).u_item_maxtruckstackcap,
                        p_top_info(i).sid,
                        p_top_info(i).seqnum,
                        'top',
                        p_top_info(i).u_dispatchdate,
                        p_top_info(i).ratio,
                        p_top_info(i).recqty,
                        p_top_info(i).sales_units_qty,
                        p_top_info(i).majorshipqty,
                        p_top_info(i).minorshipqty,
                        p_top_info(i).transleadtime,
                        p_top_info(i).arrivcal,
                        p_top_info(i).shipcal,
                        p_top_info(i).u_adjustedmaxcap,
                        p_top_info(i).wgt,
                        p_top_info(i).constrrecshipsw, 
                        p_top_info(i).availtoshipdate,
                        p_top_info(i).needshipdate, 
                        p_top_info(i).needarrivdate,
                        'loaded',
                        'N',         -- is_merged
                        'FULL'       -- pallet_type
                    );
                END IF;
            END IF;
    
            -- Increment load sequence for the next position
            v_load_sequence := v_load_sequence + 1;
        END LOOP;
    
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
    
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
            l_d_startdatetime_in => l_d_start_date_time, 
            l_d_enddatetime_in => l_d_end_date_time, 
            l_v_progstatus_in => l_v_prog_status,
            l_v_frequency_in => l_v_frequency);
    
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                l_d_datetime_in => sysdate, 
                l_v_errorid_in => sqlcode, 
                l_v_errormessage_in => sqlerrm, 
                l_v_errorrecord_in => NULL,
                l_v_errorstep_in => l_v_errstep, 
                l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                l_d_startdatetime_in => l_d_start_date_time, 
                l_d_enddatetime_in => l_d_end_date_time, 
                l_v_progstatus_in => l_v_prog_status,
                l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_store_results;
    
    PROCEDURE p_vmi_store_results_for_all_trucks (
        p_sourcingid   NUMBER,
        p_total_trucks NUMBER,
        max_pallets    NUMBER
    ) IS
    /******************************************************************
      Procedure : P_VMI_store_results_for_all_trucks
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_store_results_for_all_trucks';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;

      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_store_results_for_all_trucks';

         -- Delete only the records with 'conversion' status
        DELETE FROM batchmgr.u_recship
        WHERE
                sourcingid = p_sourcingid
            AND status = 'conversion';

        FOR i IN 1..p_total_trucks LOOP
            p_vmi_store_results(p_sourcingid, i, all_trucks_hub(i).bottom_row, all_trucks_hub(i).top_row, all_trucks_hub(i).bottom_info,
                               all_trucks_hub(i).top_info, all_trucks_hub(i).utilization, 'FIRST', max_pallets);
        END LOOP;
    -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';

      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);

      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_store_results_for_all_trucks;
    
    PROCEDURE p_vmi_update_salesunits_qty_sourcing IS
        -- Standard variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
    
        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_UPDATE_SALESUNITS_QTY_SOURCING';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- Statistics variables
        v_groups_processed NUMBER := 0;
        v_records_updated NUMBER := 0;
        v_null_ratio_count NUMBER := 0;
        v_discrepancy_count NUMBER := 0;
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                      l_d_startdatetime_in => l_d_start_date_time, 
                                      l_v_progstatus_in => 'Started..');
    
        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Initialize Sales Units Calculation';
        
        -- Backup original values for safety
        UPDATE batchmgr.u_recship SET system_sales_units_qty = sales_units_qty;
        UPDATE batchmgr.u_recship SET system_updated_wgt = updated_wgt;
        COMMIT;
        
        -- MAIN LOGIC: Calculate sales_units_qty with integer distribution
        l_v_errstep := 'Calculate sales_units_qty with integer distribution';
        
        MERGE /*+ parallel(16) */ INTO batchmgr.u_recship u
        USING (
            WITH base_calculation AS (
                -- Calculate base sales units for each record
                SELECT
                    id,
                    condition,
                    dest,
                    item,
                    pallets_qty,
                    ratio,
                    recqty,
                    -- Base calculation: full pallets get ratio, partials get floor(pallets_qty * ratio)
                    CASE 
                        WHEN pallets_qty = 1.0 THEN ratio
                        WHEN pallets_qty > 0 AND pallets_qty < 1 THEN FLOOR(pallets_qty * ratio)
                        ELSE 0
                    END AS base_sales_units,
                    -- Order by pallets_qty DESC to process full pallets first, partials last
                    ROW_NUMBER() OVER (
                        PARTITION BY condition, dest, item 
                        ORDER BY pallets_qty DESC
                    ) AS rn,
                    COUNT(*) OVER (
                        PARTITION BY condition, dest, item
                    ) AS group_count
                FROM 
                    batchmgr.u_recship
                WHERE 
                    ratio IS NOT NULL AND ratio > 0  -- Exclude problematic records from main logic
            ),
            group_totals AS (
                -- Calculate totals and adjustments needed
                SELECT
                    bc.*,
                    MAX(recqty) OVER (PARTITION BY condition, dest, item) AS total_recqty,
                    SUM(base_sales_units) OVER (PARTITION BY condition, dest, item) AS group_sum,
                    -- Identify the last record (partial pallet) for adjustment
                    CASE 
                        WHEN rn = group_count AND pallets_qty < 1 THEN 1 
                        WHEN rn = group_count AND pallets_qty = 1 AND 
                             NOT EXISTS (SELECT 1 FROM base_calculation bc2 
                                        WHERE bc2.condition = bc.condition 
                                        AND bc2.dest = bc.dest 
                                        AND bc2.item = bc.item 
                                        AND bc2.pallets_qty < 1) THEN 1
                        ELSE 0 
                    END AS is_adjustment_record
                FROM 
                    base_calculation bc
            )
            -- Final calculation with adjustment
            SELECT
                id,
                CASE
                    -- Apply adjustment to the last record (typically partial pallet)
                    WHEN is_adjustment_record = 1 THEN
                        base_sales_units + (total_recqty - group_sum)
                    ELSE
                        base_sales_units
                END AS final_sales_units_qty
            FROM 
                group_totals
        ) src ON (u.id = src.id)
        WHEN MATCHED THEN UPDATE
        SET u.sales_units_qty = src.final_sales_units_qty;
        
        --v_records_updated := SQL%ROWCOUNT;
        COMMIT;
        
        /*
        -- SEPARATE BLOCK: Handle NULL/0 ratio cases
        -- NOTE: This is a backup mechanism for edge cases where ratio is missing
        -- These records are excluded from main logic to avoid calculation errors
        l_v_errstep := 'Handle NULL or zero ratio cases';
        
        UPDATE batchmgr.u_recship
        SET sales_units_qty = recqty  -- Fallback to recqty when ratio is unavailable
        WHERE (ratio IS NULL OR ratio = 0)
        AND recqty IS NOT NULL;
        
        v_null_ratio_count := SQL%ROWCOUNT;
        
        IF v_null_ratio_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('WARNING: ' || v_null_ratio_count || ' records updated with recqty due to NULL/0 ratio');
            -- Log specific cases for investigation
            FOR rec IN (
                SELECT condition, dest, item, COUNT(*) as cnt
                FROM batchmgr.u_recship
                WHERE (ratio IS NULL OR ratio = 0)
                GROUP BY condition, dest, item
            ) LOOP
                DBMS_OUTPUT.PUT_LINE('  - Condition: ' || rec.condition || 
                                   ', Dest: ' || rec.dest || 
                                   ', Item: ' || rec.item || 
                                   ' (' || rec.cnt || ' records)');
            END LOOP;
        END IF;
        COMMIT;
        */
        /* ========== VALIDATION SECTION (Currently Commented - Future Implementation) ==========
        -- Validation Threshold Options:
        -- Option 1: Exact match (discrepancy = 0)
        -- Option 2: Within 1 unit tolerance
        -- Option 3: Within 0.1% of recqty
        
        l_v_errstep := 'Validate sales_units_qty allocation';
        
        WITH validation_check AS (
            SELECT
                condition, dest, item,
                MAX(recqty) AS expected_total,
                SUM(sales_units_qty) AS actual_total,
                ABS(MAX(recqty) - SUM(sales_units_qty)) AS discrepancy,
                CASE
                    -- Option 1: Exact match
                    WHEN ABS(MAX(recqty) - SUM(sales_units_qty)) = 0 THEN 'EXACT_MATCH'
                    -- Option 2: Within 1 unit
                    WHEN ABS(MAX(recqty) - SUM(sales_units_qty)) <= 1 THEN 'WITHIN_1_UNIT'
                    -- Option 3: Within 0.1% 
                    WHEN ABS(MAX(recqty) - SUM(sales_units_qty)) <= (MAX(recqty) * 0.001) THEN 'WITHIN_0.1_PCT'
                    ELSE 'FAILED'
                END AS validation_status
            FROM 
                batchmgr.u_recship
            GROUP BY 
                condition, dest, item
            HAVING 
                ABS(MAX(recqty) - SUM(sales_units_qty)) > 0  -- Adjust threshold as needed
        )
        SELECT COUNT(*) INTO v_discrepancy_count FROM validation_check WHERE validation_status = 'FAILED';
        ========== END VALIDATION SECTION ========== */
        
        /* ========== DISCREPANCY TRACKING (Future Implementation) ==========
        -- Options for tracking discrepancies:
        -- 1. Create tracking table: CREATE TABLE u_recship_discrepancy_log
        -- 2. Add flag column: ALTER TABLE u_recship ADD (discrepancy_flag VARCHAR2(1))
        -- 3. Log to audit table with timestamp, user, and discrepancy details
        
        -- Proposed tracking structure:
        -- CREATE TABLE u_recship_discrepancy_log (
        --     log_id NUMBER GENERATED ALWAYS AS IDENTITY,
        --     log_date DATE DEFAULT SYSDATE,
        --     condition VARCHAR2(20),
        --     dest VARCHAR2(20),
        --     item VARCHAR2(50),
        --     expected_total NUMBER,
        --     actual_total NUMBER,
        --     discrepancy NUMBER,
        --     discrepancy_pct NUMBER,
        --     resolution_status VARCHAR2(20),
        --     resolution_notes VARCHAR2(4000)
        -- );
        ========== END DISCREPANCY TRACKING ========== */
        
        -- Update sourcing values (kept from original)
        l_v_errstep := 'Update sourcing values';
        
        MERGE /*+ parallel(16) */ INTO batchmgr.u_recship t
        USING (
            SELECT
                sourcing.sourcing,
                sourcing.item,
                sourcing.sid,
                sourcing.source,
                sourcing.dest,
                sourcing.transmode,
                sourcing.u_stackabilitytype,
                sourcing.u_priority
            FROM
                scpomgr.sourcing
        ) r ON (t.item = r.item
                AND t.sid = r.sid
                AND t.source = r.source
                AND t.dest = r.dest
                AND t.transmode = r.transmode
                AND t.u_stackabilitytype = r.u_stackabilitytype
                AND t.u_priority = r.u_priority)
        WHEN MATCHED THEN UPDATE
        SET t.sourcing = nvl(r.sourcing,' ');
        COMMIT;
        
        -- Set empty strings instead of nulls
        UPDATE batchmgr.u_recship SET sourcing = ' ' WHERE sourcing IS NULL;
        COMMIT;
        
        /*
        -- Get final statistics
        SELECT COUNT(DISTINCT condition || '-' || dest || '-' || item)
        INTO v_groups_processed
        FROM batchmgr.u_recship;
        
        -- Log statistics
        DBMS_OUTPUT.PUT_LINE('=========== Sales Units Calculation Complete ===========');
        DBMS_OUTPUT.PUT_LINE('Groups processed: ' || v_groups_processed);
        DBMS_OUTPUT.PUT_LINE('Records updated: ' || v_records_updated);
        DBMS_OUTPUT.PUT_LINE('NULL/0 ratio cases: ' || v_null_ratio_count);
        DBMS_OUTPUT.PUT_LINE('======================================================');
        */
    
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                      l_d_startdatetime_in => l_d_start_date_time, 
                                      l_d_enddatetime_in => l_d_end_date_time, 
                                      l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                                    l_d_datetime_in => sysdate, 
                                    l_v_errorid_in => sqlcode, 
                                    l_v_errormessage_in => sqlerrm, 
                                    l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, 
                                    l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                          l_d_startdatetime_in => l_d_start_date_time, 
                                          l_d_enddatetime_in => l_d_end_date_time, 
                                          l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);
    
            RAISE;
    END p_vmi_update_salesunits_qty_sourcing;
    
    PROCEDURE p_vmi_delete_mincapacity IS
    /******************************************************************
      Procedure : P_VMI_DELETE_MINCAPACITY_FOR_TRUCK_CONSTRAINTS
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_DELETE_MINCAPACITY';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_DELETE_MINCAPACITY';
        
        -- Insert the rows that will be deleted into the backup table
        INSERT INTO batchmgr.u_recship_mincap(ID, SOURCINGID, SOURCINGID_SEQ, CONDITION, U_PRIORITY, LOADID, LOAD_SEQUENCE, LOADED, UTILIZATION, U_SOURCINGMIN, SCHEDSHIPDATE, SCHEDARRIVDATE, SOURCE, DEST, TRANSMODE, U_VARIANT_TYPE_DESC, ITEM, U_STACKABILITYTYPE, PALLETS_QTY, SALES_UNITS_QTY, WGT, UPDATED_WGT, SYSTEM_UPDATED_WGT, UPDATED_MINCAP_SU_PALLETS, UPDATED_MAXCAP_SU_PALLETS, UPDATED_MINCAP_SU_POUNDS, UPDATED_MAXCAP_SU_POUNDS, U_ITEM_MINTRUCKSTACKCAP, U_ITEM_MAXTRUCKSTACKCAP, SID, SEQNUM, STACK_POSITION, U_DISPATCHDATE, RATIO, RECQTY, MAJORSHIPQTY, MINORSHIPQTY, STATUS, SOURCING, TRANSLEADTIME, ARRIVCAL, SHIPCAL, CREATED_AT, U_ADJUSTEDMAXCAP, SYSTEM_SALES_UNITS_QTY, AVAILTOSHIPDATE, CONSTRRECSHIPSW, NEEDSHIPDATE, NEEDARRIVDATE)
        SELECT ID, SOURCINGID, SOURCINGID_SEQ, CONDITION, U_PRIORITY, LOADID, LOAD_SEQUENCE, LOADED, UTILIZATION, U_SOURCINGMIN, SCHEDSHIPDATE, SCHEDARRIVDATE, SOURCE, DEST, TRANSMODE, U_VARIANT_TYPE_DESC, ITEM, U_STACKABILITYTYPE, PALLETS_QTY, SALES_UNITS_QTY, WGT, UPDATED_WGT, SYSTEM_UPDATED_WGT, UPDATED_MINCAP_SU_PALLETS, UPDATED_MAXCAP_SU_PALLETS, UPDATED_MINCAP_SU_POUNDS, UPDATED_MAXCAP_SU_POUNDS, U_ITEM_MINTRUCKSTACKCAP, U_ITEM_MAXTRUCKSTACKCAP, SID, SEQNUM, STACK_POSITION, U_DISPATCHDATE, RATIO, RECQTY, MAJORSHIPQTY, MINORSHIPQTY, STATUS, SOURCING, TRANSLEADTIME, ARRIVCAL, SHIPCAL, CREATED_AT, U_ADJUSTEDMAXCAP, SYSTEM_SALES_UNITS_QTY, AVAILTOSHIPDATE, CONSTRRECSHIPSW, NEEDSHIPDATE, NEEDARRIVDATE
        FROM batchmgr.u_recship
        WHERE (sourcingid, source, dest, transmode, loadid, u_priority) IN (
            SELECT sourcingid, source, dest, transmode, loadid, u_priority
            FROM (
                SELECT sourcingid, source, dest, transmode, loadid, u_priority,
                       MIN(updated_mincap_su_pallets) AS min_pallets, COUNT(*) AS ct,
                       CASE WHEN SUM(pallets_qty) >= MIN(updated_mincap_su_pallets) THEN 1 ELSE 0 END AS calc
                FROM batchmgr.u_recship
                GROUP BY sourcingid, source, dest, transmode, loadid, u_priority
            ) subquery
            WHERE calc = 0
        );
    
        COMMIT;
        
         
        -- truckload for mincapacity is not met and need to be removed in u_recship (not an ideal case and hypthotetical situation)
        DELETE FROM batchmgr.u_recship
        WHERE
            ( sourcingid, source, dest, transmode, loadid, u_priority) IN (
                SELECT
                    sourcingid,
                    source, dest, transmode, loadid, u_priority
                FROM
                    (
                        SELECT
                            sourcingid, source,
                            dest, transmode, loadid, u_priority,
                            MIN(updated_mincap_su_pallets) AS min_pallets, COUNT(*) AS ct,
                            CASE
                                WHEN SUM(pallets_qty) >= MIN(updated_mincap_su_pallets) THEN
                                                  1
                                ELSE
                                    0
                            END              AS calc
                        FROM
                            batchmgr.u_recship
        --WHERE condition <> 'FIRST'  -- cancelling out the first condition pallets which should be shipped at all cost
                        GROUP BY
                            sourcingid, source, dest, transmode, loadid, u_priority
                    ) subquery
                WHERE
                    calc = 0
            );

    -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_delete_mincapacity;

    PROCEDURE p_vmi_update_schedarrivdate_schedshipdate IS
    /******************************************************************
      Procedure : P_VMI_UPDATE_SCHEDARRIVDATE_schedshipdate
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_UPDATE_SCHEDARRIVDATE_schedshipdate';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        v_result       t_sched_dates_rec;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_UPDATE_SCHEDARRIVDATE_schedshipdate';
        
        EXECUTE IMMEDIATE 'TRUNCATE TABLE U_RECSHIP_CAL';
        EXECUTE IMMEDIATE 'INSERT INTO batchmgr.U_RECSHIP_CAL select * from u_recship';
        
        /*
        -- Check if ship date is open or get next available date
        UPDATE batchmgr.u_recship r
        SET r.schedshipdate = (
            SELECT 
                CASE 
                    WHEN r2.shipcal = ' ' OR r2.shipcal IS NULL THEN 
                        CASE
                            WHEN r2.schedshipdate > r2.u_dispatchdate THEN r2.schedshipdate
                            ELSE r2.u_dispatchdate
                        END
                    ELSE 
                        CASE
                            WHEN r2.schedshipdate > r2.u_dispatchdate THEN
                                f_vmi_chk_cal_avl_shipdate(
                                    r2.shipcal,
                                    r2.schedshipdate,  
                                    r2.schedarrivdate,
                                    180
                                )
                            ELSE
                                f_vmi_chk_cal_avl_shipdate(
                                    r2.shipcal,
                                    r2.u_dispatchdate,
                                    r2.schedarrivdate,
                                    180
                                )
                        END
                END as next_available_date
            FROM batchmgr.u_recship r2
            WHERE r2.id = r.id
        );
        
        COMMIT;
        */
        
        -- transleadtime need to respect with source & dest
        UPDATE batchmgr.u_recship u
        SET u.transleadtime = (
            SELECT n.transleadtime / 1440  -- Converting days back to minutes
            FROM scpomgr.network n 
            WHERE n.source = u.source 
            AND n.dest = u.dest 
            AND n.transmode = u.transmode
        );
        COMMIT;
        
        /*
        -- schedarrivdate {formulae wrong}
        UPDATE batchmgr.u_recship r
        SET
            r.schedarrivdate = (
                SELECT
                    r2.schedshipdate + r2.transleadtime -- ( r2.schedarrivdate - r2.schedshipdate )
                FROM
                    batchmgr.u_recship r2
                WHERE
                    r2.id = r.id
            );

        COMMIT;
        */
        
        -- check the arrivcal and shipcal is open or close based on u_arrivcal_us & u_shipcal_us
        /*
        declare
            v_result       us_vmi_stackability.t_sched_dates_rec;
            p_needarrivdate DATE;
            p_u_dispatchdate DATE;
            p_transleadtime NUMBER;
        begin
            p_u_dispatchdate  := '02-JAN-25';
            p_needarrivdate := '18-JAN-25';
            p_transleadtime := 5;
            v_result := us_vmi_stackability.f_vmi_chk_avl_shipdate_arrivdate(
                                'RULE_USDR', -- p_shipcal
                                'RULE_10395022', -- p_arrivcal
                                TO_DATE(p_needarrivdate,'DD-MON-YY'), -- p_needarrivdate
                                TO_DATE(p_u_dispatchdate,'DD-MON-YY'), --  p_u_dispatchdate
                                p_transleadtime, -- p_transleadtime
                                30 -- p_buffer_days
                            );
        
            dbms_output.put_line('U_Dispatchdate => ' || TO_CHAR(p_u_dispatchdate, 'DD-MON-YY'));
            dbms_output.put_line('Needarrivdate => ' || TO_CHAR(p_needarrivdate, 'DD-MON-YY'));
            dbms_output.put_line('Transleadtime => ' || p_transleadtime);
            dbms_output.put_line('Schedshipdate => ' || TO_CHAR(v_result.schedshipdate, 'DD-MON-YY'));
            dbms_output.put_line('Schedarrivdate => ' || TO_CHAR(v_result.schedarrivdate, 'DD-MON-YY'));
        end;
        /
        */
        
        BEGIN
            FOR rec IN (
                Select id,
                       shipcal,
                       arrivcal,
                       needarrivdate,
                       u_dispatchdate,
                       transleadtime
                from u_recship
                where u_priority = 2
            ) LOOP
            
            v_result := f_vmi_chk_avl_shipdate_arrivdate(
                      p_shipcal        => rec.shipcal,
                      p_arrivcal       => rec.arrivcal,
                      p_needarrivdate  => rec.needarrivdate,
                      p_u_dispatchdate => rec.u_dispatchdate,
                      p_transleadtime  => rec.transleadtime,
                      p_buffer_days    => 180
                   );
            
            UPDATE u_recship
            SET schedshipdate  = v_result.schedshipdate,
                  schedarrivdate = v_result.schedarrivdate
            WHERE id = rec.id;
            END LOOP;
        commit;
        END;
        
        /*
        -- Check if arrival date is open or get next available date
        UPDATE batchmgr.u_recship r
        SET r.schedarrivdate = (
            SELECT 
                CASE 
                    WHEN r2.arrivcal = ' ' OR r2.arrivcal IS NULL THEN 
                        r2.schedarrivdate
                    ELSE 
                        f_vmi_chk_cal_avl_arrivcal(
                            r2.arrivcal,
                            r2.schedshipdate,
                            r2.schedarrivdate,
                            180
                        )
                END as next_available_date
            FROM batchmgr.u_recship r2
            WHERE r2.id = r.id
        );
        */
        
        /*
        -- shipdate : one way
        DECLARE
            v_result DATE;
        BEGIN
            v_result := f_vmi_chk_cal_avl_shipdate(
                'SHIPCAL_US',
                TO_DATE('2024-12-20', 'YYYY-MM-DD'),
                TO_DATE('2024-12-25', 'YYYY-MM-DD'),
                180
            );
            DBMS_OUTPUT.PUT_LINE('Final Result: ' || TO_CHAR(v_result, 'DD-MON-YYYY'));
        END;
            
        -- arrivdate : one way
        SELECT f_vmi_chk_cal_avl_arrivcal(
            'RULE_16340',                      -- Calendar ID
            TO_DATE('2024-12-25', 'YYYY-MM-DD'),  -- Ship date
            TO_DATE('2024-12-25', 'YYYY-MM-DD'),  -- Arrival date
            180                                    -- Buffer days
        ) as next_available_date
        FROM dual;
        
        -- another way
        DECLARE
            v_result DATE;
        BEGIN
            v_result := f_vmi_chk_cal_avl_arrivcal(
                'RULE_16340',
                TO_DATE('2024-12-20', 'YYYY-MM-DD'),
                TO_DATE('2024-12-25', 'YYYY-MM-DD'),
                180
            );
            DBMS_OUTPUT.PUT_LINE('Final Result: ' || TO_CHAR(v_result, 'DD-MON-YYYY'));
        END;
        */
        
        COMMIT;
        
    -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_update_schedarrivdate_schedshipdate;
    
    PROCEDURE p_vmi_elligible_loads
    IS
        /******************************************************************
          Procedure : p_vmi_elligible_loads
          Description : 
              1. Aligns P2 sourcing IDs with P1 for merging.
              2. Identifies eligible P1/P2 loads from u_recship and returns them.
          Author    : Vinay Govardhanam
          Revision  : Extracted on 13-Apr-2025
        *******************************************************************/
        
        -- Define local types for returning eligible loads
        TYPE load_id_rec IS RECORD (
          sourcingid            NUMBER,
          loadid                NUMBER,
          source                VARCHAR2(100),
          dest                  VARCHAR2(100),
          transmode             VARCHAR2(100),
          u_variant_type_desc   VARCHAR2(100),
          u_priority            NUMBER
        );
        TYPE load_id_list IS TABLE OF load_id_rec INDEX BY PLS_INTEGER;
        l_eligible_loads load_id_list;
        
        -- Variable for tracking rows updated in the merge operation
        v_rows_updated NUMBER := 0;
    BEGIN
        ------------------------------------------------------------------------
        -- Step 1: Align P2 Sourcing IDs with P1 Sourcing IDs
        ------------------------------------------------------------------------
        /*
        MERGE INTO batchmgr.u_recship p2
        USING (
          SELECT 
              p1.source,
              p1.dest,
              p1.transmode,
              p1.u_variant_type_desc,
              MIN(p1.sourcingid) AS p1_sourcingid
          FROM batchmgr.u_recship p1
          JOIN batchmgr.u_recship p2_check 
            ON p2_check.source = p1.source 
           AND p2_check.dest = p1.dest 
           AND p2_check.transmode = p1.transmode
           AND p2_check.u_variant_type_desc = p1.u_variant_type_desc
           AND p2_check.u_priority = 2
          WHERE p1.u_priority = 1
          GROUP BY p1.source,
                   p1.dest,
                   p1.transmode,
                   p1.u_variant_type_desc
        ) p1_src
        ON (
          p2.source = p1_src.source 
          AND p2.dest = p1_src.dest 
          AND p2.transmode = p1_src.transmode 
          AND p2.u_variant_type_desc = p1_src.u_variant_type_desc
          AND p2.u_priority = 2
        )
        WHEN MATCHED THEN
          UPDATE SET p2.sourcingid = p1_src.p1_sourcingid
          WHERE p2.sourcingid <> p1_src.p1_sourcingid;
        */
        MERGE INTO batchmgr.u_recship p2
        USING (
          SELECT 
              p1.source,
              p1.dest,
              p1.transmode,
              p1.u_variant_type_desc,
              p1.loadid,
              MIN(p1.sourcingid) AS p1_sourcingid
          FROM batchmgr.u_recship p1
          JOIN batchmgr.u_recship p2_check 
            ON p2_check.source = p1.source 
           AND p2_check.dest = p1.dest 
           AND p2_check.transmode = p1.transmode
           AND p2_check.u_variant_type_desc = p1.u_variant_type_desc
           AND p2_check.loadid = p1.loadid
           AND p2_check.u_priority = 2
          WHERE p1.u_priority = 1
          GROUP BY p1.source, p1.dest, p1.transmode, p1.u_variant_type_desc, p1.loadid
        ) p1_src
        ON (
          p2.source = p1_src.source 
          AND p2.dest = p1_src.dest 
          AND p2.transmode = p1_src.transmode 
          AND p2.u_variant_type_desc = p1_src.u_variant_type_desc
          AND p2.loadid = p1_src.loadid
          AND p2.u_priority = 2
        )
        WHEN MATCHED THEN
          UPDATE SET p2.sourcingid = p1_src.p1_sourcingid
          WHERE p2.sourcingid <> p1_src.p1_sourcingid;
          
        v_rows_updated := SQL%ROWCOUNT;
        COMMIT;
        
        ------------------------------------------------------------------------
        -- Step 2: Identify Eligible P1/P2 Loads from u_recship
        ------------------------------------------------------------------------
        l_eligible_loads.DELETE; -- Clear the collection before populating
    
        -- Use CTEs to first find all non-full loads, then identify lanes with
        -- non-full loads of BOTH priorities, then collect those loads.
        /*
        WITH
        load_usage_stats AS (
            -- Calculate usage and capacity for each load (P1 and P2)
            SELECT
                u.sourcingid, u.loadid, u.u_priority, u.source, u.dest, u.transmode, u.u_variant_type_desc,
                -- Get capacities per load using analytic functions
                MAX(u.u_adjustedmaxcap) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) as max_pallets_capacity,
                MAX(u.updated_maxcap_su_pounds) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) as max_weight_capacity,
                -- Calculate usage per load using analytic functions
                SUM(NVL(case when u.u_stackabilitytype in ('RED', 'SS') then u.pallets_qty*2 else u.pallets_qty end, 0)) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) as pallets_used,
                SUM(NVL(u.updated_wgt, 0)) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) as weight_used,
                -- Use ROW_NUMBER to select distinct loads later
                ROW_NUMBER() OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority ORDER BY u.id) as rn
            FROM batchmgr.u_recship u
            WHERE u.u_priority IN (1, 2) -- Consider only P1 and P2
        ),
        non_full_loads AS (
            -- Filter load_usage_stats to get only non-full loads
            SELECT DISTINCT -- Use DISTINCT here instead of rn=1
                sourcingid, loadid, u_priority, source, dest, transmode, u_variant_type_desc
            FROM load_usage_stats
            WHERE pallets_used < max_pallets_capacity
              AND weight_used < max_weight_capacity
        ),
        qualifying_lanes AS (
            -- Identify lanes (by aligned sourcingid) that have
            -- AT LEAST ONE non-full P1 AND AT LEAST ONE non-full P2 truck
            SELECT sourcingid, source, dest, transmode, u_variant_type_desc
            FROM non_full_loads
            GROUP BY sourcingid, source, dest, transmode, u_variant_type_desc
            HAVING COUNT(DISTINCT u_priority) = 2 -- Must have both priorities represented among non-full loads
        )
        -- Final selection: Get all non-full loads that belong to the qualifying lanes
        SELECT
            nfl.sourcingid, nfl.loadid, nfl.source, nfl.dest, nfl.transmode, nfl.u_variant_type_desc, nfl.u_priority
        BULK COLLECT INTO l_eligible_loads -- Populate the collection
        FROM non_full_loads nfl
        JOIN qualifying_lanes ql -- Join non-full loads with lanes that meet the criteria
          ON nfl.sourcingid = ql.sourcingid
         AND nfl.source = ql.source
         AND nfl.dest = ql.dest
         AND nfl.transmode = ql.transmode
         AND nfl.u_variant_type_desc = ql.u_variant_type_desc;
         */
        WITH
          load_util AS (
            SELECT
              u.sourcingid,
              u.loadid,
              u.u_priority,
              u.source,
              u.dest,
              u.transmode,
              u.u_variant_type_desc,
              MAX(u.utilization) 
                OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS util
            FROM batchmgr.u_recship u
            WHERE u.u_priority IN (1, 2)
          ),
          non_full_loads AS (
            SELECT DISTINCT
              sourcingid,
              loadid,
              u_priority,
              source,
              dest,
              transmode,
              u_variant_type_desc
            FROM load_util
            WHERE util < 100               
          ),
          qualifying_lanes AS (
            SELECT
              sourcingid,
              source,
              dest,
              transmode,
              u_variant_type_desc
            FROM non_full_loads
            GROUP BY
              sourcingid,
              source,
              dest,
              transmode,
              u_variant_type_desc
            HAVING COUNT(DISTINCT u_priority) = 2
              -- only lanes that have both P1 AND P2 “non‐full” qualify
          )
        SELECT
          nfl.sourcingid,
          nfl.loadid,
          nfl.source,
          nfl.dest,
          nfl.transmode,
          nfl.u_variant_type_desc,
          nfl.u_priority
        BULK COLLECT INTO l_eligible_loads
        FROM non_full_loads nfl
        JOIN qualifying_lanes ql
          ON nfl.sourcingid          = ql.sourcingid
         AND nfl.source              = ql.source
         AND nfl.dest                = ql.dest
         AND nfl.transmode           = ql.transmode
         AND nfl.u_variant_type_desc = ql.u_variant_type_desc;
    
        -- Add DBMS output for validation
        DBMS_OUTPUT.PUT_LINE('Found ' || l_eligible_loads.COUNT || ' eligible trucks (non-full P1/P2) from qualifying lanes for merging.');
        FOR i IN 1..l_eligible_loads.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Eligible Load: P' || l_eligible_loads(i).u_priority
                || ' SourcingID=' || l_eligible_loads(i).sourcingid
                || ' Truck_No=' || l_eligible_loads(i).loadid
                || ' LoadID=' || l_eligible_loads(i).source || '_' || l_eligible_loads(i).dest || '_' || l_eligible_loads(i).u_variant_type_desc || '_' || l_eligible_loads(i).loadid || '_' || l_eligible_loads(i).u_priority || '_' || TO_CHAR(TO_DATE(sysdate, 'DD-MON-YY'), 'MMDDYY')
                );
        END LOOP;
    
        -- Exit if no eligible loads were found meeting the new criteria
        IF l_eligible_loads.COUNT = 0 THEN
            DBMS_OUTPUT.PUT_LINE('No lanes found with both non-full P1 and non-full P2 trucks. Exiting merge procedure.');
            COMMIT;
            RETURN; -- Exit the procedure
        END IF;
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END p_vmi_elligible_loads;
    
    PROCEDURE p_vmi_merge_load IS
        -- Standard logging variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_merge_load';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- Variables for merge and counts
        v_rows_updated       NUMBER := 0;
        v_merged_count       NUMBER := 0;
        v_count              NUMBER;
        max_sourcingid       NUMBER := 0;
        
        -- Collection to store eligible P1 and P2 truck identifiers from qualifying lanes
        TYPE load_id_rec IS RECORD (
          sourcingid NUMBER,
          loadid     NUMBER,
          source     VARCHAR2(100),
          dest       VARCHAR2(100),
          transmode  VARCHAR2(100),
          u_variant_type_desc VARCHAR2(100),
          u_priority NUMBER
        );
        TYPE load_id_list IS TABLE OF load_id_rec INDEX BY PLS_INTEGER;
        l_eligible_loads load_id_list;
    BEGIN
        -- Standard logging initialization
        l_d_start_date_time := systimestamp;
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                     l_d_startdatetime_in => l_d_start_date_time, 
                                     l_v_progstatus_in => 'Started..');
    
        --------------------------------------------------------------------------
        -- Step 1: Backup and prepare priority_shift_pallets
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 1: Backup priority_shift_pallets data';
        
        -- Check if backup table exists, create if not
        BEGIN
            EXECUTE IMMEDIATE 'SELECT 1 FROM priority_shift_pallets_bkp WHERE ROWNUM = 1';
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE = -942 THEN
                    EXECUTE IMMEDIATE 'CREATE TABLE priority_shift_pallets_bkp AS SELECT * FROM priority_shift_pallets WHERE 1=0';
                ELSE
                    RAISE;
                END IF;
        END;
        
        -- Backup existing data
        EXECUTE IMMEDIATE 'INSERT INTO priority_shift_pallets_bkp SELECT * FROM priority_shift_pallets';
        
        -- Truncate the table 
        EXECUTE IMMEDIATE 'TRUNCATE TABLE priority_shift_pallets';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE MERGE_RECSHIP';
        
        --------------------------------------------------------------------------
        -- Step 2: Align P2 Sourcing IDs with P1 for merging
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 2: Align P2 Sourcing IDs';
        
        MERGE INTO batchmgr.u_recship p2
        USING (
          SELECT 
              p1.source,
              p1.dest,
              p1.transmode,
              p1.u_variant_type_desc,
              p1.loadid,
              MIN(p1.sourcingid) AS p1_sourcingid
          FROM batchmgr.u_recship p1
          JOIN batchmgr.u_recship p2_check 
            ON p2_check.source = p1.source 
           AND p2_check.dest = p1.dest 
           AND p2_check.transmode = p1.transmode
           AND p2_check.u_variant_type_desc = p1.u_variant_type_desc
           AND p2_check.loadid = p1.loadid
           AND p2_check.u_priority = 2
          WHERE p1.u_priority = 1
          GROUP BY p1.source, p1.dest, p1.transmode, p1.u_variant_type_desc, p1.loadid
        ) p1_src
        ON (
          p2.source = p1_src.source 
          AND p2.dest = p1_src.dest 
          AND p2.transmode = p1_src.transmode 
          AND p2.u_variant_type_desc = p1_src.u_variant_type_desc
          AND p2.loadid = p1_src.loadid
          AND p2.u_priority = 2
        )
        WHEN MATCHED THEN
          UPDATE SET p2.sourcingid = p1_src.p1_sourcingid
          WHERE p2.sourcingid <> p1_src.p1_sourcingid;
          
        v_rows_updated := SQL%ROWCOUNT;
        COMMIT;
    
        --------------------------------------------------------------------------
        -- Step 3: Identify Eligible P1/P2 Loads
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 3: Identify Eligible P1/P2 Loads';
        
        l_eligible_loads.DELETE;
        /*
        WITH load_usage_stats AS (
            SELECT
                u.sourcingid,
                u.loadid,
                u.u_priority,
                u.source,
                u.dest,
                u.transmode,
                u.u_variant_type_desc,
                MAX(u.u_adjustedmaxcap) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS max_pallets_capacity,
                MAX(u.updated_maxcap_su_pounds) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS max_weight_capacity,
                SUM(NVL(CASE WHEN u.u_stackabilitytype IN ('RED', 'SS') THEN u.pallets_qty*2 ELSE u.pallets_qty END, 0)) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS pallets_used,
                SUM(NVL(u.updated_wgt, 0)) OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS weight_used,
                ROW_NUMBER() OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority ORDER BY u.id) AS rn
            FROM batchmgr.u_recship u
            WHERE u.u_priority IN (1, 2)
        ),
        non_full_loads AS (
            SELECT DISTINCT
                sourcingid, loadid, u_priority, source, dest, transmode, u_variant_type_desc
            FROM load_usage_stats
            WHERE pallets_used < max_pallets_capacity
              AND weight_used < max_weight_capacity
        ),
        qualifying_lanes AS (
            SELECT sourcingid, source, dest, transmode, u_variant_type_desc
            FROM non_full_loads
            GROUP BY sourcingid, source, dest, transmode, u_variant_type_desc
            HAVING COUNT(DISTINCT u_priority) = 2
        )
        SELECT
            nfl.sourcingid,
            nfl.loadid,
            nfl.source,
            nfl.dest,
            nfl.transmode,
            nfl.u_variant_type_desc,
            nfl.u_priority
        BULK COLLECT INTO l_eligible_loads
        FROM non_full_loads nfl
        JOIN qualifying_lanes ql
          ON nfl.sourcingid = ql.sourcingid
         AND nfl.source = ql.source
         AND nfl.dest = ql.dest
         AND nfl.transmode = ql.transmode
         AND nfl.u_variant_type_desc = ql.u_variant_type_desc;*/
        WITH
          load_util AS (
            SELECT
              u.sourcingid,
              u.loadid,
              u.u_priority,
              u.source,
              u.dest,
              u.transmode,
              u.u_variant_type_desc,
              MAX(u.utilization) 
                OVER (PARTITION BY u.sourcingid, u.loadid, u.u_priority) AS util
            FROM batchmgr.u_recship u
            WHERE u.u_priority IN (1, 2)
          ),
          non_full_loads AS (
            SELECT DISTINCT
              sourcingid,
              loadid,
              u_priority,
              source,
              dest,
              transmode,
              u_variant_type_desc
            FROM load_util
            WHERE util < 100               
          ),
          qualifying_lanes AS (
            SELECT
              sourcingid,
              source,
              dest,
              transmode,
              u_variant_type_desc
            FROM non_full_loads
            GROUP BY
              sourcingid,
              source,
              dest,
              transmode,
              u_variant_type_desc
            HAVING COUNT(DISTINCT u_priority) = 2
              -- only lanes that have both P1 AND P2 “non‐full” qualify
          )
        SELECT
          nfl.sourcingid,
          nfl.loadid,
          nfl.source,
          nfl.dest,
          nfl.transmode,
          nfl.u_variant_type_desc,
          nfl.u_priority
        BULK COLLECT INTO l_eligible_loads
        FROM non_full_loads nfl
        JOIN qualifying_lanes ql
          ON nfl.sourcingid          = ql.sourcingid
         AND nfl.source              = ql.source
         AND nfl.dest                = ql.dest
         AND nfl.transmode           = ql.transmode
         AND nfl.u_variant_type_desc = ql.u_variant_type_desc;
        
        -- Exit if no eligible loads were found
        IF l_eligible_loads.COUNT = 0 THEN
            l_d_end_date_time := systimestamp;
            l_v_prog_status := 'SUCCESS';
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                         l_d_startdatetime_in => l_d_start_date_time, 
                                         l_d_enddatetime_in => l_d_end_date_time, 
                                         l_v_progstatus_in => l_v_prog_status, 
                                         l_v_frequency_in => l_v_frequency);
            COMMIT;
            RETURN; -- Exit the procedure
        END IF;
        
        --------------------------------------------------------------------------
        -- Step 4: Copy Records to priority_shift_pallets and Remove from u_recship
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 4: Copy Records to priority_shift_pallets';
        
        -- Get max sourcingid to ensure new merged loads don't conflict
        SELECT MAX(sourcingid)+1 INTO max_sourcingid FROM batchmgr.u_recship;
        --DBMS_OUTPUT.PUT_LINE('SOURCINGID: ' || max_sourcingid);
        
        FOR i IN 1..l_eligible_loads.COUNT LOOP
            IF l_eligible_loads(i).u_priority = 1 THEN
                -- For P1 loads, copy only FIRST condition pallets
                INSERT INTO batchmgr.priority_shift_pallets(
                    sourcingid,
                    sourcingid_seq,
                    condition,
                    u_priority,
                    u_sourcingmin,
                    schedshipdate,
                    schedarrivdate,
                    source,
                    dest,
                    transmode,
                    u_variant_type_desc,
                    item,
                    u_stackabilitytype,
                    pallets_qty,
                    updated_wgt,
                    updated_mincap_su_pallets,
                    updated_maxcap_su_pallets,
                    updated_mincap_su_pounds,
                    updated_maxcap_su_pounds,
                    u_item_mintruckstackcap,
                    u_item_maxtruckstackcap,
                    sid,
                    seqnum,
                    status,
                    u_dispatchdate,
                    ratio,
                    recqty,
                    sales_units_qty,
                    majorshipqty,
                    minorshipqty,
                    transleadtime,
                    arrivcal,
                    shipcal,
                    u_adjustedmaxcap,
                    wgt,
                    constrrecshipsw,
                    availtoshipdate,
                    needshipdate,
                    needarrivdate
                )
                SELECT
                    sourcingid,
                    sourcingid_seq,
                    condition,
                    u_priority,
                    u_sourcingmin,
                    schedshipdate,
                    schedarrivdate,
                    source,
                    dest,
                    transmode,
                    u_variant_type_desc,
                    item,
                    u_stackabilitytype,
                    pallets_qty,
                    updated_wgt,
                    updated_mincap_su_pallets,
                    updated_maxcap_su_pallets,
                    updated_mincap_su_pounds,
                    updated_maxcap_su_pounds,
                    u_item_mintruckstackcap,
                    u_item_maxtruckstackcap,
                    sid,
                    seqnum,
                    'priority_shift'            AS status,
                    u_dispatchdate,
                    ratio,
                    recqty,
                    sales_units_qty,
                    majorshipqty,
                    minorshipqty,
                    transleadtime,
                    arrivcal,
                    shipcal,
                    u_adjustedmaxcap,
                    wgt,
                    constrrecshipsw,
                    availtoshipdate,
                    needshipdate,
                    needarrivdate
                FROM batchmgr.u_recship src
                WHERE src.loadid = l_eligible_loads(i).loadid
                  AND src.source = l_eligible_loads(i).source
                  AND src.dest = l_eligible_loads(i).dest
                  AND src.transmode = l_eligible_loads(i).transmode
                  AND src.u_variant_type_desc = l_eligible_loads(i).u_variant_type_desc
                  AND src.u_priority = l_eligible_loads(i).u_priority
                  AND src.condition = 'FIRST';
            ELSIF l_eligible_loads(i).u_priority = 2 THEN
                -- For P2 loads, copy all pallets
                INSERT INTO batchmgr.priority_shift_pallets(
                    sourcingid,
                    sourcingid_seq,
                    condition,
                    u_priority,
                    u_sourcingmin,
                    schedshipdate,
                    schedarrivdate,
                    source,
                    dest,
                    transmode,
                    u_variant_type_desc,
                    item,
                    u_stackabilitytype,
                    pallets_qty,
                    updated_wgt,
                    updated_mincap_su_pallets,
                    updated_maxcap_su_pallets,
                    updated_mincap_su_pounds,
                    updated_maxcap_su_pounds,
                    u_item_mintruckstackcap,
                    u_item_maxtruckstackcap,
                    sid,
                    seqnum,
                    status,
                    u_dispatchdate,
                    ratio,
                    recqty,
                    sales_units_qty,
                    majorshipqty,
                    minorshipqty,
                    transleadtime,
                    arrivcal,
                    shipcal,
                    u_adjustedmaxcap,
                    wgt,
                    constrrecshipsw,
                    availtoshipdate,
                    needshipdate,
                    needarrivdate
                )
                SELECT
                    sourcingid,
                    sourcingid_seq,
                    condition,
                    u_priority,
                    u_sourcingmin,
                    schedshipdate,
                    schedarrivdate,
                    source,
                    dest,
                    transmode,
                    u_variant_type_desc,
                    item,
                    u_stackabilitytype,
                    pallets_qty,
                    updated_wgt,
                    updated_mincap_su_pallets,
                    updated_maxcap_su_pallets,
                    updated_mincap_su_pounds,
                    updated_maxcap_su_pounds,
                    u_item_mintruckstackcap,
                    u_item_maxtruckstackcap,
                    sid,
                    seqnum,
                    'priority_shift'            AS status,
                    u_dispatchdate,
                    ratio,
                    recqty,
                    sales_units_qty,
                    majorshipqty,
                    minorshipqty,
                    transleadtime,
                    arrivcal,
                    shipcal,
                    u_adjustedmaxcap,
                    wgt,
                    constrrecshipsw,
                    availtoshipdate,
                    needshipdate,
                    needarrivdate
                FROM batchmgr.u_recship src
                WHERE src.loadid = l_eligible_loads(i).loadid
                  AND src.source = l_eligible_loads(i).source
                  AND src.dest = l_eligible_loads(i).dest
                  AND src.transmode = l_eligible_loads(i).transmode
                  AND src.u_variant_type_desc = l_eligible_loads(i).u_variant_type_desc
                  AND src.u_priority = l_eligible_loads(i).u_priority;
            END IF;
        END LOOP;
        
        EXECUTE IMMEDIATE 'INSERT INTO MERGE_RECSHIP SELECT * FROM PRIORITY_SHIFT_PALLETS';
        
       
        -- Delete the copied records from u_recship
        l_v_errstep := 'Step 4: Delete Copied Records from u_recship';
        FOR i IN 1..l_eligible_loads.COUNT LOOP
            IF l_eligible_loads(i).u_priority = 1 THEN
                DELETE FROM batchmgr.u_recship src
                WHERE --src.sourcingid = l_eligible_loads(i).sourcingid AND 
                  src.loadid = l_eligible_loads(i).loadid
                  AND src.source = l_eligible_loads(i).source
                  AND src.dest = l_eligible_loads(i).dest
                  AND src.transmode = l_eligible_loads(i).transmode
                  AND src.u_variant_type_desc = l_eligible_loads(i).u_variant_type_desc
                  AND src.u_priority = l_eligible_loads(i).u_priority
                  AND src.condition = 'FIRST';
            ELSIF l_eligible_loads(i).u_priority = 2 THEN
                DELETE FROM batchmgr.u_recship src
                WHERE -- src.sourcingid = l_eligible_loads(i).sourcingid AND 
                  src.loadid = l_eligible_loads(i).loadid
                  AND src.source = l_eligible_loads(i).source
                  AND src.dest = l_eligible_loads(i).dest
                  AND src.transmode = l_eligible_loads(i).transmode
                  AND src.u_variant_type_desc = l_eligible_loads(i).u_variant_type_desc
                  AND src.u_priority = l_eligible_loads(i).u_priority;
            END IF;
        END LOOP;
        
        COMMIT;
        
        --------------------------------------------------------------------------
        -- Step 5: Update IDs (sourcingid, sourcingid_seq, u_priority)
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 5: Update sourcingid and sequences';
        UPDATE batchmgr.priority_shift_pallets SET u_priority = 12;
        COMMIT;
        
        -- Update sourcingid_seq using the same algorithm from p_vmi_process_priority_shift
        MERGE /* + Parallel(16) */ INTO batchmgr.priority_shift_pallets t  
        USING (
              WITH ranked_data AS (
                  SELECT
                      ROWID AS rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      substr(u_variant_type_desc, 1, 2) AS u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      DENSE_RANK() OVER(
                          PARTITION BY 
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN 1 
                                  ELSE 0 
                              END
                          ORDER BY
                              source, 
                              dest, 
                              transmode, 
                              substr(u_variant_type_desc, 1, 2),
                              u_priority,
                              CASE 
                                  WHEN constrrecshipsw != 0 THEN availtoshipdate
                              END
                      ) AS sourcingid
                  FROM
                      batchmgr.priority_shift_pallets
              ), final_data AS (
                  SELECT
                      rid,
                      schedshipdate,
                      availtoshipdate,
                      source,
                      dest,
                      transmode,
                      u_variant_type_desc,
                      u_priority,
                      constrrecshipsw,
                      sourcingid,
                      DENSE_RANK() OVER(
                          PARTITION BY sourcingid
                          ORDER BY
                              CASE 
                                  WHEN constrrecshipsw = 0 THEN schedshipdate
                                  ELSE availtoshipdate
                              END
                      ) AS sourcingid_seq
                  FROM
                      ranked_data
              )
              SELECT
                  rid,
                  schedshipdate,
                  source,
                  dest,
                  transmode,
                  u_variant_type_desc,
                  u_priority,
                  constrrecshipsw,
                  sourcingid,
                  sourcingid_seq
              FROM
                  final_data
          ) temp ON (t.rowid = temp.rid)
        WHEN MATCHED THEN UPDATE
        SET t.sourcingid = temp.sourcingid,
        t.sourcingid_seq = temp.sourcingid_seq;
        
        COMMIT;
        
        -- Update color priority for consistency
        UPDATE priority_shift_pallets SET color_priority_sourcingid_seq = CASE
                WHEN u_stackabilitytype = 'RED' THEN 1
                WHEN u_stackabilitytype = 'SS' THEN 2
                WHEN u_stackabilitytype = 'BLACK' THEN 3
                WHEN u_stackabilitytype = 'GREEN' THEN 4
                WHEN u_stackabilitytype = 'DS' THEN 5
                WHEN u_stackabilitytype = 'YELLOW' THEN 6
                ELSE 7
            END;
        COMMIT;
        
        UPDATE priority_shift_pallets set sourcingid = sourcingid+max_sourcingid;
        COMMIT;
        
        --------------------------------------------------------------------------
        -- Step 6: Process merged pallets for each sourcingid
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 6: Process merged pallets';
        
        FOR src IN (
            SELECT DISTINCT sourcingid
            FROM batchmgr.priority_shift_pallets
            ORDER BY sourcingid
        ) LOOP
            -- Call the hub merging procedure
            p_vmi_hub_merge_partial_pallets(src.sourcingid);
        END LOOP;
        
        COMMIT;
        
        --------------------------------------------------------------------------
        -- Step 7: Create trucks using hub truck building
        --------------------------------------------------------------------------
        l_v_errstep := 'Step 7: Build trucks';
        
        FOR src IN (
            SELECT DISTINCT sourcingid
            FROM batchmgr.priority_shift_pallets
            ORDER BY sourcingid
        ) LOOP
            p_vmi_create_priority_shift_trucks(src.sourcingid);
            COMMIT;
        END LOOP;
    
        
        -- Set Interface end time and successful status
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                     l_d_startdatetime_in => l_d_start_date_time, 
                                     l_d_enddatetime_in => l_d_end_date_time, 
                                     l_v_progstatus_in => l_v_prog_status,
                                     l_v_frequency_in => l_v_frequency);
        COMMIT;
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            l_v_prog_status := 'FAILURE';
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                                   l_d_datetime_in => sysdate, 
                                   l_v_errorid_in => SQLCODE, 
                                   l_v_errormessage_in => SQLERRM, 
                                   l_v_errorrecord_in => NULL,
                                   l_v_errorstep_in => l_v_errstep, 
                                   l_v_frequency_in => l_v_frequency);
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name,
                                         l_d_startdatetime_in => l_d_start_date_time, 
                                         l_d_enddatetime_in => l_d_end_date_time, 
                                         l_v_progstatus_in => l_v_prog_status,
                                         l_v_frequency_in => l_v_frequency);
            COMMIT;
            RAISE;
    END p_vmi_merge_load;

    PROCEDURE p_vmi_insert_vl_vll IS
    /******************************************************************
      Procedure : P_VMI_INSERT_VL_VLL
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_INSERT_VL_VLL';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        -- Cursor for VehicleLoad
        CURSOR c_vehicleload IS
        SELECT DISTINCT
            source
            || '_'
            || dest
            || '_'
            || substr(u_variant_type_desc, 1, 2)
            || '_'
            || loadid
            || '_'
            || u_priority                
            || '_'
            || TO_CHAR(TO_DATE(sysdate, 'DD-MON-YY'), 'MMDDYY')
            AS loadid,
            MIN(schedshipdate)           AS shipdate,
            MIN(schedarrivdate)          AS arrivdate,
            transmode,
            source                       AS u_source,
            dest                         AS u_dest,
            substr(u_variant_type_desc, 1, 2) as u_variant_type_desc,
            --sid,
            COUNT(*)                     AS total_pallets,
            SUM(nvl(sales_units_qty, 0)) AS total_sales_units,
            MAX(utilization)             AS utilization
        FROM
            batchmgr.u_recship
        WHERE
            loaded = 'Y' and status='loaded'
        GROUP BY
            source,
            dest,
            substr(u_variant_type_desc, 1, 2),
            loadid,
            u_priority,
            transmode;
            --sid;

        -- Updated Cursor for VehicleLoadLine
        CURSOR c_vehicleloadline (
            p_loadid VARCHAR2
        ) IS
        SELECT
            MIN(sourcing)                          AS sourcing,
            item,
            SUM(nvl(sales_units_qty, pallets_qty)) AS qty,
            MIN(schedshipdate)                     AS schedshipdate,
            MIN(schedarrivdate)                    AS schedarrivdate,
            MAX(transmode)                         AS transmode,
            MAX(substr(u_variant_type_desc, 1, 2)) AS u_variant_type_desc,
            --MAX(sid)                               AS sid,
            MAX(source)                            AS source,
            MAX(dest)                              AS dest,
            MAX(u_priority)                        AS u_priority,
            SUM(
                CASE
                    WHEN condition IN('FIRST', 'PRIORITY_SHIFT') THEN
                        nvl(sales_units_qty, pallets_qty)
                    ELSE
                        0
                END
            )                                      AS mustgoqty,
            COUNT(*)                               AS total_pallets
        FROM
            batchmgr.u_recship
        WHERE
                loaded = 'Y' and status='loaded'
            AND source
                || '_'
                || dest
                || '_'
                || substr(u_variant_type_desc, 1, 2)
                || '_'
                || loadid
                || '_'
                || u_priority 
                || '_'
                || TO_CHAR(TO_DATE(sysdate, 'DD-MON-YY'), 'MMDDYY') = p_loadid
        GROUP BY
            item;

    -- Cursor for TRANSMODEMINMETSW calculation
    -- mincap of the specific truck is met. if yes, 1 or else 0 (we need to calculate the min(count) of each truck >= updated_mincap_su_pallets)
        CURSOR c_transmodeminmetsw IS
        SELECT
            source
            || '_'
            || dest
            || '_'
            || substr(u_variant_type_desc, 1, 2)
            || '_'
            || loadid
            || '_'
            || u_priority 
            || '_'
            || TO_CHAR(TO_DATE(sysdate, 'DD-MON-YY'), 'MMDDYY')
            AS loadid,
            CASE
                WHEN COUNT(*) >= nvl(MIN(updated_mincap_su_pallets), 0) THEN
                    1
                ELSE
                    0
            END           AS transmodeminmetsw
        FROM
            batchmgr.u_recship
        WHERE
            loaded = 'Y' and status='loaded'
        GROUP BY
            source,
            dest,
            substr(u_variant_type_desc, 1, 2),
            loadid,
            u_priority;

    -- Cursor for MAXCAPACITYMETSW calculation
    -- maxcap of the specific truck is met. if yes, 1 or else 0 (we need to calculate the max(utilization) to get if it is >=95.5%)
        CURSOR c_maxcapacitymetsw IS
        SELECT
            source
            || '_'
            || dest
            || '_'
            || substr(u_variant_type_desc, 1, 2)
            || '_'
            || loadid
            || '_'
            || u_priority 
            || '_'
            || TO_CHAR(TO_DATE(sysdate, 'DD-MON-YY'), 'MMDDYY')
            AS loadid,
            CASE
                WHEN MAX(utilization) >= 95.5 THEN
                    1
                ELSE
                    0
            END           AS maxcapacitymetsw
        FROM
            batchmgr.u_recship
        WHERE
            loaded = 'Y' and status='loaded'
        GROUP BY
            source,
            dest,
            substr(u_variant_type_desc, 1, 2),
            loadid,
            u_priority;

        v_count             NUMBER;
        v_transmodeminmetsw NUMBER;
        v_maxcapacitymetsw  NUMBER;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_INSERT_VL_VLL';
      /*  DELETE FROM scpomgr.vehicleload
        WHERE
            nvl(u_data_source, 'BTL') NOT IN ( 'INTRANSIT', 'ORDER_CONFIRMATION', 'DELIVERY_NOTIFICATION' )
            AND approvalstatus = 0
            AND lbsource IN ( '2', '3', '4' );*/
        DELETE FROM scpomgr.vehicleload
        WHERE
            nvl(u_data_source, 'BTL') NOT IN ( 'INTRANSIT', 'ORDER_CONFIRMATION', 'DELIVERY_NOTIFICATION' )
            AND approvalstatus = 0
            AND lbsource IN ( '2', '3', '4' )
            AND LOADID in (SELECT LOADID from scpomgr.vehicleloadline where item like 'XUS%');  

    -- Process data for VehicleLoad
        FOR rec IN c_vehicleload LOOP
        -- Initialize variables
            v_transmodeminmetsw := 0;
            v_maxcapacitymetsw := 0;

        -- Get TRANSMODEMINMETSW value
            FOR trans_rec IN c_transmodeminmetsw LOOP
                IF trans_rec.loadid = rec.loadid THEN
                    v_transmodeminmetsw := trans_rec.transmodeminmetsw;
                    EXIT;
                END IF;
            END LOOP;

        -- Get MAXCAPACITYMETSW value
            FOR max_rec IN c_maxcapacitymetsw LOOP
                IF max_rec.loadid = rec.loadid THEN
                    v_maxcapacitymetsw := max_rec.maxcapacitymetsw;
                    EXIT;
                END IF;
            END LOOP;

        -- Check if the record already exists
            SELECT
                COUNT(*)
            INTO v_count
            FROM
                scpomgr.vehicleload
            WHERE
                loadid = rec.loadid;
		--AND ITEM Like 'XUS%';

            IF
                v_count = 0
                AND v_transmodeminmetsw <> 0
            THEN
                INSERT INTO scpomgr.vehicleload (
                    loadid,
                    descr,
                    shipdate,
                    arrivdate,
                    sourcestatus,
                    deststatus,
                    lbstatus,
                    statusdesc,
                    approvalstatus,
                    exported,
                    updated,
                    lbsource,
                    transmode,
                    ff_trigger_control,
                    statusdescr,
                    loadsw,
                    vendorminmetsw,
                    transmodeminmetsw,
                    tolerancecapmetsw,
                    lanegroupminmetsw,
                    consolidatedloadseqnum,
                    lanegroupid,
                    maxcapacitymetsw,
                    lsrulemetsw,
                    orderid,
                    orderoptseqnum,
                    maxcapacityexceededsw,
                    grouporderid,
                    u_data_source,
                    u_order_conf_orderid,
                    u_delivery_id,
                    u_po_number,
                    u_so_number,
                    u_ord_conf_filename,
                    u_ord_conf_timestamp,
                    u_delivery_filename,
                    u_delivery_timestamp,
                    u_approved_by,
                    u_unapproved_by,
                    u_approval_timestamp,
                    u_unapproval_timestamp,
                    u_source,
                    u_dest,
                    u_dest_descr,
                    u_dest_code_descr,
                    u_original_arrivdate,
                    u_not_arrived_calc,
                    u_so_creation_date,
                    u_deststatus_editable,
                    u_utilization
                ) VALUES (
                    rec.loadid,
                    'SS_CUSTOM',
                    rec.shipdate,
                    rec.arrivdate,
                    1,
                    1,
                    0,
                    ' ',
                    0,
                    0,
                    0,
                    '4',
                    rec.transmode,
                    0,
                    ' ',
                    1,
                    0,
                    v_transmodeminmetsw,
                    0,
                    0,
                    0,
                    ' ',
                    v_maxcapacitymetsw,
                    0,
                    0,
                    0,
                    0,
                    0,
                    NULL,
                    rec.loadid,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL, -- rec.u_source, rec.u_dest,
                    NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    0,
                    rec.utilization
                );

            END IF;

        -- Process data for VehicleLoadLine
            FOR line_rec IN c_vehicleloadline(rec.loadid) LOOP
            -- Check if the record already exists
                SELECT
                    COUNT(*)
                INTO v_count
                FROM
                    scpomgr.vehicleloadline
                WHERE
                        loadid = rec.loadid
                    AND item = line_rec.item;

                IF
                    v_count = 0
                    AND v_transmodeminmetsw <> 0
                THEN
                    INSERT INTO scpomgr.vehicleloadline (
                        loadid,
                        item,
                        qty,
                        supplymethod,
                        loadlineid,
                        cancelsw,
                        reviseddate,
                        actionallowedsw,
                        primaryitem,
                        drawqty,
                        expdate,
                        action,
                        actiondate,
                        actionqty,
                        ordernum,
                        ff_trigger_control,
                        sourcing,
                        mustgoqty,
                        seqnum,
                        schedshipdate,
                        schedarrivdate,
                        lbsource,
                        orderid,
                        supporderqty,
                        revisedexpdate,
                        source,
                        dest,
                        grouporderid,
                        primaryitemqty,
                        supplyid,
                        project,
                        priority,
                        configid,
                        ctoitem,
                        earliestselldate,
                        revisedshipdate,
                        dmdexpdate,
                        revisedearliestselldate,
                        unitprice,
                        totcost,
                        u_order_publication_id,
                        u_order_split_rule,
                        u_exported,
                        u_subitem_override,
                        u_saleability_alert,
                        u_subitem,
                        u_sub_material_number,
                        u_split_order_group,
                        u_disponibile,
                        u_disponibile_prev,
                        u_evaso,
                        u_evaso_prev,
                        u_inevaso,
                        u_inevaso_prev,
                        u_not_arrived_calc,
                        u_evaso_prev1,
                        u_original_source,
                        u_shipdate_promo,
                        u_original_schedarrivdate,
                        u_order_ddn_status_calc,
                        u_qty_quintals,
                        u_qty_euro
                    ) VALUES (
                        rec.loadid,
                        line_rec.item,
                        line_rec.qty,
                        0,
                        1,
                        0,
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        1,
                        line_rec.item,
                        1,
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        0,
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        0,
                        0,
                        0, 
                    --line_rec.source || '_' || line_rec.dest || '_' || substr(line_rec.u_variant_type_desc, 1, 2) || '_' || line_rec.transmode || '_' || line_rec.u_priority, 
                        line_rec.sourcing,
                        line_rec.mustgoqty,
                        0,
                        line_rec.schedshipdate,
                        line_rec.schedarrivdate,
                        4,
                        0,
                        0,
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        line_rec.source,
                        line_rec.dest,
                        0,
                        0, -- line_rec.qty, 
                        NULL,
                        ' ',
                        0,
                        NULL,
                        NULL,
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        TO_DATE('01/01/1970', 'MM/DD/YYYY'),
                        0,
                        0,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        NULL
                    );

                END IF;

            END LOOP;

        END LOOP;
    
        /*
        -- schedshipdate & schedarrivdate need to be same for lane specific 
        for example:
        LOADID	SHIPDATE	ARRIVDATE	U_UTILIZATION
        LPCA_16340_BA_1_1_111224	13-DEC-24	18-DEC-24	91.07
        LPCA_16354_BA_1_1_111224	13-DEC-24	18-DEC-24	66.07
        LPCA_16354_BA_2_1_111224	13-DEC-24	18-DEC-24	57.14
        LPCA_16354_BA_3_1_111224	13-DEC-24	18-DEC-24	89.29
        LPCA_16354_BA_4_1_111224	20-DEC-24	25-DEC-24	100
        
        instead it should be 
        LOADID	SHIPDATE	ARRIVDATE	U_UTILIZATION
        LPCA_16340_BA_1_1_111224	13-DEC-24	18-DEC-24	91.07
        LPCA_16354_BA_1_1_111224	13-DEC-24	18-DEC-24	66.07
        LPCA_16354_BA_2_1_111224	13-DEC-24	18-DEC-24	57.14
        LPCA_16354_BA_3_1_111224	13-DEC-24	18-DEC-24	89.29
        LPCA_16354_BA_4_1_111224	13-DEC-24	18-DEC-24	100
        */
    
        -- Consistent Schedarrivdate in Vehicleloadline with respect to Vehicleload table 
        -- Calculate and update arrival dates based on sourcingid groups
        UPDATE scpomgr.vehicleloadline vll
        SET
            vll.schedshipdate = (
                SELECT
                    vl.shipdate
                FROM
                    scpomgr.vehicleload vl
                WHERE
                    vl.loadid = vll.loadid
            ),
            vll.schedarrivdate = (
                SELECT
                    vl.arrivdate
                FROM
                    scpomgr.vehicleload vl
                WHERE
                    vl.loadid = vll.loadid
            )
        WHERE
            EXISTS (
                SELECT
                    1
                FROM
                    scpomgr.vehicleload vl
                WHERE
                    vl.loadid = vll.loadid
            );

        COMMIT;
    
    -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_insert_vl_vll;

    FUNCTION f_vmi_chk_cal_avl_shipdate (
        p_cal IN VARCHAR2,
        p_schedshipdate IN DATE,
        p_schedarrivdate IN DATE,
        p_buffer_days IN NUMBER
    ) RETURN DATE IS
    /*
    Description:
    - First checks if the date is a bank holiday using the master calendar
    - If it's not a holiday, then checks if opt = 2 exists
    - If opt = 2 exists, considers all non-holiday days as open
    - If opt = 2 doesn't exist, uses the regular pattern checking logic
    */
        -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
    
        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.f_vmi_chk_cal_avl_shipdate';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        v_buffer NUMBER;
        v_pattern_start DATE;
        v_pattern_end DATE;
        v_repeat_days NUMBER;
        v_current_date DATE;
        v_end_date DATE;
        v_master_cal VARCHAR2(100);
        v_is_holiday NUMBER;
        v_is_pattern_day_open NUMBER;
        v_has_opt_2 NUMBER;
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in => 'Started..');
    
        l_v_errstep := 'Calculate f_vmi_chk_cal_avl_shipdate';
        
        v_buffer := NVL(p_buffer_days, 180);
    
        -- Get master calendar if exists
        BEGIN
            SELECT NVL(TRIM(master), '')
            INTO v_master_cal
            FROM scpomgr.cal
            WHERE cal = p_cal;
        END;
    
        -- Check if calendar has opt = 2
        SELECT COUNT(1)
        INTO v_has_opt_2
        FROM scpomgr.caldata c
        WHERE c.cal = p_cal
        AND c.opt = 2;
    
        -- If opt = 2 exists, set repeat_days to 0
        IF v_has_opt_2 > 0 THEN
            v_repeat_days := 0;
        ELSE
            -- Get pattern information for opt = 5
            SELECT MIN(eff_date), MAX(eff_date), NVL(MAX(repeat_days), 7)
            INTO v_pattern_start, v_pattern_end, v_repeat_days
            FROM (
                SELECT 
                    TRUNC((c.eff/1440) + TO_DATE('1970-01-01', 'YYYY-MM-DD')) as eff_date,
                    CASE WHEN c.opt = 5 THEN c.repeat/1440 ELSE NULL END as repeat_days
                FROM scpomgr.caldata c
                WHERE c.cal = p_cal
            );
        END IF;
    
        v_current_date := TRUNC(p_schedshipdate);
        v_end_date := TRUNC(p_schedarrivdate + v_buffer);
    
        WHILE v_current_date <= v_end_date LOOP
            -- First check for bank holidays in master calendar
            IF v_master_cal IS NOT NULL AND LENGTH(TRIM(v_master_cal)) > 0 THEN
                SELECT COUNT(1)
                INTO v_is_holiday
                FROM SCPOMGR.u_mastercal_us c
                WHERE c.cal = v_master_cal
                AND TRUNC(TO_DATE(c.holiday, 'DD-MON-YY')) = TRUNC(v_current_date);
                
                IF v_is_holiday > 0 THEN
                    v_current_date := v_current_date + 1;
                    CONTINUE;
                END IF;
            END IF;
    
            -- If no holidays, check pattern days
            IF v_has_opt_2 > 0 THEN
                -- For opt = 2, all days are open except holidays
                v_is_pattern_day_open := 1;
            ELSE
                -- Check regular pattern (opt = 5 and 2)
                SELECT CASE 
                    WHEN EXISTS (
                        SELECT 1
                        FROM (
                            SELECT TRUNC((c.eff/1440) + TO_DATE('1970-01-01', 'YYYY-MM-DD')) as eff_date,
                                   c.opt
                            FROM scpomgr.caldata c
                            WHERE c.cal = p_cal
                            AND c.opt != 5
                        ) pattern_data
                        WHERE MOD(
                            (TRUNC(v_current_date) - TRUNC(v_pattern_start)), 
                            v_repeat_days
                        ) = MOD(
                            (TRUNC(pattern_data.eff_date) - TRUNC(v_pattern_start)), 
                            v_repeat_days
                        )
                        AND pattern_data.opt = 2
                    ) THEN 1
                    ELSE 0
                END
                INTO v_is_pattern_day_open
                FROM dual;
            END IF;
    
            IF v_is_pattern_day_open = 1 THEN
                RETURN v_current_date;
            END IF;
    
            v_current_date := v_current_date + 1;
        END LOOP;
    
        RETURN p_schedshipdate;
        
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
        -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);
            RAISE_APPLICATION_ERROR(-20001, 'Error in f_vmi_chk_cal_avl_shipdate: ' || SQLERRM);
            RAISE;
    END f_vmi_chk_cal_avl_shipdate;
    
    FUNCTION f_vmi_chk_cal_avl_arrivcal (
        p_cal IN VARCHAR2,
        p_schedshipdate IN DATE,
        p_schedarrivdate IN DATE,
        p_buffer_days IN NUMBER
    ) RETURN DATE IS
     /******************************************************************
      Procedure : f_vmi_chk_cal_avl_arrivcal
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.f_vmi_chk_cal_avl_arrivcal';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        v_buffer NUMBER;
        v_pattern_start DATE;
        v_pattern_end DATE;
        v_repeat_days NUMBER;
        v_current_date DATE;
        v_end_date DATE;
        v_master_cal VARCHAR2(100);
        v_is_holiday NUMBER;
        v_is_pattern_day_open NUMBER;
        v_check_start_date DATE;
        v_check_end_date DATE;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate f_vmi_chk_cal_avl_arrivcal';
        
        
        -- Calculate the date range we need to check
        v_check_start_date := TRUNC(LEAST(p_schedshipdate, p_schedarrivdate));
        v_check_end_date := TRUNC(GREATEST(p_schedshipdate, p_schedarrivdate) + NVL(p_buffer_days, 180));
        v_buffer := NVL(p_buffer_days, 1416);
    
        -- Get master calendar if exists
        BEGIN
            SELECT NVL(TRIM(master), '')
            INTO v_master_cal
            FROM scpomgr.cal
            WHERE cal = p_cal;
        END;
    
        -- Get pattern information
        SELECT MIN(eff_date), MAX(eff_date), NVL(MAX(repeat_days), 7)
        INTO v_pattern_start, v_pattern_end, v_repeat_days
        FROM (
            SELECT 
                TRUNC((c.eff/1440) + TO_DATE('1970-01-01', 'YYYY-MM-DD')) as eff_date,
                CASE WHEN c.opt = 5 THEN c.repeat/1440 ELSE NULL END as repeat_days
            FROM scpomgr.caldata c
            WHERE c.cal = p_cal
        );
    
        -- Initialize search
        v_current_date := TRUNC(GREATEST(p_schedshipdate, p_schedarrivdate));
        v_end_date := v_check_end_date;
        
        -- Main date check loop
        WHILE v_current_date <= v_end_date LOOP
            -- Check if current date is marked in master calendar (either as holiday or related to holiday)
            IF v_master_cal IS NOT NULL AND LENGTH(TRIM(v_master_cal)) > 0 THEN
                SELECT COUNT(1)
                INTO v_is_holiday
                FROM SCPOMGR.u_mastercal_us c -- scpomgr.caldata c
                WHERE c.cal = v_master_cal
                AND TRUNC(TO_DATE(c.holiday, 'DD-MON-YY')) = TRUNC(v_current_date); -- TRUNC((c.eff/1440) + TO_DATE('1970-01-01', 'YYYY-MM-DD'))
                
                IF v_is_holiday > 0 THEN
                    v_current_date := v_current_date + 1;
                    CONTINUE;
                END IF;
            END IF;
            
            -- Check if it's an open day in the pattern
            SELECT CASE 
                WHEN EXISTS (
                    SELECT 1
                    FROM (
                        SELECT TRUNC((c.eff/1440) + TO_DATE('1970-01-01', 'YYYY-MM-DD')) as eff_date,
                               c.opt
                        FROM scpomgr.caldata c
                        WHERE c.cal = p_cal
                        AND c.opt != 5
                    ) pattern_data
                    WHERE MOD(
                        (TRUNC(v_current_date) - TRUNC(v_pattern_start)), 
                        v_repeat_days
                    ) = MOD(
                        (TRUNC(pattern_data.eff_date) - TRUNC(v_pattern_start)), 
                        v_repeat_days
                    )
                    AND pattern_data.opt = 2  -- Open date
                ) THEN 1
                ELSE 0
            END
            INTO v_is_pattern_day_open
            FROM dual;
            
            -- If date passes both checks (not in master calendar AND is an open pattern day), return it
            IF v_is_pattern_day_open = 1 THEN
                RETURN v_current_date;
            END IF;
            
            v_current_date := v_current_date + 1;
        END LOOP;
        
        --debug_print('No valid date found within buffer period');
        RETURN p_schedarrivdate; --NULL;
        
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);
            RAISE_APPLICATION_ERROR(-20001, 'Error in f_vmi_chk_cal_avl_arrivcal: ' || SQLERRM);
            RAISE;
    END f_vmi_chk_cal_avl_arrivcal;
    
    -- Check if a given date is OPEN for arrival
    FUNCTION is_arrival_open (
        p_date      IN DATE,
        p_arrivcal  IN VARCHAR2
    ) RETURN BOOLEAN 
    IS
        v_count NUMBER := 0;
    BEGIN
        -- If no arrival calendar is specified, arrival is always open.
        IF p_arrivcal IS NULL OR TRIM(p_arrivcal) = '' THEN
            RETURN TRUE;
        END IF;

        -- Check if p_date is listed in u_arrivcal_us as an open day.
        SELECT COUNT(1)
          INTO v_count
          FROM scpomgr.u_arrivcal_us
         WHERE cal = p_arrivcal
           AND TRUNC(days_open) = TRUNC(p_date);

        RETURN (v_count > 0);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END is_arrival_open;
    
    -- Check if a given date is OPEN for shipping
    FUNCTION is_shipping_open (
        p_date     IN DATE,
        p_shipcal  IN VARCHAR2
    ) RETURN BOOLEAN 
    IS
        v_count NUMBER := 0;
    BEGIN
        -- If no shipping calendar is specified, shipping is always open.
        IF p_shipcal IS NULL OR TRIM(p_shipcal) = '' THEN
            RETURN TRUE;
        END IF;

        -- If the date is in the closed list, then shipping is not open.
        SELECT COUNT(1)
          INTO v_count
          FROM scpomgr.u_shipcal_us
         WHERE cal = p_shipcal
           AND TRUNC(days_close) = TRUNC(p_date);

        -- shipping is open if v_count = 0 (meaning date not found in closed list).
        RETURN (v_count = 0);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END is_shipping_open;
    
    FUNCTION f_vmi_chk_avl_shipdate_arrivdate (
        p_shipcal         IN VARCHAR2,
        p_arrivcal        IN VARCHAR2,
        p_needarrivdate   IN DATE,
        p_u_dispatchdate  IN DATE,
        p_transleadtime   IN NUMBER,
        p_buffer_days     IN NUMBER DEFAULT 180
    ) 
    RETURN t_sched_dates_rec
    /*---------------------------------------------------------------------
      Procedure : f_vmi_chk_avl_shipdate_arrivdate
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date                Author                    Description
      ----                -----                     ------------
      08-Janurary-2025    Vinay Kumar Govardhanam   New Version
    
     Description:
      1) Goal: Find a valid pair of ‘schedshipdate‘, ‘schedarrivdate‘ such that:
         - schedarrivdate is open in arrival calendar.
         - schedshipdate is open in shipping calendar.
         - schedshipdate >= p_u_dispatchdate.
         - schedarrivdate = schedshipdate + p_transleadtime.
      2) Search Order:
         - Backward First: Start at p_needarrivdate and move backward (up to p_buffer_days).
           If a valid arrival date is found, mark found and exit loop.
         - Forward Next: If backward fails, start at p_needarrivdate and move forward.
           If a valid arrival date is found, mark found and exit loop.
      3) Fallback (or raise error): If no suitable date is found, raise an error.
    
     Returns: t_sched_dates_rec (schedshipdate, schedarrivdate)
    ---------------------------------------------------------------------*/
    IS
        -- Variables for logging
        l_d_start_date_time  iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time    iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep          iio_error_log.error_step%TYPE; 
        l_n_id               iio_interface_timing_log.id%TYPE;
    
        l_v_prog_name        scpomgr.iio_interface_timing_log.program_id%TYPE := 
                                 'US_VMI_STACKABILITY.f_vmi_chk_avl_shipdate_arrivdate';
        l_v_prog_status      scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency        scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        
        
        v_result             t_sched_dates_rec;
        v_found              BOOLEAN := FALSE;
    
        v_arrival_candidate  DATE;
        v_ship_candidate     DATE;
    
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');
    
        l_v_errstep := 'Calculate f_vmi_chk_avl_shipdate_arrivdate';
    
        ----------------------------------------------------------------------
        -- STEP 1: Check if p_needarrivdate itself is open/valid
        ----------------------------------------------------------------------
        IF is_arrival_open(p_needarrivdate, p_arrivcal) THEN
            v_ship_candidate := p_needarrivdate - p_transleadtime;
            IF (v_ship_candidate >= p_u_dispatchdate)
               AND is_shipping_open(v_ship_candidate, p_shipcal)
            THEN
                v_result.schedarrivdate := p_needarrivdate;
                v_result.schedshipdate  := v_ship_candidate;
                v_found := TRUE;
            END IF;
        END IF;
        
        /* ----------------------------------------------------------------------
        Description:
          1) Check p_needarrivdate first:
             - If p_needarrivdate is open in the arrival calendar,
               and (p_needarrivdate - p_transleadtime) is open in the shipping
               calendar and >= p_u_dispatchdate, then use that date pair.
          
          2) If step (1) fails, perform the “backward” search:
             - Actually, we iterate through each date from p_u_dispatchdate 
               up to (but not including) p_needarrivdate in ascending order.
             - For each date S in that range:
               * schedshipdate = S
               * schedarrivdate = S + p_transleadtime
               * If schedarrivdate <= p_needarrivdate, and both shipping and
                 arrival calendars are open on those dates, use that pair.
               * Exit once a valid pair is found.
        
          3) If still no pair is found, perform the “forward” search:
             - From p_needarrivdate up to (p_needarrivdate + p_buffer_days).
             - For each date A in that range:
               * schedarrivdate = A
               * schedshipdate = A - p_transleadtime
               * If schedshipdate >= p_u_dispatchdate, and both shipping and
                 arrival calendars are open on those dates, use that pair.
               * Exit once a valid pair is found.
        
          4) Fallback or raise error:
             - If no suitable date pair is found after these steps,
               raise an application error or handle accordingly.
        
         Returns: t_sched_dates_rec (schedshipdate, schedarrivdate)
        ----------------------------------------------------------------------*/
        
        /*
        ----------------------------------------------------------------------
        -- STEP 2: If not found, do the "backward" search
        --   Actually we iterate "forward" in time from p_u_dispatchdate 
        --   up to (but not including) p_needarrivdate.
        ----------------------------------------------------------------------
        IF NOT v_found THEN
            DECLARE
                v_day_count NUMBER;
            BEGIN
                -- Number of days between dispatch date and need date
                v_day_count := p_needarrivdate - p_u_dispatchdate;
                IF v_day_count < 0 THEN
                    v_day_count := 0;  -- safeguard if dispatch > need date
                END IF;
    
                FOR i IN 0 .. v_day_count LOOP
                    v_ship_candidate := p_u_dispatchdate + i;
                    v_arrival_candidate := v_ship_candidate + p_transleadtime;
                    
                    -- only consider if arrival is strictly before or equal to the needed date
                    IF v_arrival_candidate <= p_needarrivdate THEN
                        IF is_arrival_open(v_arrival_candidate, p_arrivcal)
                           AND is_shipping_open(v_ship_candidate, p_shipcal)
                        THEN
                            v_result.schedarrivdate := v_arrival_candidate;
                            v_result.schedshipdate  := v_ship_candidate;
                            v_found := TRUE;
                        END IF;
                    END IF;
                    
                    IF v_found THEN
                        EXIT;  -- break from the FOR-loop
                    END IF;
                END LOOP;
            END;
        END IF;
    
        ----------------------------------------------------------------------
        -- STEP 3: If not found, do the "forward" search
        -- If still not found, go forward from p_needarrivdate 
        --          up to p_needarrivdate + p_buffer_days
        ----------------------------------------------------------------------
        IF NOT v_found THEN
            FOR i IN 0 .. p_buffer_days LOOP
                v_arrival_candidate := p_needarrivdate + i;
                
                IF is_arrival_open(v_arrival_candidate, p_arrivcal) THEN
                    v_ship_candidate := v_arrival_candidate - p_transleadtime;
                    IF (v_ship_candidate >= p_u_dispatchdate)
                       AND is_shipping_open(v_ship_candidate, p_shipcal)
                    THEN
                        v_result.schedarrivdate := v_arrival_candidate;
                        v_result.schedshipdate  := v_ship_candidate;
                        v_found := TRUE;
                        EXIT;  -- exit loop
                    END IF;
                END IF;
            END LOOP;
        END IF;
        */
        ----------------------------------------------------------------------
        -- 2) Search BACKWARD first
        ----------------------------------------------------------------------
        FOR i IN 0 .. p_buffer_days LOOP
            v_arrival_candidate := p_needarrivdate - i;
    
            -- If we've gone past the backward limit, exit loop
            IF v_arrival_candidate < (p_needarrivdate - p_buffer_days) THEN
                EXIT;
            END IF;
    
            IF is_arrival_open(v_arrival_candidate, p_arrivcal) THEN
                v_ship_candidate := v_arrival_candidate - p_transleadtime;
                IF v_ship_candidate >= p_u_dispatchdate THEN
                    IF is_shipping_open(v_ship_candidate, p_shipcal) THEN
                        v_result.schedarrivdate := v_arrival_candidate;
                        v_result.schedshipdate  := v_ship_candidate;
                        v_found := TRUE;
                        EXIT;  -- Exit the FOR-loop, not the function
                    END IF;
                END IF;
            END IF;
        END LOOP;
    
        ----------------------------------------------------------------------
        -- 3) If still not found, search FORWARD
        ----------------------------------------------------------------------
        IF NOT v_found THEN
            FOR i IN 0 .. p_buffer_days LOOP
                v_arrival_candidate := p_needarrivdate + i;
    
                -- If we've exceeded the forward limit, exit loop
                IF v_arrival_candidate > (p_needarrivdate + p_buffer_days) THEN
                    EXIT;
                END IF;
    
                IF is_arrival_open(v_arrival_candidate, p_arrivcal) THEN
                    v_ship_candidate := v_arrival_candidate - p_transleadtime;
                    IF v_ship_candidate >= p_u_dispatchdate THEN
                        IF is_shipping_open(v_ship_candidate, p_shipcal) THEN
                            v_result.schedarrivdate := v_arrival_candidate;
                            v_result.schedshipdate  := v_ship_candidate;
                            v_found := TRUE;
                            EXIT;  -- Exit the FOR-loop
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    
        ----------------------------------------------------------------------
        -- 4) Final check: if no valid date found, raise an error (or fallback)
        ----------------------------------------------------------------------
        IF NOT v_found THEN
            /*
            -- fallback approach:
            v_result.schedarrivdate := p_needarrivdate;
            v_result.schedshipdate  := GREATEST(p_needarrivdate - p_transleadtime,
                                               p_u_dispatchdate);
            */
            DBMS_OUTPUT.PUT_LINE('p_shipcal: '  || p_shipcal || ' p_arrivcal: ' || p_arrivcal|| ' p_needarrivdate: ' || p_needarrivdate|| ' p_u_dispatchdate: ' || p_u_dispatchdate|| ' p_transleadtime: ' || p_transleadtime|| ' p_buffer_days: ' || p_buffer_days);
            RAISE_APPLICATION_ERROR(-20001, 
                'Error in f_vmi_chk_avl_shipdate_arrivdate: No valid date found.');
        END IF;
    
        -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
        -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
        
        COMMIT;
        
        RETURN v_result;
    
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_chk_avl_shipdate_arrivdate;

    FUNCTION f_vmi_get_pallet_weight (
        p_is_full_pallet BOOLEAN,
        p_ratio          NUMBER,
        p_partial_su     NUMBER,
        p_wgt            NUMBER
    ) RETURN NUMBER IS
     /******************************************************************
      Procedure : F_VMI_get_pallet_weight
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_get_pallet_weight';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        -- This refactored function calculates the exact pallet weight on the fly.
        -- p_wgt is per SU, p_ratio is how many SUs per full pallet.
        -- If p_is_full_pallet = TRUE, returns full pallet weight: ratio * wgt
        -- If p_is_full_pallet = FALSE, returns partial pallet weight: partial_su * wgt
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_get_pallet_weight';
        IF p_is_full_pallet THEN
            RETURN p_ratio * p_wgt;  -- Full pallet weight
        ELSE
            RETURN p_partial_su * p_wgt;  -- Partial pallet weight
        END IF;
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_get_pallet_weight;

    FUNCTION f_vmi_can_stack_plnt (
        bottom_color IN VARCHAR2,
        top_color    IN VARCHAR2
    ) RETURN BOOLEAN IS
     /******************************************************************
      Procedure : F_VMI_can_stack
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_can_stack_plnt';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate can_stack';
        IF stackability_map.EXISTS(bottom_color) THEN
            RETURN stackability_map(bottom_color) LIKE '%'
                                                       || top_color
                                                       || '%';
        ELSE
            RETURN false;
        END IF;
     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_can_stack_plnt;

    FUNCTION f_vmi_get_next_top_color (
        bottom_color     IN VARCHAR2,
        available_demand IN OUT demand_list
    ) RETURN VARCHAR2 IS
      /******************************************************************
      Procedure : F_VMI_get_next_top_color
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_get_next_top_color';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_get_next_top_color';
        FOR i IN 1..available_demand.count LOOP
            IF
                f_vmi_can_stack_plnt(bottom_color, available_demand(i).color)
                AND available_demand(i).quantity > 0
            THEN
                RETURN available_demand(i).color;
            END IF;
        END LOOP;

        RETURN 'EMPTY';
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_get_next_top_color;

    FUNCTION f_vmi_seq_get_next_top_color (
        bottom_color          IN VARCHAR2,
        bottom_sourcingid_seq IN NUMBER,
        available_demand      IN OUT demand_list
    ) RETURN VARCHAR2 IS

        next_color          VARCHAR2(100) := 'EMPTY';
    /******************************************************************
      Procedure : F_VMI_seq_get_next_top_color
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_seq_get_next_top_color';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate F_VMI_seq_get_next_top_color';
        FOR i IN 1..available_demand.count LOOP
            IF
                f_vmi_can_stack_plnt(bottom_color, available_demand(i).color)
                AND available_demand(i).quantity > 0
                AND available_demand(i).sourcingid_seq = bottom_sourcingid_seq
            THEN
                next_color := available_demand(i).color;
                EXIT;
            END IF;
        END LOOP;

        RETURN next_color;
     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_seq_get_next_top_color;

    FUNCTION f_vmi_is_stackable (
        color IN VARCHAR2
    ) RETURN BOOLEAN IS
    /******************************************************************
      Procedure : F_VMI_is_stackable
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_is_stackable';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate F_VMI_is_stackable';
        RETURN color NOT IN ( 'SS', 'RED' );
     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_is_stackable;

    FUNCTION f_vmi_is_single_stack (
        color IN VARCHAR2
    ) RETURN BOOLEAN IS
    /******************************************************************
      Procedure : F_VMI_is_single_stack
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_is_single_stack';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_is_single_stack';
        RETURN color IN ( 'SS', 'RED', 'YELLOW' );
        
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_is_single_stack;

    FUNCTION f_vmi_has_remaining_demand (
        available_demand IN demand_list
    ) RETURN BOOLEAN IS
    /******************************************************************
      Procedure : F_VMI_has_remaining_demand
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_has_remaining_demand';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate F_VMI_has_remaining_demand';
        FOR i IN 1..available_demand.count LOOP
            IF available_demand(i).quantity > 0 THEN
                RETURN true;
            END IF;
        END LOOP;

        RETURN false;
--     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_has_remaining_demand;

    FUNCTION f_vmi_calculate_utilization_plnt (
        p_bottom_row IN sys.odcivarchar2list,
        p_top_row    IN sys.odcivarchar2list,
        max_pallets  NUMBER
    ) RETURN NUMBER IS

        -- Color counts for proper doubling
        v_red_count    NUMBER := 0;
        v_ss_count     NUMBER := 0;
        v_other_count  NUMBER := 0;
        v_unavailable_count NUMBER := 0;
        v_total_slots_used NUMBER := 0;
        v_utilization  NUMBER := 0;
    /******************************************************************
      Procedure : F_VMI_calculate_utilization_plnt
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_calculate_utilization_plnt';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate F_VMI_calculate_utilization_plnt';

        -- Basic null/empty check for safety
        IF p_bottom_row IS NULL OR p_bottom_row.count = 0 THEN
            RETURN 0; -- No bottom row means zero utilization
        END IF;
        
        -- Avoid division by zero if max_pallets is invalid
        IF max_pallets IS NULL OR max_pallets <= 0 THEN
            -- Decide how to handle this: return 0, NULL, or raise an error?
            RETURN 0; -- Returning 0 for now
        END IF;
        
        -- Count colors in bottom row
        FOR i IN 1..p_bottom_row.count LOOP
            IF p_bottom_row(i) != 'EMPTY' THEN
                IF p_bottom_row(i) = 'unavailable' THEN
                    v_unavailable_count := v_unavailable_count + 1;
                ELSIF p_bottom_row(i) = 'RED' THEN
                    v_red_count := v_red_count + 1;
                ELSIF p_bottom_row(i) = 'SS' THEN
                    v_ss_count := v_ss_count + 1;
                ELSE
                    v_other_count := v_other_count + 1;
                END IF;
            END IF;
        END LOOP;
        
        -- Count colors in top row
        IF p_top_row IS NOT NULL THEN
            FOR i IN 1..p_top_row.count LOOP
                IF i <= p_top_row.count AND p_top_row(i) != 'EMPTY' THEN
                    IF p_top_row(i) = 'unavailable' THEN
                        v_unavailable_count := v_unavailable_count + 1;
                    ELSIF p_top_row(i) = 'RED' THEN
                        v_red_count := v_red_count + 1;
                    ELSIF p_top_row(i) = 'SS' THEN
                        v_ss_count := v_ss_count + 1;
                    ELSE
                        v_other_count := v_other_count + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        -- Calculate total slots used 
        -- Apply doubling for RED/SS at global level
        -- Include unavailable as they represent used capacity
        v_total_slots_used := (v_red_count * 2) + (v_ss_count * 2) + 
                              v_other_count + v_unavailable_count;
        
        /*
        -- Debug output
        DBMS_OUTPUT.PUT_LINE('Truck Utilization Details:');
        DBMS_OUTPUT.PUT_LINE('  RED: ' || v_red_count || ' (uses ' || (v_red_count * 2) || ' slots)');
        DBMS_OUTPUT.PUT_LINE('  SS: ' || v_ss_count || ' (uses ' || (v_ss_count * 2) || ' slots)');
        DBMS_OUTPUT.PUT_LINE('  Others: ' || v_other_count || ' (uses ' || v_other_count || ' slots)');
        DBMS_OUTPUT.PUT_LINE('  Unavailable: ' || v_unavailable_count || ' (blocked slots)');
        DBMS_OUTPUT.PUT_LINE('  Total used: ' || v_total_slots_used || ' / ' || max_pallets);
        */
        
        -- Calculate utilization using the passed u_adjustedmaxcap
        IF max_pallets > 0 THEN
            v_utilization := (v_total_slots_used / max_pallets) * 100;
            -- Cap at 100%
            v_utilization := LEAST(v_utilization, 100);
        ELSE
            v_utilization := 0;
        END IF;
        
        RETURN v_utilization;
        
--     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_calculate_utilization_plnt;

    FUNCTION f_vmi_calculate_truck_utilization (
        p_sourcingid NUMBER,
        p_loadid     NUMBER
    ) RETURN NUMBER IS

        v_total_pallets     NUMBER;
        v_max_pallets       NUMBER;
        v_utilization       NUMBER;
     /******************************************************************
      Procedure : F_VMI_calculate_truck_utilization
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_calculate_truck_utilization';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_calculate_truck_utilization';
        SELECT
            SUM(
                CASE
                    WHEN u_stackabilitytype IN('RED', 'SS') THEN
                        2
                    ELSE
                        1
                END
            )
        INTO v_total_pallets
        FROM
            batchmgr.temp_visualization_results
        WHERE
                sourcingid = p_sourcingid
            AND loadid = p_loadid;

        SELECT
            MAX(u_adjustedmaxcap)
        INTO v_max_pallets
        FROM
            batchmgr.udc_recship
        WHERE
            sourcingid = p_sourcingid;

        v_utilization := ( v_total_pallets / v_max_pallets ) * 100;

--        log_debug('Final Report for sourcingid ' || p_sourcingid || ', loadid ' || p_loadid || 
--                  ': Total pallets = ' || TO_CHAR(v_total_pallets, 'FM999.00') || 
--                  ', Max pallets = ' || v_max_pallets || 
--                  ', Utilization = ' || TO_CHAR(v_utilization, 'FM990.00') || '%');

        RETURN v_utilization;
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_calculate_truck_utilization;

    FUNCTION f_vmi_calculate_utilization_hub (
        bottom_row  IN sys.odcivarchar2list,
        top_row     IN sys.odcivarchar2list,
        max_pallets NUMBER
    ) RETURN NUMBER IS
      /******************************************************************
      Procedure : F_VMI_calculate_utilization_hub
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_calculate_utilization_hub';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_total_pallets     NUMBER := 0;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_calculate_utilization_hub';
        
        -- Safety check
        IF bottom_row IS NULL OR top_row IS NULL OR max_pallets IS NULL OR max_pallets = 0 THEN
            RETURN 0;
        END IF;
    
        -- Count pallets
        FOR i IN 1..bottom_row.COUNT LOOP
            IF bottom_row(i) != 'EMPTY' THEN
                v_total_pallets := v_total_pallets + 1;
            END IF;
    
            IF i <= top_row.COUNT AND top_row(i) NOT IN ('EMPTY', 'unavailable') THEN
                v_total_pallets := v_total_pallets + 1;
            END IF;
        END LOOP;
    
        -- Calculate utilization
        RETURN ROUND((v_total_pallets / NULLIF(max_pallets, 0)) * 100, 2);
      
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);
            
            --RETURN 0;

            RAISE;
    END f_vmi_calculate_utilization_hub;

    FUNCTION f_vmi_can_add_pallet (
        p_u_stackabilitytype VARCHAR2
    ) RETURN BOOLEAN IS
      /******************************************************************
      Procedure : F_VMI_CAN_ADD_PALLET
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
--        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
--        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
--        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
--        l_n_id              iio_interface_timing_log.id%TYPE;
--
--        -- Initialize variables
--        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_CAN_ADD_PALLET';
--        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
--        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
--       -- Initialize interface start time
--        l_d_start_date_time := systimestamp;
--        
--      -- Interface Status logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
--        'Started..');
--
--        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
--        l_v_errstep := 'Calculate F_VMI_CAN_ADD_PALLET';

        -------------------------- Old Code --------------------------
--        FOR i IN 1..truck_item_capacities.count LOOP
--            dbms_output.put_line('item_constraints: ' || item_constraints(i).max_capacity);
--            dbms_output.put_line('truck_item_capacities: ' || truck_item_capacities(i).current_count);
--            IF truck_item_capacities(i).u_stackabilitytype = p_u_stackabilitytype THEN
--                RETURN truck_item_capacities(i).current_count < item_constraints(i).max_capacity;
--            END IF;
--        END LOOP;
--
--        RETURN false; -- If u_stackabilitytype not found

        -------------------------- New Code --------------------------
        -- If no capacities have been set, then by default return false.
        IF truck_item_capacities.count = 0 OR item_constraints.count = 0 THEN
            RETURN false;
        END IF;
        
        -- Loop through the capacities collection to find the matching color.
        FOR i IN 1 .. truck_item_capacities.count LOOP
            IF truck_item_capacities(i).u_stackabilitytype = p_u_stackabilitytype THEN
                -- Make sure the constraints collection has a corresponding element.
                IF i <= item_constraints.count THEN
                    RETURN truck_item_capacities(i).current_count < item_constraints(i).max_capacity;
                ELSE
                    RETURN false;
                END IF;
            END IF;
        END LOOP;
        
        -- If no matching color is found, return false.
        RETURN false;

     -- Set Interface end time and successful status of the program
--        l_d_end_date_time := systimestamp;
--        l_v_prog_status := 'SUCCESS';
--        
--      -- Interface Execution Time logging
--        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                      l_v_frequency_in => l_v_frequency);
--         
      -- Commit the transaction
        COMMIT;
--    EXCEPTION
--        WHEN OTHERS THEN
--         -- Interface Error logging
--            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
--            sqlerrm, l_v_errorrecord_in => NULL,
--                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);
--
--         -- Interface Time logging
--            l_d_end_date_time := systimestamp;
--            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
--            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
--                                          l_v_frequency_in => l_v_frequency);
--
--            RAISE;
    END f_vmi_can_add_pallet;
    
    FUNCTION f_vmi_check_sourcingmin (
        p_sourcingid NUMBER,
        p_loadid     NUMBER,
        p_u_variant_type_desc VARCHAR2,
        p_u_priority NUMBER
    ) RETURN BOOLEAN IS
      /******************************************************************
      Procedure : F_VMI_check_sourcingmin
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_check_sourcingmin';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
        v_total_pallets     NUMBER;
        v_u_sourcingmin     NUMBER;
        v_second_pallets    FLOAT;
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate F_VMI_check_sourcingmin';

        SELECT
            nvl(MIN(u_sourcingmin), 0)
        INTO v_u_sourcingmin
        FROM
            batchmgr.u_recship
        WHERE
                sourcingid = p_sourcingid
            AND substr(u_variant_type_desc,1,2) = substr(p_u_variant_type_desc,1,2)
            AND u_priority = p_u_priority
            AND ROWNUM = 1;


        SELECT
            --NVL(SUM(pallets_qty), 0) -- new change
            COUNT(distinct STACK_POSITION || LOAD_SEQUENCE) -- old code
        INTO v_total_pallets
        FROM
            batchmgr.u_recship
        WHERE
                sourcingid = p_sourcingid
            AND loadid = p_loadid
            AND substr(u_variant_type_desc,1,2) = substr(p_u_variant_type_desc,1,2)
            AND u_priority = p_u_priority
            AND condition = 'FIRST';
        
        SELECT
            NVL(sum(pallets_qty),0)
        INTO v_second_pallets
        FROM
            batchmgr.u_recship
        WHERE
                sourcingid = p_sourcingid
            AND loadid = p_loadid
            AND substr(u_variant_type_desc,1,2) = substr(p_u_variant_type_desc,1,2)
            AND u_priority = p_u_priority
            AND condition = 'SECOND';
            
        v_second_pallets := FLOOR(v_second_pallets) + (CASE WHEN (v_second_pallets - FLOOR(v_second_pallets)) > 0 THEN 1 ELSE 0 END);
            
        v_total_pallets := v_total_pallets + v_second_pallets;

        RETURN v_total_pallets >= v_u_sourcingmin;
     -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END f_vmi_check_sourcingmin;

    FUNCTION f_vmi_can_stack_hub (
        bottom_color IN VARCHAR2,
        top_color    IN VARCHAR2
    ) RETURN BOOLEAN IS
      /******************************************************************
      Function : F_VMI_can_stack_hub
      Description : Determines if a pallet with top_color can be stacked on a pallet with bottom_color
                    Enhanced with NULL checking to prevent ORA-06502 errors
      Input Parameters: bottom_color - Color/type of the bottom pallet
                        top_color - Color/type of the top pallet
      Output: Boolean - TRUE if stacking is allowed, FALSE otherwise
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      13-May-2025     Vinay Kumar Govardhanam   Added NULL handling and enhanced logging
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- Define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE;
        l_n_id              iio_interface_timing_log.id%TYPE;
        v_result            BOOLEAN;
    
        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.F_VMI_can_stack_hub';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
        -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
        -- Interface Status logging with parameter info
        l_v_errstep := 'Starting F_VMI_can_stack_hub with params - Bottom: ' || 
                       NVL(bottom_color, 'NULL') || ', Top: ' || NVL(top_color, 'NULL');
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                      l_d_startdatetime_in => l_d_start_date_time, 
                                      l_v_progstatus_in => 'Started..');
    
        -- Check for NULL input parameters
        IF bottom_color IS NULL OR top_color IS NULL THEN
            RETURN FALSE;
        END IF;
    
        -- Use the stackability map logic from plant functions 
        -- But with hub-specific rules
        IF bottom_color IN ('SS', 'RED') THEN
            v_result := FALSE;
        ELSIF top_color IN ('SS', 'RED', 'BLACK') THEN
            v_result := FALSE;
        -- Check stackability map for more complex rules
        ELSIF stackability_map.EXISTS(bottom_color) THEN
            -- Check if top_color is in the comma-separated list of stackable colors
            v_result := INSTR(',' || stackability_map(bottom_color) || ',', ',' || top_color || ',') > 0;
        ELSE
            v_result := TRUE; -- Default to true if no specific rule
        END IF;
    
        RETURN v_result;
        
        -- Success path
        l_v_prog_status := 'SUCCESS';
        l_d_end_date_time := systimestamp;
        
        -- Interface Execution Time logging  
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                     l_d_startdatetime_in => l_d_start_date_time, 
                                     l_d_enddatetime_in => l_d_end_date_time, 
                                     l_v_progstatus_in => l_v_prog_status,
                                     l_v_frequency_in => l_v_frequency);
    EXCEPTION
        WHEN OTHERS THEN
            -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, 
                                   l_d_datetime_in => sysdate, 
                                   l_v_errorid_in => sqlcode, 
                                   l_v_errormessage_in => sqlerrm, 
                                   l_v_errorrecord_in => 'Bottom: ' || NVL(bottom_color, 'NULL') || 
                                                        ', Top: ' || NVL(top_color, 'NULL'),
                                   l_v_errorstep_in => l_v_errstep, 
                                   l_v_frequency_in => l_v_frequency);
    
            -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, 
                                         l_d_startdatetime_in => l_d_start_date_time, 
                                         l_d_enddatetime_in => l_d_end_date_time, 
                                         l_v_progstatus_in => l_v_prog_status,
                                         l_v_frequency_in => l_v_frequency);
    
            -- Default to FALSE in case of any error
            RETURN FALSE;
    END f_vmi_can_stack_hub;
    
    -- Get numeric priority for a color
    FUNCTION get_color_priority(p_color VARCHAR2) RETURN NUMBER IS
    BEGIN
        RETURN v_color_priority(p_color);
    EXCEPTION
    WHEN OTHERS THEN
      RETURN 999; -- Default high number for unknown colors
    END;
    
    PROCEDURE color_sort(p_low IN PLS_INTEGER, p_high IN PLS_INTEGER) IS
        v_pivot_color VARCHAR2(10);
        v_pivot_priority NUMBER;
        i PLS_INTEGER;
        j PLS_INTEGER;
        v_temp demand_rec;
    BEGIN
        IF p_low < p_high THEN
          -- Select middle element as pivot 
          v_pivot_color := demands((p_low + p_high)/2).color;
          v_pivot_priority := get_color_priority(v_pivot_color);
          
          i := p_low;
          j := p_high;
          
          LOOP
            -- Find element on left that should be on right
            WHILE get_color_priority(demands(i).color) < v_pivot_priority LOOP
              i := i + 1;
              EXIT WHEN i > p_high;
            END LOOP;
            
            -- Find element on right that should be on left
            WHILE get_color_priority(demands(j).color) > v_pivot_priority LOOP
              j := j - 1;
              EXIT WHEN j < p_low;
            END LOOP;
            
            -- If we've found a pair to swap
            IF i <= j THEN
              -- Swap elements
              v_temp := demands(i);
              demands(i) := demands(j);
              demands(j) := v_temp;
              
              i := i + 1;
              j := j - 1;
            END IF;
            
            EXIT WHEN i > j;
          END LOOP;
          
          -- Recursively sort the smaller partitions
          IF p_low < j THEN
            color_sort(p_low, j);
          END IF;
          
          IF i < p_high THEN
            color_sort(i, p_high);
          END IF;
        END IF;
    END color_sort;
    
    -- Custom hub color sort procedure
    PROCEDURE hub_color_sort(
        p_pallets IN OUT pallet_list_info,
        p_low IN PLS_INTEGER,
        p_high IN PLS_INTEGER,
        p_color_priority IN color_priority_map
    ) IS
        -- Variables for quicksort
        i PLS_INTEGER;
        j PLS_INTEGER;
        pivot_color VARCHAR2(100);
        pivot_priority NUMBER;
        temp each_pallet_info;
        
        -- Function to safely get color priority
        FUNCTION get_safe_priority(p_color VARCHAR2) RETURN NUMBER IS
        BEGIN
            IF p_color IS NULL THEN
                RETURN 999;
            ELSIF p_color_priority.EXISTS(p_color) THEN
                RETURN p_color_priority(p_color);
            ELSE
                RETURN 999;
            END IF;
        END get_safe_priority;
    BEGIN
        IF p_low < p_high THEN
            -- Select middle element as pivot
            pivot_color := NVL(p_pallets((p_low + p_high) / 2).u_stackabilitytype, 'UNKNOWN');
            pivot_priority := get_safe_priority(pivot_color);
            
            -- Debug
            --dbms_output.put_line('Pivot: ' || pivot_color || ' with priority ' || pivot_priority);
            
            i := p_low;
            j := p_high;
            
            LOOP
                -- Move i right until we find element >= pivot_priority
                WHILE i <= p_high AND get_safe_priority(p_pallets(i).u_stackabilitytype) < pivot_priority LOOP
                    i := i + 1;
                END LOOP;
                
                -- Move j left until we find element <= pivot_priority
                WHILE j >= p_low AND get_safe_priority(p_pallets(j).u_stackabilitytype) > pivot_priority LOOP
                    j := j - 1;
                END LOOP;
                
                -- If pointers crossed, exit loop
                IF i > j THEN
                    EXIT;
                END IF;
                
                -- Swap elements
                temp := p_pallets(i);
                p_pallets(i) := p_pallets(j);
                p_pallets(j) := temp;
                
                -- Debug swap
                --dbms_output.put_line('Swapped: ' || p_pallets(j).u_stackabilitytype || ' with ' || p_pallets(i).u_stackabilitytype);
                
                i := i + 1;
                j := j - 1;
            END LOOP;
            
            -- Recursively sort sub-arrays
            IF p_low < j THEN
                hub_color_sort(p_pallets, p_low, j, p_color_priority);
            END IF;
            
            IF i < p_high THEN
                hub_color_sort(p_pallets, i, p_high, p_color_priority);
            END IF;
        END IF;
    END hub_color_sort;

    -- Main optimization procedure
    PROCEDURE p_vmi_data_dump_udc_recship IS
    /******************************************************************
      Procedure : p_vmi_data_dump_udc_recship
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_data_dump_udc_recship';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate p_vmi_data_dump_udc_recship';

        -- Starting of the process
        p_vmi_backuptables;
        p_vmi_intializingthevalues;
        p_vmi_insert_into_udcrecship;
        p_vmi_insert_into_priorityshift;
        p_vmi_update_udc_recship;
        COMMIT;

         -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_data_dump_udc_recship;
    
    -- Main optimization procedure
    PROCEDURE p_vmi_stackability_logic IS
    /******************************************************************
      Procedure : p_vmi_stackability_logic
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.p_vmi_stackability_logic';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        --EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate p_vmi_stackability_logic';

        -- Starting of the process
        p_vmi_optimize_load;
        p_vmi_calculate_utilization_trucks;
        p_vmi_process_priority_shift;
        p_vmi_calculate_utilization_trucks;
        p_vmi_merge_load;
        p_vmi_calculate_utilization_trucks;
        p_vmi_update_salesunits_qty_sourcing;
        p_vmi_delete_mincapacity;
        p_vmi_update_schedarrivdate_schedshipdate;
        COMMIT;

         -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_stackability_logic;
    
    PROCEDURE p_vmi_run_optimization IS
    /******************************************************************
      Procedure : P_VMI_run_optimization
      Description : tbd
      Output Parameters: None
      Error Conditions Raised: When Others
      Author: Vinay Govardhanam
      Revision History:
      ------------------
      Date            Author                    Description
      ----            -----                     ------------
      15-July-2024    Sahil Chawla              Initial Version
      06-June-2024    Vinay Kumar Govardhanam   Modified Version
      24/10/2024      Pavan Kumar               Conversion of Scripts to Package Standards and Logging Mechanism Implementation
      *******************************************************************/
      -- define variables
        l_d_start_date_time iio_interface_timing_log.start_date_time%TYPE;
        l_d_end_date_time   iio_interface_timing_log.end_date_time%TYPE;
        l_v_errstep         iio_error_log.error_step%TYPE; -- This variable is used to identify the error step
        l_n_id              iio_interface_timing_log.id%TYPE;

        -- Initialize variables
        l_v_prog_name       scpomgr.iio_interface_timing_log.program_id%TYPE := 'US_VMI_STACKABILITY.P_VMI_run_optimization';
        l_v_prog_status     scpomgr.iio_interface_timing_log.prog_status%TYPE := 'FAILURE';
        l_v_frequency       scpomgr.iio_interface_timing_log.log_frequency%TYPE := 'WEEKLY';
    BEGIN
       -- Initialize interface start time
        l_d_start_date_time := systimestamp;
        
      -- Interface Status logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_v_progstatus_in =>
        'Started..');

        EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
        l_v_errstep := 'Calculate P_VMI_run_optimization';
        
        Delete /*+ PARALLEL(16) */ from iio_interface_timing_log where  start_date_time < sysdate -7 ;
        commit;
        -- Starting of the process
        p_vmi_data_dump_udc_recship;
        p_vmi_stackability_logic;
        p_vmi_insert_vl_vll;
        COMMIT;

         -- Set Interface end time and successful status of the program
        l_d_end_date_time := systimestamp;
        l_v_prog_status := 'SUCCESS';
        
      -- Interface Execution Time logging
        pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
        l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                      l_v_frequency_in => l_v_frequency);
         
      -- Commit the transaction
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
         -- Interface Error logging
            pkg_iio_util.p_error_log(l_v_programid_in => l_v_prog_name, l_d_datetime_in => sysdate, l_v_errorid_in => sqlcode, l_v_errormessage_in =>
            sqlerrm, l_v_errorrecord_in => NULL,
                                    l_v_errorstep_in => l_v_errstep, l_v_frequency_in => l_v_frequency);

         -- Interface Time logging
            l_d_end_date_time := systimestamp;
            pkg_iio_util.p_obj_runtime_log(l_n_id, l_v_programid_in => l_v_prog_name, l_d_startdatetime_in => l_d_start_date_time, l_d_enddatetime_in =>
            l_d_end_date_time, l_v_progstatus_in => l_v_prog_status,
                                          l_v_frequency_in => l_v_frequency);

            RAISE;
    END p_vmi_run_optimization;

END us_vmi_stackability;
